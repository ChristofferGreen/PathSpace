Mermaid rendering: Enabled
PlantUML rendering: Enabled
SVG in markdown rendering: Enabled
Data presentation: prefer tables (auto-columns)

You are an expert C++ developer tasked with analysing and improving a piece of C++ code.

Conduct an in-depth analysis of the code. Consider the following aspects:

Code structure and organisation
Naming conventions and readability
Efficiency and performance
Potential bugs or errors
Adherence to C++ best practices and C++ community guidelines
Use of appropriate data structures and algorithms
Error handling and edge cases
Modularity and reusability
Comments and documentation
Write your analysis inside <analysis> tags. Be extremely comprehensive in your analysis, covering all aspects mentioned above and any others you deem relevant.

Using chain of thought prompting, explain how to fix issues. Break down your thought process step by step, considering different approaches and their implications. Write your explanation inside <fix_explanation> tags.
Reason out the problem carefully and in step by step manner. You may use the space <thinking></thinking> as your scratchpad and will not be considered by the reader.
Based on your analysis and the fixes you've proposed, come up with a search term that might be useful to find additional information or solutions. Write your search term inside <search_term> tags.

Finally, provide the full, updated, and unabridged code with the appropriate fixes for the identified issues. Remember:

Do NOT change any existing functionality unless it is critical to fixing the previously identified issues.
Only make changes that directly address the identified issues or significantly improve the code based on your analysis.
Ensure that all original functionality remains intact.
You can take multiple messages to complete this task if necessary. Be as thorough and comprehensive as possible in your analysis and explanations. Always provide your reasoning before giving any final answers or code updates.
<!-- === ./README.md === -->
<README.md>
# PathSpace

PathSpace is a new coordination language that draws inspiration from other coordination languages such as Linda, as well as concepts from reactive programming and data-oriented design. It provides a tuplespace-like system for managing typed hierarchical streams of data and computations.

## Introduction

PathSpace is designed to be a foundational component for larger systems, such as:
- Game engines
- Visualization engines
- Web-based book readers
- Any application requiring a tree-like structure for storing typed distributed data in a thread-safe manner

It's intended to be a multi-platform library supporting at least Windows, Linux, Android, macOS, and iOS.

## Key Features

- **Hierarchical Structure**: Similar to a file system, with PathSpaces as folders and Data as files
- **Typed Data Storage**: Supports various data types, including user-defined serializable classes and lambda functions
- **Polymorphism**: Allows user-supplied child classes to behave differently in different parts of the tree
- **Thread-Safe Operations**: All PathSpace operations are designed to be thread-safe
- **Glob Expressions**: Supports glob-style path matching for flexible data access
- **JSON Serialization**: Built-in support for JSON serialization and deserialization
- **Capability-based Access Control**: Fine-grained control over data access and operations

## Core Operations

1. **Insert**: Add data or a PathSpace to one or more paths
2. **Read**: Retrieve a copy of the value at a specified path
3. **Extract**: Similar to read, but removes the data from the PathSpace

## Advanced Features

- **Blocking Operations**: Wait for data to become available
- **Execution Management**: Support for lambda functions and delayed execution
- **Data Compression**: Automatic data compression and decompression
- **Out-of-core Storage**: Ability to store data on disk instead of RAM
- **Reactive Programming Support**: Enables creation of reactive data flows
- **Distributed Data Management**: Replication of spaces across multiple computers (planned)

## Use Cases

PathSpace can be used to implement various systems, including:
- Scene graphs for 3D renderers
- Vulkan renderers with easy mesh and shader management
- Just-in-time geometry generation systems
- Operating system-like environments with user and file system management
- Database front-ends</README.md>

<!-- === ./docs/design.md === -->
<design.md>
# PathSpace
![PathSpace](images/PathSpace.jpeg)

## Introduction
PathSpace is a coordination language that enables insertion and extractions from paths in a thread safe datastructure. The data structure supports views of the paths similar to Plan 9. The data attached to the paths are more like a JSON datastructure than files though. The data supported is standard C++ data types and data structures from the standard library, user created structs/classes as well as function pointers, std::function or function objects for storing executions that generate values to be inserted at a path.

## Internal Data
PathSpace can be seen as a map between a path and a vector of data. Inserting more data to the path will append it to the end. Reading data from the path will return a copy of the front data. Extracting data from a path will pop and return the front data of the vector for the path.

## Syntax Example
```
PathSpace space;
space.insert("/collection/numbers", 5);
space.insert("/collection/numbers", 3.5f);
assert(space.extract<int>("/collection/numbers").value() == 5);
assert(space.read<float>("/collection/numbers").value() == 3.5);

space.insert("/collection/executions", [](){return 7;});
assert(space.extractBlock<int>("/collection/numbers").value() == 7);
```

## Polymorphism
The internal spaces inside a path are implemented witha  PathSpaceLeaf class, it's possible to inherit from that class and insert that child class in order to change the
behaviour of parts of the path structure of a PathSpace instance. This can be used to have different behaviour for different sub spaces within a PathSpace. By default PathSpace
will create a PathSpaceLeaf of the same type as the parent when creating new ones (which happens during insert of data).

## Path Globbing
Paths given to insert can be a glob expression, if the expression matches the names of subspaces then the data will be inserted to all the matching subspaces.
````
PathSpace space;
space.insert("/collection/numbers", 5);
space.insert("/collection/numbers_more", 4);
space.insert("/collection/other_things", 3);
space.insert("/collection/numbers*", 2);
assert(space.extract<int>("/collection/other_things").value() == 2);
assert(!space.extract<int>("/collection/other_things").has_value());
assert(space.extract<int>("/collection/numbers_more").value() == 4);
assert(space.extract<int>("/collection/numbers_more").value() == 2);
```

## Blocking
It's possible to send a blocking object to insert/read/extract instructing it to wait a certain amount of time for data to arrive if it is currently empty or non-existent.


## Operations
The operations in the base language are insert/read/extract, they are implemented as member functions of the PathSpace class.
* **Insert**: 
	* Insert data or a PathSpaceLeaf to one or more paths. If the path does not exist it will be created.
	* The given path can be a concrete path in which case at most one object will be inserted or a glob expression path which could potentially insert multiple values.
	* Supports batch operations by inserting an initialiser list
	* Takes an optional InOptions which has the following properties:
		* Optional Execution object that describes how to execute the data (if the data is a lambda or function):
			* Execute immediately or when the user requests the data via read/extract.
			* If the data should be cached and updated every n milliseconds.
				* How many times the function should be executed.
			* If the value to be stored is executed in a lazy fashion or right away.
		* Optional Block object specifying what to do if the value does not (yet) exist, enables waiting forever or a set amount of time.
	* The data inserted can be:
		* Executions with signature T() or T(ConcretePath const &path, PathSpace &space) :
			* Lambda
			* Function pointer
			* std::function
			* Preregistered executions for serialisation/deserialisation over the network.
		* Data
			* Fundamental types
			* Standard library containers if serialisable
			* User created structures/classes as long as they are serialisable
	* Returns an InsertReturn structure with the following information:
		* How many items/Tasks were inserted.
		* What errors occurred during insertion.
	* Syntax:
		* InsertReturn PathSpace::insert<T>(GlobPath const &path, T const &value, optional<InOptions> const &options={})
* **Read**:
	* Returns a copy of the front value at the supplied path or Error if it could not be found, if for example the path did not exist or the front value had the wrong type.
	* Takes an optional ReadOptions which has the following properties:
		* Optional Block object specifying what to do if the data does not exist or paths to the data do not exist:
			* Wait forever if data/space does not exist
			* Wait a specified amount of milliseconds if data/space does not exist
			* Return an error
	* Takes a ConcretePath, does not support GlobPaths. Perhaps will implement a readMultiple later that returns a vector<T>
	* Syntax:
		* std::expected<T, Error> PathSpace::read<T>(ConcretePath const &path, optional<ReadOptions> const &options={})
* **Extract**: 
	* Same as read but pops the front data instead of just returning a copy.
	* Syntax:
		* std::expected<T, Error> PathSpace::extract<T>(ConcretePath, Block, optional<OutOptions> const &options={})

## Data Storage
A normal PathSpace will store data by serialising it to a std::vector<std::byte>. That vector can contain data of different types and a separate vector storing std::type_id pointers
together with how many objects or that type are in a row will be used to determine what parts of the data vector has what type. std::function objects will be stored in their own vector
as well since they can not be serialised. Insert will append serialised data to this vector. Extract will not necessarily erase from the front of the vector since this would be too costly,
a pointer to the front element will instead be stored and its position changed forward when a extract is issued. At first the serialisation will be done via the alpaca library but when a
compiler supporting the C++26 serialisation functionality it will be rewritten to use that instead.

## Unit Testing
Unit testing will be done by using the C++ doctest library. A test driven development method will be used.

## Logging
A log of every action can be produced. This is mostly for aiding in debugging.

## Exception Handling
PathSpaces will not throw exceptions, all errors will be handled via the return type of the operations.

## Licensing
PathSpace will be under an open source license, likely GPL-3.

## Trellis
Lazy executions can be chained together via blocking operations waiting for new data, when one execution updates a value another listener to that value can execute.
This creates a trellis like structure as described in the book mirror worlds book where values are fed from bottom processes and filtered up into higher order processes.

## Actor Based Programming
An actor system could be implemented with PathSpace by having executions within the PathSpace as actors communicating via messages sent to mailboxes at predefined paths, the mailboxes
could simply be std::string objects stored at those paths.

## Bottlenecks
Linda like tuple spaces have traditionally been seen as slow. To some degree this is due to the pattern matching required to extract data from a tuple. 
### Path Caching
In PathSpace the slowest part will be traversing the path hierarchy. Potentially this could be sped up if we provide a cache of the most recent lookups of paths for insert/read/extract.
Could be done as a hashmap from a ConcretePath to a PathSpace*. Would need to clear the cache on extract, or other PathSpace removals.

### Reactive programming
The extendability of a PathSpace can be used to create a reactive data flow, for example by creating a child PathSpace that takes n other PathSpace paths as input and combines their
values by extractbing from them or a PathSpace that performs a transformation on any data from n other paths. Each tuple can be seen as a data stream as long as they are alive, when
they run out of items the stream dies. One example could be a lambda within the space that waits for the left mouse button to be pressed via space.read<int>(“/system/mouse/button_down”,
ReadOptions{.block=true}).

## Example Use Cases
* Scene Graph - Objects to be displayed by a 3d renderer. Mainly takes care of seamlessly interacting with the renderer to upload and display objects in the graph. Could also support data oriented design by having composable objects that store their properties in a list instead of objects in a list.
* Vulcan Render - A renderer that integrates with the GPU via Vulcan. Makes it easy to upload and use meshes and shaders.
* ISO Surface Generator - Just in time generation of geometry to display, taking LOD into account. It can have an internal path like …/generate/x_y_y that can be read to start the generation.
* Operating System - The capabilities functionality can be used to implement a user system and file system similar to Unix. When the initial PathSpace has been filled a process for the root user with full capability can be started by launching a lambda that executes a script. This is similar to how on login a bash session is started with a default script. This process can in turn launch other processes similar to systemd or cron.
* Database front end - Interpreter to a proper database library adding or changing data within it. For example mariadb or postgressql.
* GraphQL server to interact with html/javascript

## Not Yet Implemented Features

### Temporary Data Path
Will not write out any data for state saving and if a user logs out all their created data will be deleted. Will usually be at /tmp, with user dirs as /tmp/username.

### Scripting
There will be support for manipulating a PathSpace through lua. Issuing an operator can then be done without having to reference a space object, like so: insert(“/a”, 5).
But separate space objects could be created as variables in the script and could be used by the normal space_name.insert(… usage.

### Command line
Using a live script interpreter a command line can be written.

### Compression
Compresses the input data seamlessly behind the scene on insert and decompresses it on read/extract.

### Out-of-core
Similar to compression but can store the data on the hard drive instead of in RAM.

### Distributed Data
Another specialisation is to create a PathSpace child that can replicate a space over several computers over the network. Duplicating data where needed. May use Asia for networking.
Like a live object.

## Memory (not yet implemented)
In order to avoid memory allocation calls to the operating system the PathSpace could have a pre-allocated pool of memory from the start. Perhaps some PathSpace tuple data could be marked
as non essential somehow, if an out of memory situation occurs such data could be erased or flushed to disk. The alpha version of PathSpace will not contain this feature and will allocate
all memory via std standard allocators.

## Metadata (not yet implemented)
Every PathSpace will have some metadata such as last time read, last time modified, how many times modified (same as version). Testing will be done by using a special CMake project that uses one .cpp file per operation to test.

## Documentation (not yet implemented)
Documentation with examples and descriptions of the API will be provided on the GitHub page for the project.

### Metrics Collection (not yet implemented)
Will be possible to collect metrics on the data for the paths, how often they are accessed etc.

### Data Integrity (not yet implemented)
Especially for the networking part some checking for data consistency will be needed.

## Distributed Networking
### Transaction Support
TBD
### Multi-Version Consistency Control
TBD
### Conflict-Free Replicated Data Types
TBD
### Invariant-based Reasoning
TBD

### Version Migration Utilities
TBD

## Back-Pressure Handling
TBD

## Default Paths
TBD

## Live Objects
TBD

## Fault Tolerance
TBD

## Views
TBD

## Operating System
TBD</design.md>

<!-- === ./src/pathspace/PathSpace.hpp === -->
<PathSpace.hpp>
#pragma once
#include "PathSpaceLeaf.hpp"
#include "core/OutOptions.hpp"
#include "core/TaskToken.hpp"
#include "core/WaitMap.hpp"
#include "path/GlobPath.hpp"
#include "taskpool/TaskPool.hpp"
#include "utils/TaggedLogger.hpp"

namespace SP {
class PathSpace {
public:
    /**
     * @brief Constructs a PathSpace object.
     * @param pool Pointer to a TaskPool for managing asynchronous operations. If nullptr, uses the global instance.
     */
    explicit PathSpace(TaskPool* pool = nullptr);
    ~PathSpace();

    /**
     * @brief Inserts data into the PathSpace at the specified path.
     *
     * @tparam DataType The type of data being inserted.
     * @param path The glob-style path where the data should be inserted.
     * @param data The data to be inserted.
     * @param options Options controlling the insertion behavior, such as overwrite policies.
     * @return InsertReturn object containing information about the insertion operation, including any errors.
     */
    template <typename DataType>
    auto insert(GlobPathStringView const& path, DataType&& data, InOptions const& options = {}) -> InsertReturn {
        log("PathSpace::insert", "Function Called");
        InputData inputData{std::forward<DataType>(data)};
        ConstructiblePath constructedPath = path.isConcrete() ? ConstructiblePath{path} : ConstructiblePath{};

        if (inputData.metadata.category == DataCategory::ExecutionFunctionPointer
            || inputData.metadata.category == DataCategory::ExecutionStdFunction) {
            bool const isImmidiate
                    = (!options.execution.has_value())
                      || (options.execution.has_value() && options.execution.value().category == ExecutionOptions::Category::Immediate);
            bool const isOnReadOrExtract
                    = options.execution.has_value() && options.execution.value().category == ExecutionOptions::Category::OnReadOrExtract;
            if (std::optional<Task> task = this->createTask(constructedPath, std::forward<DataType>(data), inputData, options)) {
                if (isImmidiate) {
                    this->pool->addTask(std::move(task.value()));
                    return {.nbrTasksCreated = 1};
                } else if (isOnReadOrExtract) {
                    inputData.task = std::move(task);
                }
            }
        }

        return this->in(constructedPath, path, inputData, options);
    }

    /**
     * @brief Reads data from the PathSpace at the specified path.
     *
     * @tparam DataType The type of data to be read.
     * @param path The concrete path from which to read the data.
     * @param options Options controlling the read behavior, such as blocking policies.
     * @return Expected<DataType> containing the read data if successful, or an error if not.
     */
    template <typename DataType>
    auto read(ConcretePathStringView const& path, OutOptions const& options = {.doPop = false}) const -> Expected<DataType> {
        log("PathSpace::read", "Function Called");
        if (options.doPop)
            return std::unexpected(Error{Error::Code::PopInRead, std::string("read does not support doPop: ").append(path.getPath())});
        DataType obj;
        if (auto ret = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj); !ret)
            return std::unexpected(ret.error());
        return obj;
    }

    template <typename DataType>
    auto readBlock(ConcretePathStringView const& path,
                   OutOptions const& options = {.block{{.behavior = BlockOptions::Behavior::Wait}}, .doPop = false}) const
            -> Expected<DataType> {
        log("PathSpace::readBlock", "Function Called");
        DataType obj;
        auto result = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj);

        if (result.has_value() || !options.block.has_value()
            || (options.block.has_value() && options.block.value().behavior == BlockOptions::Behavior::DontWait)) {
            if (result.has_value() && result.value() > 0) {
                return obj;
            }
            std::unexpected(result.error());
        }

        bool const exitLoopAfterFirstRun = options.block && options.block->timeout;
        auto const timeout = (options.block && options.block->timeout) ? std::chrono::system_clock::now() + *options.block->timeout
                                                                       : std::chrono::system_clock::time_point::max();
        auto guard = waitMap.wait(path);
        while (!result.has_value()) {
            if (guard.wait_until(timeout, [&]() {
                    result = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj);
                    return (result.has_value() && result.value() > 0);
                })) {
                break;
            }
            if (exitLoopAfterFirstRun)
                break;
        }

        if (result.has_value() && result.value() > 0) {
            return obj;
        }
        return std::unexpected(result.error());
    }

    /**
     * @brief Reads and removes data from the PathSpace at the specified path.
     *
     * @tparam DataType The type of data to be extractbed.
     * @param path The concrete path from which to extract the data.
     * @return Expected<DataType> containing the extractbed data if successful, or an error if not.
     */
    template <typename DataType>
    auto extract(ConcretePathStringView const& path, OutOptions const& options = {}) -> Expected<DataType> {
        log("PathSpace::extract", "Function Called");
        DataType obj;
        auto const ret = this->out(path, InputMetadataT<DataType>{}, options, &obj);
        if (!ret)
            return std::unexpected(ret.error());
        if (ret.has_value() && (ret.value() == 0))
            return std::unexpected(Error{Error::Code::NoObjectFound, std::string("Object not found at: ").append(path.getPath())});
        return obj;
    }

    template <typename DataType>
    auto extractBlock(ConcretePathStringView const& path, OutOptions const& options = {.block{{.behavior = BlockOptions::Behavior::Wait}}})
            -> Expected<DataType> {
        log("PathSpace::extractBlock", "Function Called");
        DataType obj;
        auto result = this->out(path, InputMetadataT<DataType>{}, options, &obj);

        if (result.has_value() || !options.block.has_value()
            || (options.block.has_value() && options.block.value().behavior == BlockOptions::Behavior::DontWait)) {
            if (result.has_value() && result.value() > 0) {
                return obj;
            }
            return std::unexpected(result.error());
        }

        bool const exitLoopAfterFirstRun = options.block && options.block->timeout;
        auto const timeout = (options.block && options.block->timeout) ? std::chrono::system_clock::now() + *options.block->timeout
                                                                       : std::chrono::system_clock::time_point::max();
        auto guard = waitMap.wait(path);
        while (!result.has_value()) {
            if (guard.wait_until(timeout, [&]() {
                    result = this->out(path, InputMetadataT<DataType>{}, options, &obj);
                    return (result.has_value() && result.value() > 0);
                })) {
                break;
            }
            if (exitLoopAfterFirstRun)
                break;
        }

        if (result.has_value() && result.value() > 0) {
            return obj;
        }
        return std::unexpected(result.error());
    }

    auto clear() -> void;

protected:
    template <typename DataType>
    auto createTask(ConstructiblePath const& constructedPath, DataType const& data, InputData const& inputData, InOptions const& options)
            -> std::optional<Task> { // ToDo:: Add support for glob based executions
        log("PathSpace::createTask", "Function Called");
        if (!this->taskToken.isValid()) {
            return std::nullopt;
        }
        bool const shouldRegisterNow
                = !options.execution.has_value()
                  || (options.execution.has_value() && options.execution.value().category == ExecutionOptions::Category::Immediate);

        if (shouldRegisterNow) {
            this->taskToken.registerTask();
        }
        if constexpr (ExecutionFunctionPointer<DataType> || ExecutionStdFunction<DataType>) {
            auto function = [userFunction = std::move(data)](Task const& task, void* obj, bool isOut) {
                if (!task.token || !task.token->isValid()) {
                    return;
                }
                try {
                    if (isOut) {
                        *static_cast<std::function<std::invoke_result_t<DataType>()>*>(obj) = userFunction;
                    } else {
                        if (obj == nullptr) {
                            assert(task.space != nullptr);
                            task.space->insert(task.pathToInsertReturnValueTo.getPath(), userFunction());
                        } else {
                            *static_cast<std::invoke_result_t<DataType>*>(obj) = userFunction();
                        }
                    }
                } catch (...) {
                    if (task.token)
                        task.token->unregisterTask();
                    throw;
                }
            };
            return Task{.space = this,
                        .token = &taskToken,
                        .pathToInsertReturnValueTo = constructedPath,
                        .executionOptions = options.execution.has_value() ? options.execution.value() : ExecutionOptions{},
                        .function = std::move(function)};
        }
        return std::nullopt;
    }

    virtual auto in(ConstructiblePath& constructedPath, GlobPathStringView const& path, InputData const& data, InOptions const& options)
            -> InsertReturn;

    virtual auto out(ConcretePathStringView const& path, InputMetadata const& inputMetadata, OutOptions const& options, void* obj)
            -> Expected<int>;

    auto shutdown() -> void;

    TaskPool* pool = nullptr;
    TaskToken taskToken;
    PathSpaceLeaf root;
    mutable WaitMap waitMap;
};

} // namespace SP</PathSpace.hpp>

<!-- === ./src/pathspace/type/InputData.hpp === -->
<InputData.hpp>
#pragma once
#include "pathspace/type/InputMetadata.hpp"

#include <functional>

namespace SP {
struct Task;

struct InputData {
    template <typename T>
    InputData(T&& in) : metadata(InputMetadataT<T>{}) {
        if constexpr (std::is_function_v<std::remove_pointer_t<std::decay_t<T>>> || std::is_member_function_pointer_v<std::decay_t<T>>) {
            this->obj = reinterpret_cast<void*>(+in);
        } else {
            this->obj = const_cast<void*>(static_cast<const void*>(&in));
        }
    }

    void* obj = nullptr;
    std::optional<Task> task;
    InputMetadata metadata;
};

} // namespace SP</InputData.hpp>

<!-- === ./src/pathspace/type/InputMetadataT.hpp === -->
<InputMetadataT.hpp>
#pragma once
#include "type/helpers/serialization_alpaca.hpp"
// #include "type/helpers/serialization_glaze.hpp"
</InputMetadataT.hpp>

<!-- === ./src/pathspace/type/helpers/serialization_glaze.hpp === -->
<serialization_glaze.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "pathspace/taskpool/TaskPool.hpp"
#include "type/helpers/return_type.hpp"

#include <cassert>

#include "glaze/glaze.hpp"
#define SERIALIZATION_TYPE std::byte
namespace SP {

template <typename T>
static auto serialize_glaze(void const* objPtr, std::vector<std::byte>& bytes) -> void {
    T const& obj = *static_cast<T const*>(objPtr);
    std::vector<std::byte> tmp;
    glz::write_binary_untagged(obj, tmp);
    bytes.insert(bytes.end(), tmp.begin(), tmp.end());
}

template <typename T>
static auto deserialize_glaze(void* objPtr, std::vector<std::byte> const& bytes) -> void {
    T* obj = static_cast<T*>(objPtr);
    auto error = glz::read_binary_untagged(obj, bytes);
    assert(!error);
}

template <typename T>
static auto deserialize_pop_glaze(void* objPtr, std::vector<std::byte>& bytes) -> void {
    deserialize_glaze<T>(objPtr, bytes);
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(T));
}

template <typename CVRefT>
struct InputMetadataT {
    using T = std::remove_cvref_t<CVRefT>;
    InputMetadataT() = default;

    static constexpr auto serialize = &serialize_glaze<T>;
    static constexpr auto deserialize = &deserialize_glaze<T>;
    static constexpr auto deserializePop = &deserialize_pop_glaze<T>;
};

} // namespace SP</serialization_glaze.hpp>

<!-- === ./src/pathspace/type/helpers/return_type.hpp === -->
<return_type.hpp>
#pragma once
/*
    Defines a helper template ReturnTypeInfo that can return a type_info pointer
    for any type. If the type is a function pointer, it will return the return value type.
*/

template <typename T>
struct return_type_helper {
    using type = std::remove_cvref_t<T>;
};

template <typename R, typename... Args>
struct return_type_helper<R (*)(Args...)> {
    using type = R;
};

template <typename R, typename... Args>
struct return_type_helper<R(Args...)> {
    using type = R;
};

template <typename T>
concept Invocable = requires(T t) { std::invoke(t); };

template <Invocable T>
struct return_type_helper<T> {
    using type = std::invoke_result_t<T>;
};

template <typename T>
std::type_info const* ReturnTypeInfo = &typeid(typename return_type_helper<std::remove_cvref_t<T>>::type);</return_type.hpp>

<!-- === ./src/pathspace/type/helpers/serialization_alpaca.hpp === -->
<serialization_alpaca.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "taskpool/TaskPool.hpp"
#include "type/DataCategory.hpp"
#include "type/helpers/return_type.hpp"
#include "utils/TaggedLogger.hpp"

#include <cassert>
#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <type_traits>
#include <vector>

#define SERIALIZATION_TYPE uint8_t
#include <alpaca/alpaca.h>

namespace SP {
struct PathSpace;

// ########### Alpaca Serialization ###########

template <typename T>
static auto serialize_alpaca(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    struct Wrapper {
        T wrappedObject;
    };
    Wrapper wrapper{*static_cast<T const*>(objPtr)};

    try {
        // Serialize the object
        std::vector<uint8_t> tempBytes;
        size_t bytesWritten = alpaca::serialize<Wrapper, 1>(wrapper, tempBytes);

        // Store the size of the serialized data
        uint32_t size = static_cast<uint32_t>(bytesWritten);
        bytes.insert(bytes.end(), reinterpret_cast<const uint8_t*>(&size), reinterpret_cast<const uint8_t*>(&size) + sizeof(size));

        // Append the serialized data
        bytes.insert(bytes.end(), tempBytes.begin(), tempBytes.begin() + bytesWritten);

        log("Object serialized successfully", "INFO");
    } catch (const std::exception& e) {
        log("Serialization failed: " + std::string(e.what()), "ERROR");
        throw;
    }
}

template <typename T>
static auto deserialize_alpaca_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    if (bytes.size() < sizeof(uint32_t)) {
        log("Not enough data to read size", "ERROR");
        throw std::runtime_error("Not enough data to read size");
    }

    uint32_t size;
    std::memcpy(&size, bytes.data(), sizeof(uint32_t));

    if (bytes.size() < sizeof(uint32_t) + size) {
        log("Not enough data to deserialize object", "ERROR");
        throw std::runtime_error("Not enough data to deserialize object");
    }

    struct Wrapper {
        T wrappedObject;
    };

    std::error_code ec;
    std::vector<uint8_t> deserializeBytes(bytes.begin() + sizeof(uint32_t), bytes.begin() + sizeof(uint32_t) + size);
    auto wrapper = alpaca::deserialize<Wrapper, 1>(deserializeBytes, ec);

    if (ec) {
        log("Deserialization failed: " + ec.message(), "ERROR");
        throw std::runtime_error("Deserialization failed: " + ec.message());
    }

    // Copy the deserialized object to the output
    *static_cast<T*>(objPtr) = std::move(wrapper.wrappedObject);

    // Remove the read data from the input vector
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(uint32_t) + size);

    log("Object deserialized successfully", "INFO");
}

template <typename T>
static auto deserialize_alpaca_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    if (bytes.size() < sizeof(uint32_t)) {
        log("Not enough data to read size", "ERROR");
        throw std::runtime_error("Not enough data to read size");
    }

    uint32_t size;
    std::memcpy(&size, bytes.data(), sizeof(uint32_t));

    if (bytes.size() < sizeof(uint32_t) + size) {
        log("Not enough data to deserialize object", "ERROR");
        throw std::runtime_error("Not enough data to deserialize object");
    }

    struct Wrapper {
        T wrappedObject;
    };

    std::error_code ec;
    std::vector<uint8_t> deserializeBytes(bytes.begin() + sizeof(uint32_t), bytes.begin() + sizeof(uint32_t) + size);
    auto wrapper = alpaca::deserialize<Wrapper, 1>(deserializeBytes, ec);

    if (ec) {
        log("Deserialization failed: " + ec.message(), "ERROR");
        throw std::runtime_error("Deserialization failed: " + ec.message());
    }

    // Copy the deserialized object to the output
    *static_cast<T*>(objPtr) = std::move(wrapper.wrappedObject);

    log("Object deserialized successfully", "INFO");
}

template <typename T>
concept AlpacaCompatible = !std::is_pointer_v<T> && requires(T t, std::vector<uint8_t>& v) {
    { serialize_alpaca<T>(static_cast<void const*>(&t), v) };
    { deserialize_alpaca_const<T>(static_cast<void*>(&t), v) };
};

// ########### Fundamental Datatype Serialization ###########

template <typename T>
static auto serialize_fundamental(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    static_assert(std::is_fundamental_v<T>, "T must be a fundamental type");
    T const& obj = *static_cast<T const*>(objPtr);
    auto const* begin = reinterpret_cast<uint8_t const*>(&obj);
    auto const* end = begin + sizeof(T);
    bytes.insert(bytes.end(), begin, end);
}

template <typename T>
static auto deserialize_fundamental_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    static_assert(std::is_fundamental_v<T>, "T must be a fundamental type");
    if (bytes.size() < sizeof(T)) {
        return;
    }
    T* obj = static_cast<T*>(objPtr);
    std::copy(bytes.begin(), bytes.begin() + sizeof(T), reinterpret_cast<uint8_t*>(obj));
}

template <typename T>
static auto deserialize_fundamental_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    deserialize_fundamental_const<T>(objPtr, bytes);
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(T));
}

static auto serialize_function_pointer(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    auto funcPtr = *static_cast<void (**)()>(const_cast<void*>(objPtr));
    auto funcPtrInt = reinterpret_cast<std::uintptr_t>(funcPtr);
    auto const* begin = reinterpret_cast<uint8_t const*>(&funcPtrInt);
    auto const* end = begin + sizeof(funcPtrInt);
    bytes.insert(bytes.end(), begin, end);
}

static auto deserialize_function_pointer_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    if (bytes.size() < sizeof(std::uintptr_t)) {
        return;
    }
    std::uintptr_t funcPtrInt;
    std::copy(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t), reinterpret_cast<uint8_t*>(&funcPtrInt));
    auto funcPtr = reinterpret_cast<void (*)()>(funcPtrInt);
    *static_cast<void (**)()>(objPtr) = funcPtr;
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t));
}

static auto deserialize_function_pointer_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    if (bytes.size() < sizeof(std::uintptr_t)) {
        return;
    }
    std::uintptr_t funcPtrInt;
    std::copy(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t), reinterpret_cast<uint8_t*>(&funcPtrInt));
    auto funcPtr = reinterpret_cast<void (*)()>(funcPtrInt);
    *static_cast<void (**)()>(objPtr) = funcPtr;
}

template <typename T>
concept FunctionPointer = requires {
    requires std::is_pointer_v<T>;
    requires std::is_function_v<std::remove_pointer_t<T>>;
};

template <typename T>
concept ExecutionFunctionPointer
        = (std::is_function_v<std::remove_pointer_t<T>> || std::is_member_function_pointer_v<T> || requires(T& t) { +t; })
          && // Unary plus operator, which attempts to convert to function pointer
          requires(T t) {
              t(); // Can be called with no arguments
          };

template <typename T, typename R = void>
concept ExecutionStdFunction = requires(T f) { requires std::is_convertible_v<T, std::function<R()>>; };

template <typename CVRefT>
struct InputMetadataT {
    using T = std::remove_cvref_t<CVRefT>;
    InputMetadataT() = default;

    static constexpr std::type_info const* typeInfo = []() {
        if constexpr (ExecutionFunctionPointer<T> || ExecutionStdFunction<T>) {
            return &typeid(std::invoke_result_t<T>);
        }
        return &typeid(T);
    }();

    static constexpr DataCategory const category = []() {
        if constexpr (ExecutionFunctionPointer<T>) {
            return DataCategory::ExecutionFunctionPointer;
        } else if constexpr (FunctionPointer<T>) {
            return DataCategory::FunctionPointer;
        } else if constexpr (ExecutionStdFunction<T>) {
            return DataCategory::ExecutionStdFunction;
        } else if constexpr (std::is_fundamental<T>::value) {
            return DataCategory::Fundamental;
        } else if constexpr (AlpacaCompatible<T>) {
            return DataCategory::SerializationLibraryCompatible;
        } else {
            return DataCategory::None;
        }
    }();

    static constexpr auto serialize = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return &serialize_function_pointer;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &serialize_fundamental<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &serialize_alpaca<T>;
        } else {
            return nullptr;
        }
    }();

    static constexpr auto deserialize = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return deserialize_function_pointer_const;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (FunctionPointer<T>) {
            return &deserialize_function_pointer_const;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &deserialize_fundamental_const<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &deserialize_alpaca_const<T>;
        } else {
            return nullptr;
        }
    }();

    static constexpr auto deserializePop = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return &deserialize_function_pointer_pop;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (FunctionPointer<T>) {
            return nullptr;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &deserialize_fundamental_pop<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &deserialize_alpaca_pop<T>;
        } else {
            return nullptr;
        }
    }();
};

} // namespace SP
</serialization_alpaca.hpp>

<!-- === ./src/pathspace/type/InputMetadata.hpp === -->
<InputMetadata.hpp>
#pragma once
#include <type_traits>
#include <typeinfo>

#include "pathspace/type/DataCategory.hpp"
#include "pathspace/type/InputMetadataT.hpp"

namespace SP {

struct InputMetadata {
    InputMetadata() = default;
    template <typename CVRefT, typename T = std::remove_cvref_t<CVRefT>>
    InputMetadata(InputMetadataT<CVRefT> const& obj)
        : category(obj.category), typeInfo(obj.typeInfo), serialize(obj.serialize), deserialize(obj.deserialize),
          deserializePop(obj.deserializePop) {
    }

    DataCategory category;
    std::type_info const* typeInfo = nullptr;
    void (*serialize)(void const* obj, std::vector<SERIALIZATION_TYPE>&) = nullptr;
    void (*deserialize)(void* obj, std::vector<SERIALIZATION_TYPE> const&) = nullptr;
    void (*deserializePop)(void* obj, std::vector<SERIALIZATION_TYPE>&) = nullptr;
};

} // namespace SP</InputMetadata.hpp>

<!-- === ./src/pathspace/type/DataCategory.hpp === -->
<DataCategory.hpp>
#pragma once
#include <typeinfo>

namespace SP {

enum struct DataCategory {
    None = 0,
    SerializedData,
    ExecutionFunctionPointer,
    FunctionPointer,
    ExecutionStdFunction,
    Fundamental,
    SerializationLibraryCompatible
};

} // namespace SP</DataCategory.hpp>

<!-- === ./src/pathspace/type/NodeDataHashMap.hpp === -->
<NodeDataHashMap.hpp>
#pragma once
#include "core/NodeData.hpp"
#include "path/ConcreteName.hpp"

#include <parallel_hashmap/phmap.h>

namespace SP {
class PathSpaceLeaf;
class PathSpace;
using NodeDataHashMap = phmap::parallel_node_hash_map<
        SP::ConcreteNameString,
        std::variant<SP::NodeData, std::unique_ptr<SP::PathSpaceLeaf>>,
        std::hash<SP::ConcreteNameString>,
        std::equal_to<SP::ConcreteNameString>,
        std::allocator<std::pair<const SP::ConcreteNameString, std::variant<SP::NodeData, std::unique_ptr<SP::PathSpaceLeaf>>>>,
        12, // Number of submaps
        std::mutex>;

} // namespace SP
</NodeDataHashMap.hpp>

<!-- === ./src/pathspace/PathSpaceLeaf.hpp === -->
<PathSpaceLeaf.hpp>
#pragma once
#include "path/ConcretePathIterator.hpp"
#include "path/GlobPathIterator.hpp"
#include "type/NodeDataHashMap.hpp"

namespace SP {
struct Error;
struct InOptions;
struct InsertReturn;
struct InputData;
struct OutOptions;
struct ConstructiblePath;

class PathSpaceLeaf {
public:
    auto in(ConstructiblePath& path,
            GlobPathIteratorStringView const& iter,
            GlobPathIteratorStringView const& end,
            InputData const& inputData,
            InOptions const& options,
            InsertReturn& ret) -> void;
    auto out(ConcretePathIteratorStringView const& iter,
             ConcretePathIteratorStringView const& end,
             InputMetadata const& inputMetadata,
             void* obj,
             OutOptions const& options) -> Expected<int>;

    auto clear() -> void;

private:
    auto inFinalComponent(ConstructiblePath& path,
                          GlobName const& pathComponent,
                          InputData const& inputData,
                          InOptions const& options,
                          InsertReturn& ret) -> void;
    auto inIntermediateComponent(ConstructiblePath& path,
                                 GlobPathIteratorStringView const& iter,
                                 GlobPathIteratorStringView const& end,
                                 GlobName const& pathComponent,
                                 InputData const& inputData,
                                 InOptions const& options,
                                 InsertReturn& ret) -> void;

    auto outDataName(ConcreteNameStringView const& concreteName,
                     ConcretePathIteratorStringView const& nextIter,
                     ConcretePathIteratorStringView const& end,
                     InputMetadata const& inputMetadata,
                     void* obj,
                     OutOptions const& options) -> Expected<int>;
    auto outConcretePathComponent(ConcretePathIteratorStringView const& nextIter,
                                  ConcretePathIteratorStringView const& end,
                                  ConcreteNameStringView const& concreteName,
                                  InputMetadata const& inputMetadata,
                                  void* obj,
                                  OutOptions const& options) -> Expected<int>;
    NodeDataHashMap nodeDataMap;
};

} // namespace SP</PathSpaceLeaf.hpp>

<!-- === ./src/pathspace/core/ExecutionOptions.hpp === -->
<ExecutionOptions.hpp>
#pragma once
#include <chrono>

namespace SP {

struct ExecutionOptions {
    enum class Category {
        Immediate,
        OnReadOrExtract,
        PeriodicImmidiate,
        PeriodicOnRead,
        Never
    };
    enum class Location {
        Any,
        MainThread
    };
    enum class Priority {
        Low,
        Middle,
        High
    };

    Category category = Category::Immediate;
    Location location = Location::Any;
    Priority priority = Priority::Middle;
    std::optional<std::chrono::milliseconds> updateInterval;
    std::optional<uint32_t> maxNbrExecutions;
    bool cacheResult = false; // Converts function pointer/object to stored value for future read/extract operations
};

} // namespace SP</ExecutionOptions.hpp>

<!-- === ./src/pathspace/core/InOptions.hpp === -->
<InOptions.hpp>
#pragma once
#include "BlockOptions.hpp"
#include "ExecutionOptions.hpp"

#include <optional>

namespace SP {

struct InOptions {
    std::optional<ExecutionOptions> execution;
    std::optional<BlockOptions> block;
    std::optional<int> maxInsertionsForBlob;
    bool createDirectoriesAlongPath = true;
};

} // namespace SP</InOptions.hpp>

<!-- === ./src/pathspace/core/TaskRegistration.hpp === -->
<TaskRegistration.hpp>
#pragma once
#include "core/TaskToken.hpp"

namespace SP {

class PathSpace;

class TaskRegistration {
public:
    explicit TaskRegistration(TaskToken* t) : token(t) {
        if (token)
            token->registerTask();
    }

    // Non-copyable
    TaskRegistration(const TaskRegistration&) = delete;
    TaskRegistration& operator=(const TaskRegistration&) = delete;

    // Moveable
    TaskRegistration(TaskRegistration&& other) noexcept : token(other.token) {
        other.token = nullptr;
    }

    TaskRegistration& operator=(TaskRegistration&& other) noexcept {
        if (this != &other) {
            if (token)
                token->unregisterTask();
            token = other.token;
            other.token = nullptr;
        }
        return *this;
    }

    ~TaskRegistration() {
        if (token)
            token->unregisterTask();
    }

private:
    TaskToken* token;
};

} // namespace SP</TaskRegistration.hpp>

<!-- === ./src/pathspace/core/WaitMap.hpp === -->
<WaitMap.hpp>
#pragma once
#include "path/ConcretePath.hpp"
#include <chrono>
#include <condition_variable>
#include <mutex>
#include <unordered_map>

namespace SP {

struct WaitMap {
    struct Guard {
        Guard(WaitMap& waitMap, ConcretePathString const& path, std::unique_lock<std::mutex> lock)
            : waitMap(waitMap), path(path), lock(std::move(lock)) {
        }

        template <typename Pred>
        bool wait_until(std::chrono::time_point<std::chrono::system_clock> timeout, Pred pred) {
            return waitMap.getCv(path).wait_until(lock, timeout, std::move(pred));
        }

    private:
        WaitMap& waitMap;
        ConcretePathString path;
        std::unique_lock<std::mutex> lock;
    };

    auto wait(ConcretePathStringView const& path) -> Guard {
        return Guard(*this, ConcretePathString{path.getPath()}, std::unique_lock<std::mutex>(mutex));
    }

    auto notify(ConcretePathStringView const& path) -> void {
        std::lock_guard<std::mutex> lock(mutex);
        auto it = cvMap.find(ConcretePathString{path.getPath()});
        if (it != cvMap.end()) {
            it->second.notify_all();
        }
    }

    auto notifyAll() -> void {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto& [_, cv] : cvMap) {
            cv.notify_all();
        }
    }

    auto clear() -> void {
        std::lock_guard<std::mutex> lock(mutex);
        cvMap.clear();
    }

private:
    friend struct Guard;

    auto getCv(ConcretePathString const& path) -> std::condition_variable& {
        return cvMap[path];
    }

    mutable std::mutex mutex;
    std::unordered_map<ConcretePathString, std::condition_variable> cvMap;
};

} // namespace SP</WaitMap.hpp>

<!-- === ./src/pathspace/core/NodeData.hpp === -->
<NodeData.hpp>
#pragma once

#include "ElementType.hpp"
#include "Error.hpp"
#include "ExecutionOptions.hpp"
#include "InOptions.hpp"
#include "InsertReturn.hpp"
#include "core/TaskRegistration.hpp"
#include "type/DataCategory.hpp"
#include "type/InputData.hpp"
#include "type/InputMetadata.hpp"

#include <cassert>
#include <deque>
#include <expected>
#include <optional>

namespace SP {

struct NodeData {
    NodeData() = default;
    NodeData(InputData const& inputData, InOptions const& options, InsertReturn& ret) {
        this->serialize(inputData, options, ret);
    }

    auto serialize(const InputData& inputData, const InOptions& options, InsertReturn& ret) -> std::optional<Error> {
        if (inputData.task.has_value()) {
            this->tasks.push_back(std::move(inputData.task.value()));
            ret.nbrTasksCreated++;
        } else {
            if (!inputData.metadata.serialize)
                return Error{Error::Code::SerializationFunctionMissing, "Serialization function is missing."};
            inputData.metadata.serialize(inputData.obj, data);
        }
        pushType(inputData.metadata);
        return std::nullopt;
    }

    auto deserialize(void* obj, const InputMetadata& inputMetadata, std::optional<ExecutionOptions> const& execution) const
            -> Expected<int> {
        return const_cast<NodeData*>(this)->deserializeImpl(obj, inputMetadata, execution, false);
    }

    auto deserializePop(void* obj, const InputMetadata& inputMetadata) -> Expected<int> {
        return deserializeImpl(obj, inputMetadata, std::nullopt, true);
    }

private:
    std::vector<SERIALIZATION_TYPE> data;
    std::deque<Task> tasks;
    std::deque<ElementType> types;

    auto deserializeImpl(void* obj, const InputMetadata& inputMetadata, std::optional<ExecutionOptions> const& execution, bool shouldPop)
            -> Expected<int> {
        if (types.empty())
            return 0;

        if (this->types.front().typeInfo != inputMetadata.typeInfo)
            return 0;

        if (this->types.front().category == DataCategory::ExecutionFunctionPointer
            || this->types.front().category == DataCategory::ExecutionStdFunction) {
            assert(!this->tasks.empty());

            bool isOnReadOrExtract = this->tasks.front().executionOptions.category == ExecutionOptions::Category::OnReadOrExtract;
            auto result = 0;
            {
                std::optional<TaskRegistration> registration;
                if (isOnReadOrExtract && this->tasks.front().token) {
                    registration.emplace(this->tasks.front().token);
                }

                if (inputMetadata.category == DataCategory::ExecutionStdFunction)
                    this->tasks.front().function(this->tasks.front(), obj, true);
                else
                    this->tasks.front().function(this->tasks.front(), obj, false);
                result = 1;
            }

            if (shouldPop) {
                this->tasks.pop_front();
                popType();
            }
            return 1;
        }

        if (shouldPop) {
            if (!inputMetadata.deserializePop) {
                return std::unexpected(Error{Error::Code::UnserializableType, "No pop deserialization function provided."});
            }
            inputMetadata.deserializePop(obj, data);
            popType();
        } else {
            if (!inputMetadata.deserialize) {
                return std::unexpected(Error{Error::Code::UnserializableType, "No deserialization function provided."});
            }
            inputMetadata.deserialize(obj, data);
        }
        return 1;
    }

    auto pushType(InputMetadata const& meta) -> void {
        if (!types.empty()) {
            if (types.back().typeInfo == meta.typeInfo)
                types.back().elements++;
            else
                types.emplace_back(meta.typeInfo, 1, meta.category);
        } else {
            types.emplace_back(meta.typeInfo, 1, meta.category);
        }
    }

    auto popType() -> void {
        if (!this->types.empty()) {
            if (--this->types.front().elements == 0) {
                this->types.erase(this->types.begin());
            }
        }
    }
};

} // namespace SP</NodeData.hpp>

<!-- === ./src/pathspace/core/BlockOptions.hpp === -->
<BlockOptions.hpp>
#pragma once

#include <chrono>
#include <optional>

struct BlockOptions {
    enum class Behavior {
        DontWait,
        WaitForExecution,
        WaitForExistence,
        Wait
    };

    Behavior behavior = Behavior::DontWait;
    std::optional<std::chrono::milliseconds> timeout;
};</BlockOptions.hpp>

<!-- === ./src/pathspace/core/InsertReturn.hpp === -->
<InsertReturn.hpp>
#pragma once
#include "Error.hpp"

#include <cstdint>
#include <vector>

namespace SP {

struct InsertReturn {
    uint32_t nbrValuesInserted = 0;
    uint32_t nbrSpacesInserted = 0;
    uint32_t nbrTasksCreated = 0;
    std::vector<Error> errors;
};

} // namespace SP</InsertReturn.hpp>

<!-- === ./src/pathspace/core/ElementType.hpp === -->
<ElementType.hpp>
#pragma once

#include "type/DataCategory.hpp"

#include <stdint.h>
#include <typeinfo>

namespace SP {

struct ElementType {
    std::type_info const* typeInfo = nullptr;
    uint32_t elements = 0;
    DataCategory category = DataCategory::SerializedData;
};

} // namespace SP</ElementType.hpp>

<!-- === ./src/pathspace/core/OutOptions.hpp === -->
<OutOptions.hpp>
#pragma once
#include "BlockOptions.hpp"
#include "ExecutionOptions.hpp"

#include <optional>

namespace SP {

struct OutOptions {
    std::optional<ExecutionOptions> execution;
    std::optional<BlockOptions> block;
    std::optional<int> maxReadsForBlob;
    bool doPop = true;
};

} // namespace SP</OutOptions.hpp>

<!-- === ./src/pathspace/core/Error.hpp === -->
<Error.hpp>
#pragma once
#include <expected>
#include <optional>
#include <string>

namespace SP {

struct Error {
    enum class Code {
        NoSuchPath,
        InvalidPath,
        InvalidPathSubcomponent,
        InvalidType,
        Timeout,
        CapabilityMismatch,
        CapabilityWriteMissing,
        MemoryAllocationFailed,
        MalformedInput,
        UnmatchedQuotes,
        UnknownError,
        SerializationFunctionMissing,
        UnserializableType,
        NoObjectFound,
        PopInRead,
        Shutdown
    };

    Code code;
    std::optional<std::string> message;

    Error(Code c, std::string m) : code(c), message(std::move(m)) {
    }
};

template <typename T>
using Expected = std::expected<T, Error>;

} // namespace SP</Error.hpp>

<!-- === ./src/pathspace/core/TaskToken.hpp === -->
<TaskToken.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "path/ConstructiblePath.hpp"

#include <atomic>
#include <condition_variable>
#include <functional>

namespace SP {

class PathSpace;

class TaskToken {
private:
    std::atomic<bool> valid{true};
    std::mutex mutex;
    std::condition_variable cv;
    std::atomic<size_t> outstandingTasks{0};
    std::atomic<bool> everUsed{false};

public:
    bool isValid() const {
        return valid.load(std::memory_order_seq_cst);
    }

    void invalidate() {
        valid.store(false, std::memory_order_seq_cst);
    }

    void registerTask() {
        everUsed.store(true, std::memory_order_release);
        outstandingTasks.fetch_add(1, std::memory_order_seq_cst);
    }

    void unregisterTask() {
        if (outstandingTasks.fetch_sub(1, std::memory_order_seq_cst) == 1) {
            std::lock_guard<std::mutex> lock(mutex);
            cv.notify_all();
        }
    }

    bool wasEverUsed() const {
        return everUsed.load(std::memory_order_acquire);
    }

    size_t getTaskCount() const {
        return outstandingTasks.load(std::memory_order_seq_cst);
    }

    void waitForTasks() {
        std::unique_lock<std::mutex> lock(mutex);
        cv.wait(lock, [this]() { return outstandingTasks.load(std::memory_order_seq_cst) == 0; });
    }
};

} // namespace SP</TaskToken.hpp>

<!-- === ./src/pathspace/PathSpace.cpp === -->
<PathSpace.cpp>
#include "PathSpace.hpp"
#include "core/BlockOptions.hpp"
#include <future>

namespace SP {

PathSpace::PathSpace(TaskPool* pool) {
    log("PathSpace::PathSpace", "Function Called");
    if (this->pool == nullptr)
        this->pool = &TaskPool::Instance();
};

PathSpace::~PathSpace() {
    log("PathSpace::~PathSpace", "Function Called");
    this->shutdown();
}

auto PathSpace::clear() -> void {
    log("PathSpace::clear", "Function Called");
    this->root.clear();
    this->waitMap.clear();
}

auto PathSpace::shutdown() -> void {
    log("PathSpace::shutdown", "Function Called");
    size_t count = this->taskToken.getTaskCount();
    if (count > 0) {
        log("PathSpace::shutdown Warning: Found " + std::to_string(count) + " uncleaned tasks at shutdown", "Warning");
    }
    if (this->taskToken.wasEverUsed()) {
        this->taskToken.invalidate(); // Prevent new tasks
        this->waitMap.notifyAll();
        this->root.clear();

        // Double check after clear
        count = this->taskToken.getTaskCount();
        if (count > 0) {
            log("PathSpace::shutdown Error: Still have " + std::to_string(count) + " tasks after clear", "Error");
        }

        auto waitResult = std::async(std::launch::async, [this]() {
            auto start = std::chrono::system_clock::now();
            while (true) {
                if (this->taskToken.getTaskCount() == 0) {
                    return true;
                }
                if (std::chrono::system_clock::now() - start > std::chrono::milliseconds(100)) {
                    return false;
                }
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
        });

        if (waitResult.wait_for(std::chrono::milliseconds(100)) == std::future_status::timeout) {
            log("PathSpace::shutdown Warning: Shutdown timed out waiting for tasks", "Warning");
            // Force cleanup
            while (this->taskToken.getTaskCount() > 0) {
                this->taskToken.unregisterTask();
            }
        }
    }
}

auto PathSpace::in(ConstructiblePath& constructedPath, GlobPathStringView const& path, InputData const& data, InOptions const& options)
        -> InsertReturn {
    log("PathSpace::in", "Function Called");
    InsertReturn ret;
    if (!path.isValid()) {
        ret.errors.emplace_back(Error::Code::InvalidPath, std::string("The path was not valid: ").append(path.getPath()));
        return ret;
    }

    this->root.in(constructedPath, path.begin(), path.end(), data, options, ret);

    if (ret.nbrSpacesInserted > 0 || ret.nbrValuesInserted > 0 || ret.nbrTasksCreated) {
        waitMap.notify(path.getPath()); // ToDo:: Fix glob path situation
    }
    return ret;
}

auto PathSpace::out(ConcretePathStringView const& path, InputMetadata const& inputMetadata, OutOptions const& options, void* obj)
        -> Expected<int> {
    log("PathSpace::out", "Function Called");
    return this->root.out(path.begin(), path.end(), inputMetadata, obj, options);
}

} // namespace SP</PathSpace.cpp>

<!-- === ./src/pathspace/taskpool/TaskPool.cpp === -->
<TaskPool.cpp>
#include "TaskPool.hpp"
#include "core/TaskRegistration.hpp"
#include "core/TaskToken.hpp"
#include "utils/TaggedLogger.hpp"

#include <stdexcept>

namespace SP {

TaskPool& TaskPool::Instance() {
    static TaskPool instance;
    return instance;
}

TaskPool::TaskPool(size_t threadCount) : stop(false), availableThreads(0) {
    if (threadCount == 0) {
        threadCount = std::thread::hardware_concurrency();
    }
    for (size_t i = 0; i < threadCount; ++i) {
        workers.emplace_back(&TaskPool::workerFunction, this);
    }
}

TaskPool::~TaskPool() {
    shutdown();
}

auto TaskPool::addTask(Task&& task) -> void {
    std::lock_guard<std::mutex> lock(taskMutex);
    if (task.executionOptions.location == ExecutionOptions::Location::MainThread)
        tasksMainThread.emplace(std::move(task));
    else
        tasks.emplace(std::move(task));
    taskCV.notify_one();
}

void TaskPool::shutdown() {
    {
        std::unique_lock<std::mutex> lock(taskMutex);
        if (stop)
            return; // Prevent multiple shutdowns
        stop = true;
        taskCV.notify_all();
    }

    // Clear remaining tasks
    {
        std::unique_lock<std::mutex> lock(taskMutex);
        while (!tasks.empty())
            tasks.pop();
        while (!tasksMainThread.empty())
            tasksMainThread.pop();
    }

    // Join threads
    for (std::thread& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }
    workers.clear();
}

size_t TaskPool::size() const {
    return workers.size();
}

void TaskPool::workerFunction() {
    while (true) {
        Task task;
        {
            std::unique_lock<std::mutex> lock(taskMutex);
            taskCV.wait(lock, [this]() { return this->stop || !this->tasks.empty(); });

            if (this->stop && this->tasks.empty()) {
                break;
            }

            if (!tasks.empty()) {
                task = std::move(tasks.front());
                tasks.pop();
            } else {
                continue;
            }
        }

        {
            std::unique_lock<std::mutex> counterLock(availableThreadsMutex);
            availableThreads++;
        }

        if (task.function) {
            try {
                if (!task.token || !task.token->isValid()) {
                    continue;
                }
                TaskRegistration registration(task.token);
                task.function(task, nullptr, false);
            } catch (const std::exception& e) {
                log("Task execution failed: " + std::string(e.what()), "ERROR");
            } catch (...) {
                log("Task execution failed with unknown error", "ERROR");
            }
        }

        {
            std::unique_lock<std::mutex> counterLock(availableThreadsMutex);
            availableThreads--;
        }
    }
}

} // namespace SP</TaskPool.cpp>

<!-- === ./src/pathspace/taskpool/TaskPool.hpp === -->
<TaskPool.hpp>
#pragma once
#include "Task.hpp"

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <optional>
#include <queue>
#include <thread>
#include <vector>

namespace SP {

struct PathSpace;

class TaskPool {
public:
    TaskPool(size_t threadCount = 0);
    ~TaskPool();

    static TaskPool& Instance();

    TaskPool(TaskPool const&) = delete;
    auto operator=(TaskPool const&) -> TaskPool& = delete;

    auto addTask(Task&& task) -> void;

    auto shutdown() -> void;
    auto size() const -> size_t;

private:
    auto workerFunction() -> void;

    std::vector<std::thread> workers;
    std::queue<Task> tasks;
    std::queue<Task> tasksMainThread;
    std::mutex taskMutex, availableThreadsMutex;
    std::condition_variable taskCV;
    std::atomic<bool> stop;
    std::atomic<size_t> availableThreads;
};

} // namespace SP</TaskPool.hpp>

<!-- === ./src/pathspace/taskpool/Task.cpp === -->
<Task.cpp>
#include "taskpool/Task.hpp"

namespace SP {} // namespace SP</Task.cpp>

<!-- === ./src/pathspace/taskpool/Task.hpp === -->
<Task.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "path/ConstructiblePath.hpp"

#include <cassert>
#include <functional>

namespace SP {
struct PathSpace;
struct TaskToken;

struct Task {
    PathSpace* space = nullptr;                  // Returned values from the execution will be inserted here
    TaskToken* token = nullptr;                  // Token for validation
    ConstructiblePath pathToInsertReturnValueTo; // On this path, the return value will be inserted.
    ExecutionOptions executionOptions;

    std::function<void(Task const& task, void* obj, bool isOut)> function;
};

} // namespace SP</Task.hpp>

<!-- === ./src/pathspace/PathSpaceLeaf.cpp === -->
<PathSpaceLeaf.cpp>
#include "PathSpaceLeaf.hpp"
#include "core/BlockOptions.hpp"
#include "core/Error.hpp"
#include "core/InOptions.hpp"
#include "core/InsertReturn.hpp"
#include "core/OutOptions.hpp"
#include "path/ConstructiblePath.hpp"
#include "pathspace/type/InputData.hpp"
#include "type/InputData.hpp"

namespace SP {

auto PathSpaceLeaf::clear() -> void {
    this->nodeDataMap.clear();
}

/*
    ############# In #############
*/

auto PathSpaceLeaf::in(ConstructiblePath& path,
                       GlobPathIteratorStringView const& iter,
                       GlobPathIteratorStringView const& end,
                       InputData const& inputData,
                       InOptions const& options,
                       InsertReturn& ret) -> void {
    std::next(iter) == end ? inFinalComponent(path, *iter, inputData, options, ret)
                           : inIntermediateComponent(path, iter, end, *iter, inputData, options, ret);
}

auto PathSpaceLeaf::inFinalComponent(ConstructiblePath& path,
                                     GlobName const& pathComponent,
                                     InputData const& inputData,
                                     InOptions const& options,
                                     InsertReturn& ret) -> void {
    path.append(pathComponent.getName());

    if (pathComponent.isGlob()) {
        // Create a vector to store the keys that match before modification. ToDo: Memory allocation
        std::vector<ConcreteNameString> matchingKeys;

        // First pass: Collect all matching keys without holding write locks
        nodeDataMap.for_each([&](auto& item) {
            const auto& key = item.first;
            if (std::get<0>(pathComponent.match(key))) {
                matchingKeys.push_back(key);
            }
        });

        // Second pass: Modify matching nodes with proper locking
        for (const auto& key : matchingKeys) {
            nodeDataMap.modify_if(key, [&](auto& nodePair) {
                if (auto* nodeData = std::get_if<NodeData>(&nodePair.second)) {
                    if (auto error = nodeData->serialize(inputData, options, ret); error.has_value()) {
                        ret.errors.emplace_back(error.value());
                    }
                    ret.nbrValuesInserted++;
                    return true; // Indicate that modification occurred
                }
                return false; // No modification if it's not a NodeData
            });
        }
    } else {
        nodeDataMap.try_emplace_l(
                pathComponent.getName(),
                [&](auto& value) {
                    if (auto* nodeData = std::get_if<NodeData>(&value.second)) {
                        if (auto error = nodeData->serialize(inputData, options, ret); error.has_value()) {
                            ret.errors.emplace_back(error.value());
                        }
                    }
                },
                NodeData{inputData, options, ret});
        ret.nbrValuesInserted++;
    }
}

auto PathSpaceLeaf::inIntermediateComponent(ConstructiblePath& path,
                                            GlobPathIteratorStringView const& iter,
                                            GlobPathIteratorStringView const& end,
                                            GlobName const& pathComponent,
                                            InputData const& inputData,
                                            InOptions const& options,
                                            InsertReturn& ret) -> void {
    path.append(pathComponent.getName());
    auto nextIter = std::next(iter);

    if (pathComponent.isGlob()) {
        nodeDataMap.for_each([&](const auto& item) {
            const auto& key = item.first;
            if (std::get<0>(pathComponent.match(key))) {
                if (const auto* leaf = std::get_if<std::unique_ptr<PathSpaceLeaf>>(&item.second)) {
                    (*leaf)->in(path, nextIter, end, inputData, options, ret);
                }
            }
        });
    } else {
        auto [it, inserted] = nodeDataMap.try_emplace(pathComponent.getName(), std::make_unique<PathSpaceLeaf>());
        if (auto* leaf = std::get_if<std::unique_ptr<PathSpaceLeaf>>(&it->second)) {
            (*leaf)->in(path, nextIter, end, inputData, options, ret);
        }
    }
}

/*
    ############# Out #############
*/

auto PathSpaceLeaf::out(ConcretePathIteratorStringView const& iter,
                        ConcretePathIteratorStringView const& end,
                        InputMetadata const& inputMetadata,
                        void* obj,
                        OutOptions const& options) -> Expected<int> {
    auto const nextIter = std::next(iter);
    auto const pathComponent = *iter;
    return nextIter == end ? outDataName(pathComponent, nextIter, end, inputMetadata, obj, options)
                           : outConcretePathComponent(nextIter, end, pathComponent, inputMetadata, obj, options);
}

auto PathSpaceLeaf::outDataName(ConcreteNameStringView const& concreteName,
                                ConcretePathIteratorStringView const& nextIter,
                                ConcretePathIteratorStringView const& end,
                                InputMetadata const& inputMetadata,
                                void* obj,
                                OutOptions const& options) -> Expected<int> {
    Expected<int> result = std::unexpected(Error{Error::Code::NoSuchPath, "Path not found"});

    nodeDataMap.modify_if(concreteName.getName(), [&](auto& nodePair) {
        if (auto* nodeData = std::get_if<NodeData>(&nodePair.second)) {
            if (options.doPop) {
                result = nodeData->deserializePop(obj, inputMetadata);
            } else {
                result = nodeData->deserialize(obj, inputMetadata, options.execution);
            }
            return options.doPop; // Only modify (remove) if it's a pop operation
        }
        return false;
    });

    return result;
}

auto PathSpaceLeaf::outConcretePathComponent(ConcretePathIteratorStringView const& nextIter,
                                             ConcretePathIteratorStringView const& end,
                                             ConcreteNameStringView const& concreteName,
                                             InputMetadata const& inputMetadata,
                                             void* obj,
                                             OutOptions const& options) -> Expected<int> {
    Expected<int> expected = std::unexpected(Error{Error::Code::NoSuchPath, "Path not found"});
    this->nodeDataMap.if_contains(concreteName.getName(), [&](auto const& nodePair) {
        expected = std::holds_alternative<std::unique_ptr<PathSpaceLeaf>>(nodePair.second)
                           ? std::get<std::unique_ptr<PathSpaceLeaf>>(nodePair.second)->out(nextIter, end, inputMetadata, obj, options)
                           : std::unexpected(Error{Error::Code::InvalidPathSubcomponent, "Sub-component name is data"});
    });
    return expected;
}

} // namespace SP</PathSpaceLeaf.cpp>

<!-- === ./src/pathspace/utils/TaggedLogger.hpp === -->
<TaggedLogger.hpp>
#pragma once

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

namespace SP {

class TaggedLogger {
public:
    struct LogMessage {
        std::chrono::system_clock::time_point timestamp;
        std::vector<std::string> tags;
        std::string message;
        std::string threadName;
    };

    TaggedLogger();
    ~TaggedLogger();

    TaggedLogger(const TaggedLogger&) = delete;
    TaggedLogger& operator=(const TaggedLogger&) = delete;
    TaggedLogger(TaggedLogger&&) = delete;
    TaggedLogger& operator=(TaggedLogger&&) = delete;

    template <typename... Tags>
    auto log(const std::string& message, Tags&&... tags) -> void;

    auto setThreadName(const std::string& name) -> void;
    auto setLoggingEnabled(bool enabled) -> void;

    static std::mutex coutMutex;

private:
    std::queue<LogMessage> messageQueue;
    mutable std::mutex queueMutex;
    std::condition_variable cv;
    std::thread workerThread;
    std::atomic<bool> running;
    std::atomic<bool> loggingEnabled;

    std::unordered_map<std::thread::id, std::string> threadNames;
    mutable std::mutex threadNamesMutex;
    std::atomic<int> nextThreadNumber;

    auto processQueue() -> void;
    auto writeToStderr(const LogMessage& msg) const -> void;
    auto getThreadName(const std::thread::id& id) -> std::string;
};

// Inline function definitions

inline TaggedLogger& logger() {
    static TaggedLogger instance;
    return instance;
}

template <typename... Tags>
auto TaggedLogger::log(const std::string& message, Tags&&... tags) -> void {
    if (!loggingEnabled)
        return;

    const auto logMessage = LogMessage{.timestamp = std::chrono::system_clock::now(),
                                       .tags = {std::forward<Tags>(tags)...},
                                       .message = message,
                                       .threadName = getThreadName(std::this_thread::get_id())};

    {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->messageQueue.push(std::move(logMessage));
        this->cv.notify_one();
    }
}

template <typename... Args>
inline void log(Args&&... args) {
    // logger().log(std::forward<Args>(args)...);
}

inline void set_thread_name(const std::string& name) {
    logger().setThreadName(name);
}

inline void set_logging_enabled(bool enabled) {
    logger().setLoggingEnabled(enabled);
}

} // namespace SP</TaggedLogger.hpp>

<!-- === ./src/pathspace/utils/TaggedLogger.cpp === -->
<TaggedLogger.cpp>
#include "TaggedLogger.hpp"

namespace SP {

std::mutex TaggedLogger::coutMutex;

TaggedLogger::TaggedLogger() : running(true), nextThreadNumber(0), loggingEnabled(true) {
    this->workerThread = std::thread(&TaggedLogger::processQueue, this);
}

TaggedLogger::~TaggedLogger() {
    {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->running = false;
        this->cv.notify_one();
    }
    if (this->workerThread.joinable()) {
        this->workerThread.join();
    }
}

auto TaggedLogger::setThreadName(const std::string& name) -> void {
    const auto threadId = std::this_thread::get_id();
    std::lock_guard<std::mutex> lock(threadNamesMutex);
    threadNames[threadId] = name;
}

auto TaggedLogger::setLoggingEnabled(bool enabled) -> void {
    loggingEnabled.store(enabled, std::memory_order_relaxed);
}

auto TaggedLogger::processQueue() -> void {
    while (true) {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->cv.wait(lock, [this] { return !this->messageQueue.empty() || !this->running; });

        if (!this->running && this->messageQueue.empty()) {
            return;
        }

        while (!this->messageQueue.empty()) {
            const auto msg = std::move(this->messageQueue.front());
            this->messageQueue.pop();
            lock.unlock();
            this->writeToStderr(msg);
            lock.lock();
        }
    }
}

auto TaggedLogger::writeToStderr(const LogMessage& msg) const -> void {
    const auto now = msg.timestamp;
    const auto nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
    const auto nowTimeT = std::chrono::system_clock::to_time_t(now);
    const auto* nowTm = std::localtime(&nowTimeT);

    std::ostringstream oss;
    oss << std::put_time(nowTm, "%Y-%m-%d %H:%M:%S") << '.' << std::setfill('0') << std::setw(3) << nowMs.count() << ' ';

    oss << '[';
    for (size_t i = 0; i < msg.tags.size(); ++i) {
        if (i > 0)
            oss << "][";
        oss << msg.tags[i];
    }
    oss << "] ";

    oss << "[" << msg.threadName << "] ";
    oss << msg.message << '\n';

    std::lock_guard<std::mutex> lock(coutMutex);
    std::cerr << oss.str() << std::flush;
}

auto TaggedLogger::getThreadName(const std::thread::id& id) -> std::string {
    std::lock_guard<std::mutex> lock(threadNamesMutex);
    auto it = threadNames.find(id);
    if (it != threadNames.end()) {
        return it->second;
    } else {
        std::string name = "Thread " + std::to_string(nextThreadNumber++);
        threadNames[id] = name;
        return name;
    }
}

} // namespace SP</TaggedLogger.cpp>

