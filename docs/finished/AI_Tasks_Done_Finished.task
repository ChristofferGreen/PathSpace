// Completed PathSpace tasks archive (updated October 20, 2025).

task {
  name: "Metal Renderer Material Bindings [BLOCKER]"
  description: "Finish GPU parity by wiring PathRenderer2DMetal into the shared material/shader descriptor cache so Metal draws stay feature-complete with the software pipeline."
  status: completed
  priority: P0

  acceptance_criteria: [
    "PathRenderer2DMetal uses shared material/shader keys so GPU frames mirror software material telemetry (including glyph batches and textured pipelines).",
    "Metal path covers glyph batches and material-driven pipelines without falling back to the CPU, barring explicitly unsupported commands.",
    "UITests assert GPU material telemetry (descriptor count, shader keys, residency) and capture GPU error handling."
  ]

  steps: [
    "Plumbed Builders::MaterialDescriptor/MaterialShaderKey through the Metal encoder and bound textures/shaders per drawable batch.",
    "Maintained GPU command coverage for glyph/textured pipelines while documenting any remaining fallbacks.",
    "Augmented PathSpaceUITests with GPU material telemetry assertions, including a blending parity check for material-driven pipelines."
  ]
}

task {
  name: "UndoableSpace Wrapper Skeleton [CORE]"
  description: "Land the in-memory undo/redo wrapper (`history::UndoableSpace`) with copy-on-write snapshots, history controls, and RAII batching so plan phase 2 is unblocked."
  status: completed
  priority: P0

  acceptance_criteria: [
    "`history::UndoableSpace` decorates a backing PathSpace and exposes `enableHistory`, `undo`, `redo`, and `_history/*` control paths.",
    "Undo/redo replay copy-on-write snapshots for value nodes; nested transactions coalesce into a single history entry.",
    "PathSpaceTests cover undo/redo flows and transaction batching in the mandated 15× loop; docs capture current limitations (no tasks/nested spaces yet)."
  ]

  steps: [
    "Implemented SlidingBuffer/NodeData history serialization helpers and the UndoableSpace wrapper with per-root stacks and RAII transactions.",
    "Added history tests (tests/unit/history/test_UndoableSpace.cpp) plus plan/doc updates outlining remaining persistence/telemetry work.",
    "Executed the release build + 15× ctest loop via `ctest --test-dir build --output-on-failure -j 8 --repeat-until-fail 15 --timeout 20`."
  ]
}

task {
  name: "HTML Asset Hydration Bug [BLOCKER]"
  description: "Resolved October 20, 2025 by introducing a dedicated Html::Asset codec (include/pathspace/ui/HtmlSerialization.hpp) so PathSpace round-trips asset vectors without loss."
  status: completed
  priority: P0

  acceptance_criteria: [
    "PathSpace core fix lands so `PathSpace::read<std::vector<Html::Asset>>` returns the same data that was inserted.",
    "`Renderer::RenderHtml hydrates image assets into output` passes without UI-side workarounds; asset bytes persist under `output/v1/html/assets`.",
    "Docs (AI_Debugging_Playbook, AI_Onboarding_Next) updated to reflect the resolution and any new knobs/tests."
  ]

  steps: [
    "Verified with PathSpaceUITests (loop=15) and the new Html::Asset regression on October 20, 2025.",
    "Legacy Alpaca fallback remains for backwards compatibility; schedule removal once historical data migrates."
  ]
}

task {
  name: "Software Presenter Zero-Copy Buffer [PERF]"
  description: "Eliminate framebuffer memcpy by backing PathSurfaceSoftware with an IOSurface shared directly with CAMetalLayer."
  status: completed
  priority: P1

  acceptance_criteria: [
    "PathSurfaceSoftware allocates/owns an IOSurface that the renderer writes into directly; no std::vector memcpy in copy_buffered_frame.",
    "Presenter binds the IOSurface (or texture alias) without copying, and the paint_example runs fullscreen without regressions.",
    "Docs updated (Plan_SceneGraph_Renderer_Finished.md, AI_Architecture.md) to reflect the zero-copy pipeline; tests cover the new path."
  ]

  steps: [
    "Refactor PathSurfaceSoftware to allocate IOSurface-backed memory and expose the relevant descriptors.",
    "Update presenter/Builders to consume the shared resource, removing the fallback memcpy code path.",
    "Add regression tests/benchmarks exercising fullscreen presents to verify zero-copy performance."
  ]
}

task {
  name: "CAMetalLayer Range Group Reuse [PERF]"
  description: "Reuse IOSurface instances during CAMetalLayer presents so extended UI sessions do not exhaust range groups."
  status: completed
  priority: P1

  acceptance_criteria: [
    "Presenter reuses a bounded IOSurface pool; no per-frame allocations during steady-state painting.",
    "Long-duration paint_example runs show no 'Failed to allocate segment' errors.",
    "Instrumentation gated behind PATHSPACE_DEBUG_IOSURFACE=1 captures resize/allocation events."
  ]

  steps: [
    "Introduce a small IOSurface reuse pool in WindowEventPump, rotating through surfaces matching the current drawable size.",
    "Ensure PathSurfaceSoftware only reallocates IOSurfaces when the size changes.",
    "Add optional logging to confirm allocation behaviour during debugging runs."
  ]
}

task {
  name: "Renderer Benchmarking [PERF]"
  description: "Instrument PathRenderer2D phases (damage diff, encode, progressive copy, IOSurface publish, presenter blit) and capture 4K vs small-surface timings; reuse the new benchmark harness for automation."
  status: completed
  priority: P1

  acceptance_criteria: [
    "Benchmark harness reports per-phase timings for 4K_full, 4K_incremental, and sub-2K cases.",
    "Results summarized in docs/Plan_SceneGraph.md with bottleneck callouts."
  ]

  steps: [
    "Instrument damage diff and encode loops with timers in benchmark build.",
    "Capture IOSurface allocation/publish metrics under repeated full-surface runs.",
    "Document findings and update paint_example plan."
  ]
}

task {
  name: "WindowEventPump UI Migration [UI]"
  description: "Fold the macOS WindowEventPump presenter/event bridge into the PathSpace UI library so examples stay platform-neutral."
  status: completed
  priority: P1

  acceptance_criteria: [
    "PathWindowView (and supporting UI library code) owns the CAMetalLayer drawable acquisition, Metal/IOSurface present path, and event-loop integration currently implemented in examples/macos/WindowEventPump.mm.",
    "examples/macos/* no longer compile any platform-specific presenter code; they reuse the shared UI bridge.",
    "Docs updated (Plan_SceneGraph.md, AI_Architecture.md) to reference the shared presenter instead of the example harness."
  ]

  steps: [
    "Refactor WindowEventPump.mm logic into PathSpace UI components (ObjC++ shim + C++ presenters) while preserving current Metal gating.",
    "Provide a thin example harness that only wires app-specific input/scene setup.",
    "Update examples and tests to consume the shared bridge; remove redundant platform code."
  ]
}

task {
  name: "Metal Presenter UITest [TESTS]"
  description: "Add a PATHSPACE_ENABLE_METAL_UPLOADS-gated UITest that exercises the CAMetalLayer presenter path."
  status: completed
  priority: P1

  acceptance_criteria: [
    "PathSpaceUITests builds an ObjC++ test that configures PathWindowView with a CAMetalLayer and records Metal present stats when PATHSPACE_ENABLE_METAL_UPLOADS=1.",
    "The test skips gracefully when Metal uploads remain disabled (default CI/headless runs).",
    "Docs reference the new UITest and its gating so contributors know how to enable it locally."
  ]

  steps: [
    "Create ui/test_PathWindowView_Metal.mm under PathSpaceUITests to configure a CAMetalLayer and invoke the presenter.",
    "Guard the test behind PATHSPACE_UI_METAL, APPLE, and PATHSPACE_ENABLE_METAL_UPLOADS so CI remains stable.",
    "Update planning/docs to track the new coverage and remaining CI toggle work."
  ]
}

task {
  name: "Metal Renderer Material Bindings [BLOCKER]"
  description: "Finish GPU parity by wiring PathRenderer2DMetal into the shared material/shader descriptor cache so Metal draws stay feature-complete with the software pipeline."
  status: completed
  priority: P0

  acceptance_criteria: [
    "PathRenderer2DMetal uses shared material/shader keys so GPU frames mirror software material telemetry (including glyph batches and textured pipelines).",
    "Metal path covers glyph batches and material-driven pipelines without falling back to the CPU, barring explicitly unsupported commands.",
    "UITests assert GPU material telemetry (descriptor count, shader keys, residency) and capture GPU error handling."
  ]

  steps: [
    "Plumb Builders::MaterialDescriptor/MaterialShaderKey through the Metal encoder and bind textures/shaders per drawable batch.",
    "Extend GPU command coverage to glyph batches and material-driven pipelines; document any remaining fallbacks.",
    "Augment PathSpaceUITests with GPU material telemetry assertions once bindings land.",
    "Added `PathRenderer2DMetal::bind_material`, per-draw pipeline selection, and a Metal UITest that verifies blending vs opaque material pipelines."
  ]
}

task {
  name: "Widget Interaction Bindings [FEATURE]"
  description: "Bind widget interactions to dirty-hint and ops queues so UI updates avoid full scene republishes."
  status: completed
  priority: P1

  acceptance_criteria: [
    "Binding helper API diffed widget state (button/toggle/slider) and submitted dirty rect hints instead of full-scene republishes.",
    "Ops inbox schema documented; reducers have a stable `WidgetOp` payload (kind, pointer metadata, value, timestamp).",
    "Tests exercised hover/press/release and slider flows, confirming auto-render scheduling stays stable under the 15× loop harness."
  ]

  steps: [
    "Added `Widgets::Bindings::Dispatch{Button,Toggle,Slider}` helpers that coalesce state changes, submit dirty rect hints, and enqueue ops under `widgets/<id>/ops/inbox/queue`.",
    "Documented the `WidgetOp` schema/path layout (Plan_SceneGraph.md, AI_Paths.md) for reducers and tooling.",
    "Extended doctests to cover button/toggle/slider interaction flows and verified auto-render queues remain stable in the 15× loop harness."
  ]
}

task {
  name: "Paint Example Palette Controls [FEATURE]"
  description: "Expose live color + brush sizing controls in paint_example via widget bindings so demos no longer require code edits for palette tweaks."
  status: completed
  priority: P1

  acceptance_criteria: [
    "Palette buttons (red/green/blue/yellow/purple/orange) route through Widgets::Bindings so color swaps emit dirty hints instead of full-scene republishes.",
    "Brush size slider persists to /config/brushSizePx and updates the demo immediately, matching UITest loop expectations.",
    "paint_example publishes an overlay bucket for the control stack and guards pointer events so painting ignores UI footprint."
  ]

  steps: [
    "Added PaintControls helper that creates palette buttons + slider bindings, registers action callbacks, and merges the control bucket into the scene snapshot.",
    "Persisted brush color/size under /config paths and guarded paint input so UI interactions do not start strokes.",
    "Documented completion in Plan_SceneGraph.md and refreshed backlog focus for upcoming slider → listbox coverage work."
  ]
}
