# Plan — Typed Distributed Payloads

> **Drafted:** December 6, 2025  
> **Owner:** PathSpace distributed/runtime pairing  
> **Status:** Completed — typed/slidingbuffer payloads enforced everywhere, PATHSPACE_REMOTE_TYPED_PAYLOADS gate shipped, and legacy encodings disabled by default

## Problem Statement

Remote mounts historically shipped opaque `NodeData` snapshots across the wire (`nodedata/base64` payloads). That leaked an internal storage format outside `PathSpaceBase`, forced transports to understand `NodeData`, and blocked the goal of “no `NodeData` access outside PathSpace itself.” We need a protocol and runtime design that keeps the distributed stack entirely on the public typed API (`insert/read/take`) while still supporting arbitrary user-defined types.

## Goals

1. **Encapsulation:** Eliminate `PathSpace::insertSerializedNodeData` / `takeSerializedNodeData` and remove every external use of `NodeData` (RemoteMountServer, RemoteMountManager, protocol tests, docs).
2. **Typed parity:** Distributed insert/read/take must continue to handle arbitrary user types—as long as those types are registered through the existing `InputMetadata` machinery—without copying or deserializing twice.
3. **Graceful unknown handling:** When a mount encounters a type it cannot decode, it should log/metric and gracefully ignore the value while keeping wait/read semantics responsive.
4. **Minimal behavioral change:** ServeHtml, inspector, and existing remote clients should continue to function once they rebuild with the new protocol contract.

## Non-goals

- Replacing `NodeData` as the internal storage primitive. We only want to stop exposing it externally.
- Introducing new serialization libraries. We rely on the current `InputMetadata` (`serialize`/`deserialize` callbacks) generated by `InputMetadataT<T>`.
- Solving executor offloading; execution forwarding keeps its current behavior.

## Architecture Overview

### Typed Codec Source of Truth

Every `insert<T>` already supplies an `InputMetadata` describing:
- `typeInfo` — canonical RTTI identity.
- `serialize` — function pointer to encode `T` into a `SlidingBuffer`.
- `deserialize` / `deserializePop` — functions to reconstruct `T` from bytes.

We leverage those callbacks everywhere remote payloads are encoded or decoded. No extra registry is required—applications simply ensure the receiving binary was built with the same type definitions so `InputMetadataT<T>` exists on both ends.

### Typed Payload Bridge + Registry

`distributed/TypedPayloadBridge` centralizes every conversion between transport bytes and the in-process typed API. `insertTypedPayloadFromBytes` resolves the `InputMetadata` through `TypeMetadataRegistry`, uses the per-type construct/destroy callbacks to materialize the destination value, and reinserts it through `PathSpace::insert` without exposing `NodeData`. `takeTypedPayloadToBytes` performs the inverse: it validates any caller-supplied type hints, invokes `PathSpace::take`/`read`, serializes via the registered `InputMetadata::serialize`, and packages the bytes alongside the canonical `type_name`. `TypeMetadataRegistry` is hydrated automatically by `InputData`/`RemoteMountManager`, so distributed code never touches `PathSpace` internals or bespoke helpers.

### Protocol Changes

1. **`ValuePayload`:** add `type_name` (required) plus an optional `schema_hint` field so future non-RTTI identifiers can be supported. `encoding` now defaults to `typed/slidingbuffer`.
2. **`ReadRequest` / `TakeRequest`:** include a `type_name` hint for the payload the caller expects. Reads fall back to the runtime type when the hint is omitted; takes still enforce a type name so the server never pops values blindly.
3. **`Notification`:** mirror the runtime `type_name` so subscribers (and mirrors) know which `InputMetadata` to use when decoding the payload, even when they did not request the value body.
4. **Encoding:** `encoding == typed/slidingbuffer` is now the default. The data blob is exactly what `InputMetadata::serialize` produces. Legacy `string/base64`, `nodedata/base64`, and `void/sentinel` frames remain accepted for one release to ease upgrades.

### Server Flow

**Insert:**
1. Validate `request.type_name` (reject with `InvalidType` when it is missing).
2. Call `TypedPayloadBridge::insertTypedPayloadFromBytes`, which asks `TypeMetadataRegistry` for the metadata, allocates storage via the registered construct/destroy callbacks, deserializes the payload, and immediately invokes `space.insert(path, value)` through the public typed API.
3. When metadata is absent or decoding fails, return `InvalidType` (retryable=false) and log so operators can register the type before replaying the request.

**Take/Read/Notify:**
1. Materialize the value via `TypedPayloadBridge::takeTypedPayloadToBytes`. The bridge validates the runtime type against any caller-provided hint and falls back to the discovered type when reads omit the hint.
2. The bridge serializes the result with the registered `InputMetadata`, populates `ValuePayload.bytes` with the encoded buffer, and sets `ValuePayload.type_name` to the canonical runtime type.
3. If the metadata is missing or serialization fails, respond with `unsupported_type` while still emitting `deleted=true` notifications so wait queues remain responsive.

### Client Flow

**Insert:** reuse the existing `InputData` — call the metadata’s `serialize`, ship the bytes with `type_name = metadata.typeInfo->name()`, and rely on RemoteMountManager’s auto-registration to keep `TypeMetadataRegistry` populated on both sides.

**Take/Read:** the caller already invoked `take<T>` or `read<T>`, so the manager knows the `InputMetadata`. Send `type_name` in the request when it is known (reads omit it for mirror/snapshot crawls), receive a serialized buffer, and call `metadata.deserialize` into the caller’s storage. When hydrating local mirrors, RemoteMountManager hands the decoded value to `TypedPayloadBridge` so the local `PathSpace` mutations also flow through `insert`/`take`.

**Unknown type handling:** If a `Notification` or `TakeResponse` arrives with an unrecognized `type_name`, log, increment `/inspector/metrics/remotes/<alias>/client/unsupported_types`, skip the payload, and keep the queue moving.

## Migration Plan

1. **Audit references:***
   - `PathSpace` serialized helpers.
   - `RemoteMountServer` (`NodeData` encode/deserialize).
   - `RemoteMountManager` inserts/takes/mirror code.
   - Docs/tests referencing `nodedata/base64`.

2. **Introduce `TypeMetadataRegistry` (optional helper):**
   - Maintains a hash map from `std::string type_name` to lightweight structs containing the same callbacks as `InputMetadata`.
   - Populated automatically via a macro or explicit registration in modules that define distributed types.
   - Falls back to RTTI lookups for core STL/primitive types to minimize churn.
   > **Update (December 6, 2025):** `TypeMetadataRegistry` now lives in `src/pathspace/type/TypeMetadataRegistry.{hpp,cpp}` with doctest coverage and RemoteMountManager auto-registration for every insert/read/take/wait metadata. The registry keeps canonical `type_info::name()` strings cached for upcoming protocol work and exposes a macro for early opt-ins.

3. **Protocol update:**
   - Modify `distributed/RemoteMountProtocol.{hpp,cpp}` and related tests to represent the new fields and encodings.
   - Bump protocol minor version to signal the change.
   > **Update (December 6, 2025):** Landed in this revision. `ValuePayload` now carries `type_name`, `ReadRequest`/`TakeRequest` ship optional type hints, notifications mirror runtime types, and protocol v1.1 clients/servers default to `typed/slidingbuffer`.

4. **Server refactor:**
   - Delete `PathSpace::insertSerializedNodeData` / `takeSerializedNodeData`.
   - Update `RemoteMountServer` to decode/encode via registered type metadata.
   - Update notification streaming to populate `type_name`.
   > **Update (December 6, 2025):** RemoteMountServer now consumes `typed/slidingbuffer` frames, validates hints when provided, mirrors type names on every notification, and funnels every payload through `TypedPayloadBridge`. No `NodeData` helpers or `PathSpace::insertTypedPayload` / `takeTypedPayload` shims remain, and `nodedata/base64` frames are rejected outright while legacy `string/base64` decoding is only available when `PATHSPACE_REMOTE_TYPED_PAYLOADS=0`.

5. **Client refactor:**
   - Rework `RemoteMountManager::performInsert/read/take/mirror` to use typed serialization and handle “unsupported type” responses.
   - Mirror assignments should skip nodes whose types are unknown locally.
   > **Update (December 6, 2025):** RemoteMountManager now emits typed payloads (`typed/slidingbuffer`), requests type hints for reads/takes when possible, reinserts mirrored values through `TypedPayloadBridge`, and reports unsupported types via metrics/logs. Legacy `string/base64` handling only exists behind `PATHSPACE_REMOTE_TYPED_PAYLOADS=0`, and the manager no longer rebuilds `NodeData` outside PathSpace internals.

6. **Docs/tests:**
   - Update `docs/finished/Plan_Distributed_PathSpace_Finished.md`, `docs/Memory.md`, debugging guides, and unit tests (`tests/unit/distributed/*`) to describe and exercise the typed flow.
   > **Update (December 6, 2025):** `tests/unit/distributed/test_RemoteMountProtocol.cpp`, `test_RemoteMountServer.cpp`, and `test_RemoteMountManager.cpp` now assert the `type_name` metadata across reads/takes/notifications, while `docs/finished/Plan_Distributed_PathSpace_Finished.md` + `docs/Memory.md` describe the `typed/slidingbuffer` default and the temporary legacy compatibility window. Compatibility is now enforced by Step 7’s gate, so this item is fully closed.

7. **Compatibility strategy:**
   - Provide a feature flag (e.g., `PATHSPACE_REMOTE_TYPED_PAYLOADS=1`) during the rollout so clients/servers can be updated in lockstep.
   - Once both ends support the new protocol, remove the flag entirely; `nodedata/base64` is already rejected and only the legacy `string/base64` decoder remains behind the flag during the final compatibility window.
> **Update (December 6, 2025):** `PATHSPACE_REMOTE_TYPED_PAYLOADS` now defaults to typed-only mode. Setting the variable to `0`/`false` temporarily re-enables only the legacy `string/base64` decoder for straggler deployments; `nodedata/base64` frames are rejected regardless of the flag. The default path rejects legacy payloads at both the server (`RemoteMountServer`) and client (`RemoteMountManager`). Tests assert that typed-only mode fails fast, and docs now direct operators to flip the flag only during the final compatibility window. With this gate landed, the plan is finished and archived under `docs/finished/Plan_DistributedTypedPayloads_Finished.md`.

> **Update (December 6, 2025 — helper cleanup):** `RemoteMountServer` / `RemoteMountManager` now deserialize typed payloads through the shared `TypedPayloadBridge` (which resolves `TypeMetadataRegistry` entries, instantiates the concrete value, and reserializes via the standard API), so the interim `PathSpace::insertTypedPayload` / `takeTypedPayload` helpers have been deleted. `nodedata/base64` frames remain rejected and the compatibility flag only gates the legacy `string/base64` decoder.

## Open Questions

1. **Type identity canonicalization:** Is `type_info::name()` stable enough across compilers/optimization levels? If not, we may need a user-provided string ID per type.
2. **Registration UX:** Do we expect applications to explicitly register every distributed type, or can we auto-register via templates when `take<T>`/`insert<T>` is instantiated in remote contexts?
3. **Backwards compatibility:** Resolved — typed payloads are enforced by default, and operators can temporarily re-enable the legacy `string/base64` + `nodedata/base64` decoders by setting `PATHSPACE_REMOTE_TYPED_PAYLOADS=0` during the final compatibility window.
4. **Diagnostics:** What additional metrics/logging do we want when unsupported types are encountered repeatedly?

## Next Steps

1. Get buy-in from the PathSpace maintainer on the plan (especially type identity approach).
2. File implementation tasks for server, client, protocol, and documentation updates.
3. Add regression tests covering:
   - Successful typed insert/take for primitives and user structs.
   - Unknown type handling (server rejects insert, client skips takes/reads).
   - Mixed-version behavior when the feature flag is disabled/enabled.
