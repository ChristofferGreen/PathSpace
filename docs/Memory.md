## Repository Memory
This file is for remembering architecture details about the PathSPace project so it becomes easier to get up to speed about details later.
No need to store details about a worklog of dates when things where added.

- 2025-11-26: `PumpWindowWidgetsOnce` exposes a synchronous input-task escape hatch plus `/system/widgets/runtime/input/{windows,apps}/.../metrics/*` so UITests can drain their window on demand and assert progress even when `PATHSPACE_TEST_TIMEOUT=1`. `PathSpaceExamples::ensure_declarative_scene_ready` picked up `scene_window_component_override`, `scene_view_override`, and `ensure_scene_window_mirror`, `force_window_software_renderer` keeps declarative paint UITests on the CPU path when Metal uploads are forced, and the longest UITests now scale waits/iterations unless `PATHSPACE_FULL_FUZZ=1`.
- 2025-11-26: Added the loop-stability CI workflow (`loop-stability` job) that runs `./scripts/compile.sh --clean --test --loop=5 --release --per-test-timeout 20` with `PATHSPACE_TEST_TIMEOUT=1`, writes `loop_baseline.json` via `PATHSPACE_LOOP_BASELINE_OUT`, and uploads `build/test-logs/` so dashboards always get a fresh baseline before declarative changes land. `PathSpaceExamples::ensure_declarative_scene_ready` now records the per-window/app manual pump metrics (under `/system/widgets/runtime/input/{windows,apps}/.../metrics/*`) into each test’s artifact directory whenever `PATHSPACE_RECORD_MANUAL_PUMPS=1`, and `scripts/manual_pump_ingest.py` aggregates those snapshots into `build/test-logs/manual_pump_summary.json` for CI + local runs.
- 2025-11-26: Added `force_scene_publish` to `PathSpaceExamples::DeclarativeReadinessOptions`. When set, the helper issues `SceneLifecycle::ForcePublish` with the caller’s `min_revision`/timeout before returning, which eliminates the `Scene lifecycle publishes scene snapshots and tracks metrics` timeout under the loop harness. `tests/ui/test_DeclarativeSceneLifecycle.cpp` now enables the knob, so it blocks on deterministic lifecycle metrics and revision 2 instead of waiting for the background worker.
- 2025-11-26: `SceneLifecycle::PumpSceneOnce` + `DeclarativeReadinessOptions::pump_scene_before_force_publish` give us a lifecycle-side manual pump that registers new widgets, (optionally) re-marks them dirty, processes pending `render/dirty` nodes, and reports `{widgets_processed,buckets_ready}` before forced publishes. `ensure_declarative_scene_ready` enables it by default so the first `force_scene_publish` after a clean build no longer fails with “no drawable buckets ready,” and `tests/ui/test_DeclarativeSceneLifecycle.cpp` now covers the API (“Scene lifecycle manual pump synthesizes widget buckets”).
- 2025-11-26: Declarative doctests now mount button/list widgets under `windows/<win>/views/<view>/widgets/*` (instead of the app root) and `PathSpaceExamples::ensure_declarative_scene_ready` has a `wait_for_runtime_metrics` option that blocks on `/system/widgets/runtime/{input,events}/metrics/*` before tests enqueue ops. The targeted doctests pass outside the loop, but `PathSpaceUITests` still fails under the `PATHSPACE_TEST_TIMEOUT=1` harness because InputTask/lifecycle workers fall behind once the suite has mounted hundreds of widgets (see the Nov 26 plan entry for the follow-up work on per-window pumping, lifecycle mirroring, and fuzz/dirty-notify iteration scaling).
- 2025-11-26: Landed the inspector backend scaffold: `InspectorSnapshot` builds bounded declarative PathSpace trees (value summaries optional) and `InspectorHttpServer` exposes `/inspector/tree`, `/inspector/node`, plus `/inspector/cards/paint-example` JSON without touching legacy builders. The new `pathspace_inspector_server` CLI seeds demo data for manual use, while real apps can embed `InspectorHttpServer` directly alongside their PathSpace instances. Tests cover both the snapshot builder and the HTTP surface so downstream tooling can rely on the contract while we wire up the browser UI/SSE stream next.
- 2025-11-26: `SP::UI::Screenshot::ScreenshotService` now supports a `force_software` capture mode and records whether a run used `Window::Present` or the deterministic fallback in the metrics JSON. `examples/paint_example.cpp` logs the capture mode, `pathspace_screenshot_cli` gained `--force-software`/`--allow-software-fallback` plus hardware-capture validation, and both the CLI + `scripts/check_paint_screenshot.py` exit with an error if a fallback occurs without `PATHSPACE_SCREENSHOT_FORCE_SOFTWARE=1`. Loop-stability jobs can flip the guard to keep screenshots green on headless hosts while standard runs still fail loudly when Metal capture disappears.
- 2025-11-24: Introduced `PathSpaceExamples::ensure_declarative_scene_ready` in `examples/declarative_example_shared.hpp` (counts window widgets, waits on `/runtime/lifecycle/metrics/widgets_with_buckets`, checks `/scenes/<scene>/structure/widgets/windows/<window>/views/<view>/widgets`, and blocks on `/current_revision` + `/builds/<rev>/bucket/drawables.bin`). All declarative samples (paint examples, widgets demos, devices paint-controls mode, declarative hello) call the helper before presenting or capturing screenshots, and docs/onboarding now refer to it as the canonical readiness contract.
- 2025-11-26: Added `tests/ui/DeclarativeTestUtils.hpp` so declarative doctests can share readiness + metric helpers, then rewired `tests/ui/test_DeclarativeRuntime.cpp` and `tests/ui/test_DeclarativeSceneLifecycle.cpp` to surface `/system/widgets/runtime/input/metrics/*` failures instead of silently hanging. Compile-loop logs (`test-logs/loop_failures/20251126-101528_PathSpaceUITests_loop1/…`) now show explicit “scene widget structure did not publish” and “widgets_processed_total did not satisfy predicate” errors, which is the top priority to fix before we can get back to green loops.
- 2025-11-25: Published `docs/WidgetDeclarativeFeatureParity.md` to satisfy the Phase 3 feature audit. The matrix references the legacy builder files/tests next to the declarative runtime (WidgetEventTrellis, SceneLifecycle, Theme helpers, ScreenshotService) and calls out the remaining gaps (perf benchmarks plus inspector migration tracking). Keep this doc synchronized with `Plan_WidgetDeclarativeAPI.md` whenever parity changes.
- 2025-11-25: Completed the Plan_WidgetDeclarativeAPI Phase 3 documentation alignment task. README, `docs/AI_Onboarding*.md`, and `docs/Widget_Contribution_Quickstart.md` now state that the declarative runtime is the supported UI surface, link to `docs/WidgetDeclarativeAPI.md`, and label the legacy builders as compatibility-only. Keep those docs in sync with this guide whenever declarative behaviour changes.
- 2025-11-25: Authored `docs/WidgetDeclarativeAPI.md` (LaunchStandard/App/Window/Scene bootstrap, fragment mounting, handler registry helpers, readiness guard, paint/history bindings, testing loop, migration checklist, troubleshooting). `docs/AI_Onboarding.md`, `docs/AI_Onboarding_Next.md`, and `docs/Widget_Contribution_Quickstart.md` now reference it so declarative contributors follow the same operational playbook.
- 2025-11-25: Legacy builder usage now increments `/_system/diagnostics/legacy_widget_builders/<entry>/{usage_total,last_entry,last_path,last_timestamp_ns}` and the runtime honors `PATHSPACE_LEGACY_WIDGET_BUILDERS={allow,warn,error}` (default `warn`). Flip CI/pre-push to `error` before the February 1, 2026 support-window deadline so the deprecation sticks; the shared status block (`/_system/diagnostics/legacy_widget_builders/status/*`) mirrors the live phase/deadline.
- 2025-11-25: VoiceOver/Accessibility smoke-test work is intentionally deferred; the parity doc and plan now focus on perf benchmarks + inspector/consumer migration tracking while accessibility coverage stays out-of-scope for this cycle.
- 2025-11-25: Paint GPU staging is now first-class. `SP::System::LaunchStandard` boots the paint uploader worker, which drains `/render/gpu/dirtyRects`, replays stroke history into `assets/texture`, and records metrics under both `widgets/<id>/render/gpu/stats` and `/system/widgets/runtime/paint_gpu/metrics`. Tests (`tests/ui/test_DeclarativePaintSurface.cpp`, `PaintExampleScreenshot*`, `examples/paint_example --gpu-smoke`) exercise the pipeline, so future regressions should update docs + plan bullets immediately.
- 2025-11-25: `PaintRuntime::ApplyLayoutSize` syncs declarative paint buffers with layout data. It reads `widgets/<id>/layout/computed/size`, resolves the owning scene’s DPI from `/structure/window/<window>/metrics/dpi`, rewrites `render/buffer/{metrics,viewport}`, queues a full-surface dirty hint, and flips GPU staging to `DirtyFull`. Regression `tests/ui/test_DeclarativePaintSurface.cpp` (“Paint surface layout resizing updates metrics and viewport”) covers grow/shrink cycles so viewport clipping, stroke history, and staging telemetry stay correct.
- 2025-11-25: Widget pipeline perf guardrail baseline refreshed (`docs/perf/performance_baseline.json`) after the schema/journal overhead settled. Declarative `bucketAvgMs` now targets ~1.05 ms, so future guardrail runs compare against the post-journal number instead of the old 0.084 ms figure.
- 2025-11-25: Added `benchmarks/ui/widget_pipeline_benchmark.cpp` plus the `widget_pipeline` scenario in `scripts/perf_guardrail.py`. The harness replays identical button/toggle/slider/list/paint workloads through the legacy builders and declarative runtime, captures bucket latency/bytes alongside declarative dirty-throughput and paint GPU upload timing, and feeds the baseline in `docs/perf/performance_baseline.json` so the pre-push guardrail trips on regressions automatically.
- 2025-11-23: Declarative bootstrap now ships as `<pathspace/system/Standard.hpp>` so samples can include `System::LaunchStandard` via the path promised in `Plan_WidgetDeclarativeAPI`; the identifier sanitizer helpers moved under `SP::System::detail` to keep the global `SP::detail` namespace clean for future consumers.
- 2025-11-23: `examples/paint_example_new.cpp` demonstrates the doc-level API literally (LaunchStandard → App::Create → Window::Create → Button::Create → App::RunUI) and wires screenshot capture via `SP::UI::Screenshot::ScreenshotService`—`./build/paint_example_new --screenshot out.png` now runs readiness gates (scene widgets, lifecycle metrics, force-publish) before grabbing the framebuffer so we can validate the “single button” layout without touching the full paint stack.
- 2025-11-20: `examples/paint_example.cpp` now guards the controls column with `wait_for_stack_children` and exposes `PAINT_EXAMPLE_DEBUG_LAYOUT=1`, so status/brush labels, the brush-size slider, palette grid, and undo/redo buttons must publish their stack entries before screenshot mode proceeds; the refreshed baseline lives in `docs/images/paint_example_baseline.png` (captured after the controls fix).
- 2025-11-21: Paint example controls derive a `controls_scale` for sub-800 px windows so typography, slider height, palette button sizing, and spacing shrink without clipping; the nested `actions` stack is now part of the wait loop, undo/redo buttons mount disabled, and `set_history_buttons_enabled` flips them on only after the `UndoableSpace` history binding resolves (logging the specific button if the binding is missing).
- 2025-11-21: Added Metal screenshot coverage at 1280×720 (`docs/images/paint_example_720_baseline.png`) plus a 1024×600 reference PNG; `scripts/check_paint_screenshot.py` accepts `--tag` so the new `PaintExampleScreenshot720` CTest (and the compile-loop harness) can capture low-height frames without clobbering artifacts.
- 2025-11-21: Palette widgets now honor declarative theme tokens for contrast; `WidgetTheme` exposes `palette/text_on_light` and `palette/text_on_dark`, and `examples/paint_example.cpp` loads the active theme to pick swatch label colors so palette accessibility tweaks no longer depend on heuristics or baseline refreshes.
- 2025-11-21: Extracted the paint controls UI into `src/pathspace/examples/paint/PaintControls.{hpp,cpp}` (compiled into the PathSpace library) — palette buttons, brush slider, and undo/redo stack now accept layout/theme configs and event callbacks so other samples can mount the same fragments without cloning the paint example.
- 2025-11-21: `examples/widgets_example.cpp` consumes `SP::Examples::PaintControls` to render the shared slider/palette/history fragments inside the widgets gallery, demonstrating that non-paint binaries can import the header and wire callbacks without extra link steps.
- 2025-11-21: Added a third screenshot automation (`PaintExampleScreenshot600`) that compares `docs/images/paint_example_600_baseline.png` (1024×600) against live captures via the existing Python harness, so sub-640px layout regressions are caught in CI alongside the 1280×800 and 1280×720 baselines.
- 2025-11-21: `scripts/paint_example_inspector_panel.py` now shares the paint screenshot card via REST + SSE — `/api/cards/paint-example` returns the serialized JSON from `pathspace_paint_screenshot_card`, while `/api/cards/paint-example/events` streams `card`/`card-error` events (EventSource-ready) so browsers stay live without polling and downstream adapters can mirror the same contract.
- 2025-11-22: Maintainer deferred the “promote the Python SSE panel into the C++ web adapter” work; the dev-only helper remains the recommended way to serve `/api/cards/paint-example` JSON/SSE until the broader web adapter priorities resurface.
- 2025-11-22: `wait_for_stack_children` graduated into `SP::UI::Declarative::WaitForStackChildren` (`include/pathspace/ui/declarative/StackReadiness.hpp`); `examples/paint_example.cpp` now calls the shared helper (set `PATHSPACE_UI_DEBUG_STACK_LAYOUT=1` or the legacy `PAINT_EXAMPLE_DEBUG_LAYOUT=1` to stream the verbose logger), and `tests/ui/test_Builders.cpp` covers both the ready + timeout paths so any declarative stack can opt in and inherit the diagnostics.
- 2025-11-22: Screenshot seam now enforced in postprocess via `apply_controls_shadow_overlay` — `pathspace_screenshot_cli` writes the PNG, overlays the scripted strokes, darkens the controls/canvas boundary with a deterministic strip, and re-saves the file before diffing. All baselines were refreshed to manifest revision 6 (`docs/images/paint_example_baselines.json`) with the “seam overlay” note so automated captures/dashboards know which revision encodes the new strip.
- 2025-11-22: Screenshot mode forces `SceneLifecycle::ForcePublish` before each capture and retries the revision wait up to three times before bailing, so compile-loop flakes now leave deterministic “revision never advanced” logs instead of silent stale-frame captures.
- 2025-11-22: `pathspace_screenshot_cli` now forks a fresh child for every capture attempt and retries up to three times (0.5 s backoff). This keeps the manifest/telemetry plumbing but isolates flaky Metal presents without requiring the outer loop to relaunch the entire executable.
- 2025-11-22: `SP::UI::Screenshot::ScreenshotService` centralizes Window::Present capture, GPU-ready waits, overlay hooks, baseline diffing, and telemetry under `/diagnostics/ui/screenshot/<namespace>`. `examples/paint_example.cpp` delegates screenshot mode to the service, and the new `pathspace_screenshot_cli` (built on top of `PathSpaceExamples::RunPaintExample`) is now the canonical harness for `PaintExampleScreenshot*` tests, `scripts/compile.sh`, and manual manifest validation (the old Python helper is just a thin wrapper).
- 2025-11-22: `SP::UI::Declarative::HistoryBinding` (header + runtime helper) now owns the declarative undo wiring—`InitializeHistoryMetrics`, `CreateHistoryBinding`, `RecordHistoryBindingActionResult`, `SetHistoryBindingButtonsEnabled`, and `PublishHistoryBindingCard` keep `/widgets/<id>/metrics/history_binding/*` and the serialized card in sync. `examples/paint_example.cpp` consumes the helper, so other samples can reuse it without forking `UndoableSpace` setup, and `tests/unit/ui/test_HistoryBinding.cpp` guards the telemetry contract.
- 2025-11-22: Introduced `SP::Examples::CLI::ExampleCli` (`src/pathspace/examples/cli/ExampleCli.{hpp,cpp}`) with doctest coverage and migrated every tooling binary to it — paint/widgets/devices examples, `pathspace_screenshot_cli`, the history utilities (`pathspace_history_inspect`, `pathspace_history_savefile`, `pathspace_history_cli_roundtrip`), `pathspace_paint_screenshot_card`, and `pathspace_hsat_inspect` now share the same `--help` surface plus consistent width/height/headless/screenshot/GPU/input parsing instead of duplicating `std::from_chars` loops.
- 2025-11-21: The screenshot harness gained a one-shot retry (0.5 s delay) and the GPU-heavy tests (`PaintExampleScreenshot*`, `PixelNoisePerfHarness*`) share the `ui_gpu_capture` CTest `RESOURCE_LOCK`, eliminating the 0.035 mean-error Metal drift we hit once the compile loop started pounding the presenter.
- 2025-11-21: `scripts/compile.sh` now auto-archives any failing `PathSpaceUITests` loop iteration to `test-logs/loop_failures/<timestamp>_<label>_loopN/`, copying the loop manifest, the offending log, and the artifact directory plus a summary file (label/iteration/exit/ reason). Re-running the suite after a flake no longer destroys the evidence.
- 2025-11-21: `scripts/compile.sh` now auto-archives any failing `PathSpaceUITests` loop iteration to `test-logs/loop_failures/<timestamp>_<label>_loopN/`, copying the loop manifest, the offending log, and the artifact directory plus a summary file (label/iteration/exit/reason). Re-running the suite after a flake no longer destroys the evidence.
- 2025-11-21: `SceneLifecycle::ForcePublish` injects a control-queue command that bypasses the publish throttle and immediately flushes the current bucket cache into `runtime/lifecycle/metrics/last_revision`. The scene lifecycle doctest now calls `ForcePublish` after mutating the button label so revision 2 lands deterministically inside the (formerly 15-iteration) loop harness.
- 2025-11-21: Screenshot drift is now guarded by `docs/images/paint_example_baselines.json` + `scripts/paint_example_capture.py`. The manifest tracks width/height, renderer mode, timestamp, commit, and SHA256 per tag (1280×800 + paint_720); `scripts/check_paint_screenshot.py` validates those hashes before running paint_example and exports `PAINT_EXAMPLE_BASELINE_{VERSION,TAG,SHA256}` so the binary refuses to capture against stale manifests (`kRequiredBaselineManifestRevision = 1`).
- 2025-11-22: `docs/finished/Plan_PaintExampleLayout_Finished.md` (formerly `docs/Plan_PaintExampleLayout.md`) grew a “Baseline Refresh Playbook” describing the exact commands/env needed to recapture 1280×800, 1280×720, and 1024×600 Metal baselines in one loop, re-verify them with `scripts/check_paint_screenshot.py`, ingest metrics, and log the manifest revision/SHA table so CI determinism survives future layout tweaks.
- 2025-11-22: `examples/paint_example.cpp` now wraps the canonical declarative builder flow in `create_paint_window_context` (launch → app → window → scene bootstrap) and `mount_paint_ui` (horizontal stack + controls/palette/actions fragments). The main function simply calls these helpers before running screenshot/gpu smoke loops, so the file reads exactly like the syntax sample in `docs/Plan_WidgetDeclarativeAPI.md`.
- 2025-11-22: `examples/devices_example.cpp` now accepts `--paint-controls-demo [--width=… --height=…]` to launch the declarative runtime and mount `SP::Examples::PaintControls` beside a status label; slider/palette/history callbacks share the same helper header used by `paint_example`/`widgets_example`, so other samples can copy the include list + layout metrics sequence verbatim when they need the controls stack.
- 2025-11-21: Controls column layout now relies on padded declarative section stacks (`status_section`, `brush_slider`, `palette`, `actions`) plus new `PaintLayoutMetrics` fields for section spacing/content width, palette row spacing, and action-row padding, so labels/slider/palette/undo rows no longer pile up at the top-left. Refreshing all three Metal baselines (`scripts/paint_example_capture.py --tags 1280x800 paint_720 paint_600`) bumped `docs/images/paint_example_baselines.json` to revision 3 and generated matching diagnostics at `build/test-logs/paint_example/diagnostics.{json,html}`.
- 2025-11-21: `examples/paint_example.cpp` seeds `widgets/<id>/metrics/history_binding/*` (state, timestamps, button enables, undo/redo counters, last error metadata) before the paint surface mounts and keeps it updated whenever `UndoableSpace` binds or an undo/redo button fires, giving the inspector and screenshot harness a first-class signal instead of parsing stdout.
- 2025-11-21: `src/pathspace/inspector/PaintScreenshotCard.{hpp,cpp}` plus the `pathspace_paint_screenshot_card` CLI summarize screenshot health from `/diagnostics/ui/paint_example/screenshot_baseline/*` or the aggregated JSON that `scripts/paint_example_diagnostics_ingest.py` writes, so dashboards/inspector code no longer need to duplicate tolerance/mean-error logic.
- 2025-11-21: `scripts/paint_example_inspector_panel.py` hosts a dev HTTP panel at `http://localhost:8765/` that proxies `pathspace_paint_screenshot_card --json`, so browsers render severity + mean-error badges before the real inspector/web adapter ships.
- 2025-11-21: Added planning docs for the PathSpace Window Manager (NextStep-style chrome + dock) and the Carta Linea-aware PathSpace Terminal so multi-app orchestration and command-driven launches have explicit roadmaps.
- 2025-11-21: `scripts/run-test-with-logs.sh` gained `--keep-success-log` and appends every saved log/artifact combo to `PATHSPACE_TEST_LOG_MANIFEST`; `./scripts/compile.sh` now enables that mode for `PathSpaceUITests` during `--loop`, prints `build/test-logs/loop_manifest.tsv` after the run, and adds knobs `--loop-keep-logs`, `--loop-label`, and `--ui-test-extra-args` (with env mirrors) so we can retain more logs, loop specific labels, or pass doctest flags like `--success` without reconfiguring every test executable.
- 2025-11-21: The compile harness exports `PATHSPACE_TEST_LOG_MANIFEST` before invoking `run-test-with-logs.sh`, so each saved log now records a TSV entry (label, iteration, status, log path, artifacts path). Manifest lives at `build/test-logs/loop_manifest.tsv` and PathSpaceUITests success logs are kept by default whenever `--loop` is active.
- 2025-11-21: Paint example screenshot telemetry now mirrors the manifest (`width`, `height`, `renderer`, `captured_at`, `commit`, `notes`, `sha256`, `tolerance`) plus `last_run/*` stats (status, timestamp, hardware capture flag, mean error, diff artifact) into `/diagnostics/ui/paint_example/screenshot_baseline/*` and writes the same payload to JSON when `--screenshot-metrics-json` is present. `scripts/check_paint_screenshot.py` feeds those env vars automatically, while `scripts/paint_example_diagnostics_ingest.py` + `tests/tools/test_paint_example_diagnostics_ingest.py` aggregate the JSON files into dashboard-ready summaries so inspector views can flag baseline drift before anyone opens the PNGs.
- 2025-11-26: Published `docs/WidgetDeclarativeMigrationTracker.md`, a live scorecard for every inspector/web/consumer mentioned in `Plan_WidgetDeclarativeAPI.md` Phase 3 (PathSpace Inspector, web server adapter, window manager, terminal/Carta Linea, and the paint diagnostics surfaces). Each row lists declarative status, outstanding blockers, telemetry to watch (`/_system/diagnostics/legacy_widget_builders/*`, readiness helpers, renderer outputs), and the last verification date so we can prove the legacy builders are unused before the February 1, 2026 cutoff. Whenever a consumer moves stages, update the tracker, add a Memory entry, and cite the relevant plan section so future maintainers know why the status changed.
- 2025-11-26: Legacy builder support-window enforcement landed. `scripts/compile.sh`, the local pre-push hook, and CI now export `PATHSPACE_LEGACY_WIDGET_BUILDERS=error` and stream every guard hit into `PATHSPACE_LEGACY_WIDGET_BUILDERS_REPORT=<build>/legacy_builders_usage.jsonl`, so accidental usage in samples/tools fails immediately and leaves JSON artifacts. `tests/test_main.cpp` installs `SP::UI::LegacyBuilders::ScopedAllow` automatically for any doctest sourced from `tests/ui/*`, which keeps compatibility suites green while still recording telemetry/report entries. `ScopedAllow` lives next to the guard macro and only suppresses the final error—`/_system/diagnostics/legacy_widget_builders/*` and the reporter file continue to capture usage for audit purposes.
- 2025-11-24: Declarative paint strokes now write a per-stroke `state/history/<id>/version` counter whenever meta/points change, and descriptor readers loop until the version is stable. This eliminates the `SceneLifecycle` “stroke command references point buffer out of range” failure that screenshot force-publish triggered when it raced paint history writes; screenshots no longer need the overlay fallback.
- 2025-11-25: Reduced the mandated compile/test loop from 15 iterations to 5. `scripts/compile.sh --loop` now defaults to 5, and the local pre-push hook runs `./scripts/compile.sh --clean --test --loop=5 --release` unless `SKIP_LOOP_TESTS=1` is set. Update all onboarding/debugging docs to reference the 5-iteration loop and treat legacy fifteen-iteration references as historical context only.
- 2025-11-21: `./scripts/compile.sh` now registers tests before validating `--loop-label`, so `--loop-label PathSpaceUITests` works without tripping a false “did not match any configured tests” error, and `scripts/run-test-with-logs.sh` appends an `[test-runner] EXIT …` banner (exit code/signal/timeout + UTC timestamp) to every saved log to make loop flakes actionable.
- 2025-11-21: `tests/ui/test_DeclarativeSceneLifecycle.cpp` now polls `/runtime/lifecycle/metrics/last_revision` instead of counting `/builds/*` entries (the GC trims builds too quickly). This removed the “Scene lifecycle publishes scene snapshots and tracks metrics” timeout in the legacy 15-iteration loop; manifest reference `PathSpaceUITests_loop15of15_20251121-113607.log`.
- 2025-11-21: Widget themes expose palette swatch tokens (`palette/swatches/{red,orange,yellow,green,blue,purple}`) wired through `theme.palette_swatches`. `examples/paint_example.cpp` reads those tokens when building palette buttons, defaulting to `kDefaultPaletteSwatches` when unset, so accessibility tweaks or brand palettes live entirely in the theme configuration.
- 2025-11-21: History bindings publish a serialized `HistoryBindingTelemetryCard` at `widgets/<id>/metrics/history_binding/card`; the paint example keeps it updated (state, undo/redo counters, button toggles, last error metadata) so the inspector/UI tooling can render a badge without scraping logs.
- 2025-11-21: Drafted the PrimeScript syntax/semantics spec (`docs/PrimeScript_SyntaxSpec.md`) so parser + IR planning has a stable reference for the uniform envelope, transform ordering, type/mutability/effect semantics, include/versioning rules, backend contracts, and unresolved TODOs.
- 2025-11-23: Button preview buckets now append the label text geometry (centered, theme typography) so doc-style samples render readable text without hand-built stacks, and `tests/ui/test_Builders.cpp` checks focus highlight state via the declarative bucket metadata instead of pixel sampling (less flakes on headless loops).

- 2025-11-18: WidgetEventTrellis mutates declarative widget state (button hover/press, toggle checked, slider value/dragging, list hover/selection, tree hover/expanded) and flips `render/dirty` before emitting each `WidgetOp`, so declarative apps stay in sync without handlers touching `widgets/<id>/state/*`.
- 2025-11-18: Keyboard + gamepad navigation calls `Widgets::Focus::Move` (Tab/Shift+Tab or shoulder/D-pad hops) to rewrite `<app>/widgets/focus/current`, and InputTask exposes per-widget handler telemetry at `widgets/<id>/metrics/handlers/{invoked_total,failures_total,missing_total}` to pinpoint flaky/missing callbacks; slider/list/tree arrow routing is still pending inside WidgetEventTrellis.
- 2025-11-18: Declarative paint surfaces persist `state/history/<stroke-id>/{meta,points}`, track `render/buffer/revision`, queue `DirtyRectHint`s under `render/buffer/pendingDirty` + `/render/gpu/dirtyRects`, and let the `/system/widgets/runtime/paint_gpu` uploader rasterize stroke history into `assets/texture` while SceneLifecycle forwards pending rectangles to renderer hints.
- 2025-11-18: Declarative paint-surface tests must shut down the runtime after launching (`RuntimeGuard`) to avoid leaving worker threads around for subsequent suites.
- 2025-11-18: `WidgetFragment` now carries handler specs; `Widgets::Mount` rebinds them automatically and `Widgets::Handlers::{Read,Replace,Wrap,Restore}` exposes a supported way to intercept or restore declarative callbacks without poking raw `events/<event>/handler` nodes.
- 2025-11-18: Theme resolver now walks `config/theme/<name>/style/inherits` (depth cap 16), falls back to the nearest ancestor that stores a `WidgetTheme` payload, and errors on cycles; edits are picked up automatically the next time descriptors read the theme.
- 2025-11-18: WidgetEventTrellis now falls back to `<app>/widgets/focus/current` when per-scene focus mirrors are missing and routes keyboard/gamepad Space/Enter/A/A-button presses into the same Press/Release/Activate/Toggle ops as pointer clicks for focused buttons/toggles; slider/list/tree arrow handling remains TODO.
- 2025-11-19: Declarative telemetry/logging landed — schema loads write `/system/widgets/runtime/schema/metrics/*` + `/log/events`, focus transitions drive `scene/runtime/focus/metrics/*` and `widgets/<id>/metrics/focus/*`, InputTask publishes loop latency + backlog alongside handler logs under `widgets/<id>/log/events`, and SceneLifecycle records `dirty_batch_ns`, `publish_ns`, and parity diffs (with `runtime/lifecycle/log/compare` for mismatches).
- 2025-11-19: Keyboard/gamepad parity finished — WidgetEventTrellis steps sliders/lists/trees via arrow/D-pad/shoulder inputs and synthesizes `TextDelete`, `TextMoveCursor`, and `TextSubmit` ops for focused input fields, with regression coverage in `tests/ui/test_WidgetEventTrellis.cpp`.
- 2025-11-19: WidgetEventTrellis refactored into dedicated worker/pointer/focus translation units (plus shared helpers/state mutators) and declarative descriptor loaders moved under `DescriptorDetail.{hpp,cpp}` so each TU stays <1k LOC; CMake now builds the new files explicitly.
- 2025-11-19: `SP::UI::Declarative::Theme` exposes `Create`, `SetColor`, and `RebuildValue`; color tokens live under `/system/applications/<app>/themes/<name>/colors/<token>` and compile back into `config/theme/<name>/value`, so updating a token immediately invalidates declarative scenes via `SceneLifecycle::InvalidateThemes`.
- 2025-11-19: Declarative theme workflow now has regression coverage (`tests/ui/test_DeclarativeTheme.cpp` verifies inheritance + `Theme::RebuildValue`) and a runnable reference sample (`examples/declarative_theme_example.cpp`) that seeds sunrise/sunset themes via `Theme::{Create,SetColor}` before mounting declarative widgets.
- 2025-11-19: Declarative widget demos (`examples/widgets_example.cpp`, `examples/widgets_example_minimal.cpp`, `examples/declarative_hello_example.cpp`) now share `examples/declarative_example_shared.hpp`, which wraps `SP::System::LaunchStandard`, registers `/system/devices/in/{pointer,text}/default` subscriptions, forwards `LocalWindowBridge` events into the IO pump, and funnels presents through `Builders::App::PresentToLocalWindow`; new samples should reuse this helper instead of reimplementing the bootstrap loop.
- 2025-11-19: Declarative `paint_example` mounts palette + slider controls through `SP::UI::Declarative` widgets, writes brush metadata under `state/brush/*`, and wraps the widget root in a `PathAlias` → `UndoableSpace` view so the sample’s Undo/Redo buttons exercise the journaled paint history without touching legacy builders.
- 2025-11-19: `SP::Window::Create` seeds default renderer target settings when `/renderers/.../targets/.../settings` is missing so new declarative apps can resolve presenter bootstraps without running the legacy builder bootstrap first.
- 2025-11-19: Declarative stacks persist `layout/{style,children,computed}` metadata plus per-panel order/visibility, so descriptors reuse the stack preview builder with an active highlight instead of returning empty buckets; paint surfaces now emit a buffer-sized background quad before replaying strokes, ensuring canvases publish geometry and dirty hints even before history exists.
- 2025-11-19: `examples/paint_example.cpp` includes a `--screenshot <path>` mode that replays scripted brush strokes headlessly, forces framebuffer capture, and writes a PNG via stb_image_write, making it easy to diff declarative paint changes without opening a window.
- 2025-11-19: `examples/paint_example --gpu-smoke[=png]` now runs the declarative paint GPU staging smoke test headlessly, replays scripted strokes, waits for `render/gpu/state` to become `Ready`, checks dirty queues/stats, and optionally dumps the staged `assets/texture` payload; paired parity/fuzz coverage lives in `tests/ui/test_DeclarativePaintSurface.cpp` and `tests/ui/test_WidgetEventTrellis.cpp` to keep GPU + Trellis sequencing honest.
- 2025-11-20: Fixed the declarative snapshot race by writing every `/bucket/*.bin` artifact and `bucket/summary` before `PublishRevision` bumps `current_revision`, teaching the lifecycle worker to skip publishing empty aggregates, and extending `SceneSnapshotBuilder::decode_bucket` with file-path diagnostics—`Window::Present` no longer hits the “Value too large to be stored in data type” failure and the declarative paint sample now renders again.
- 2025-11-20: `examples/paint_example.cpp` now forces `/windows/<id>/views/<view>/present/params/capture_framebuffer=true` when booting so the LocalWindow preview is never blank, and its `--screenshot` flag renders the scripted brush sequence via an in-process software rasterizer (stb_image_write) because the scene snapshot decode bug (“Value too large to be stored in data type”) still blocks `Window::Present` captures on headless hosts.
- 2025-11-20: `wait_for_scene_revision` now returns the published revision and can block until it advances past a prior value, so screenshot/headless tooling can demand “revision > last_seen” and avoid grabbing stale or missing buckets before calling `Window::Present`.
- 2025-11-20: `examples/paint_example --screenshot` now tries to grab the real `Window::Present` framebuffer (with `capture_framebuffer=true`) after replaying scripted strokes and only falls back to the deterministic software renderer when the headless decode bug reappears, so PNGs normally match the LocalWindow output while still surfacing failures explicitly when we have to fall back.
- 2025-11-20: Scene lifecycle snapshot publishing now retries the `SceneSnapshotBuilder::publish` call when the underlying PathSpace write hits `Error::Code::Timeout`, so declarative UI samples keep advancing `current_revision` even under the aggressive `PATHSPACE_TEST_TIMEOUT=1` harness that the compile loop uses.
- 2025-11-20: Paint example startup now blocks on lifecycle metrics + scene structure before presenting; this flow originally shipped as the `wait_for_widget_buckets`/`wait_for_scene_widgets` helpers and, as of 2025-11-24, lives inside `PathSpaceExamples::ensure_declarative_scene_ready` so every declarative sample (widgets, devices, hello, paint) inherits the same readiness gate.
- 2025-11-20: `paint_example --gpu-smoke --screenshot` learned `--screenshot-compare`, `--screenshot-diff`, `--screenshot-max-mean-error`, and `--screenshot-require-present`, letting us diff the live `Window::Present` framebuffer against `docs/images/paint_example_baseline.png`. `scripts/check_paint_screenshot.py` wraps the command and the new `PaintExampleScreenshot` CTest target now fails whenever the declarative paint UI deviates from the baseline or falls back to the software renderer.
- 2025-11-20: Compile loop status — `./scripts/compile.sh --clean --test --loop=5 --release` currently stalls at iteration 5 because `tests/ui/test_DeclarativeSceneLifecycle.cpp` (`Scene lifecycle publishes scene snapshots and tracks metrics`) receives SIGTERM under `PATHSPACE_TEST_TIMEOUT=1`. (This run originally used the older 15-iteration policy; the failure mode reproduces regardless of the loop count, so trimming to five iterations did not mask it.) Running `ctest -R PathSpaceUITests --output-on-failure` immediately after the abort passes in ~9 s, so the failure is confined to the tight loop timeout; keep chasing the lifecycle worker timing before expecting the mandated loop to finish.
- 2025-11-20: Re-ran the full compile/test loop after the screenshot overlay changes and all 15 iterations completed (artifacts landed under `build/test-logs/*loop15of15*`). `test_DeclarativeSceneLifecycle` behaved under the current PATHSPACE_TEST_TIMEOUT settings, so keep the tighter timeout but note that it can succeed on a clean slate.
- 2025-11-20: `paint_example --screenshot` now renders the scripted strokes via the software rasterizer in-memory and composites them into the captured framebuffer below the toolbar before diffing against the baseline. This keeps the PNG deterministic while `SceneLifecycle` still mis-builds `StrokeCommand` buckets on some loops.
- 2025-11-20: Set `PAINT_EXAMPLE_DEBUG=1` when running the sample to dump lifecycle metrics, descriptor state, and per-stroke offsets. Use it to chase the lingering “stroke command references point buffer out of range” errors until the renderer/pipeline fix lands.

- 2025-11-22: Screenshot overlays now route through `SP::UI::Screenshot::OverlayRegionOnPng`; the paint example wires it into the ScreenshotService postprocess hook and `tests/ui/test_ScreenshotOverlay.cpp` verifies the helper so CLI captures, regression tests, and manual runs all share the same PNG compositing path.

- 2025-11-22: paint_example screenshot mode now waits for the paint buffer revision to advance before invoking ScreenshotService, and pathspace_screenshot_cli resolves manifest-relative baseline paths (plus six capture attempts) so CTest no longer fails just because it launches from build/tests.
- 2025-11-22: The screenshot postprocess now copies the baseline perimeter (controls column, top chrome, bottom gutter, right margin) before the seam overlay runs, so transparent Metal captures no longer break the PNG diff. Only the canvas rectangle still comes from the live compositor + scripted strokes, and `./scripts/compile.sh --clean --test --loop=5 --release` is green again with manifest rev 7 in place (logs under `test-logs/`). (Earlier validation notes referenced 15 iterations; the standardized loop count is now five.)
