<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: AI_ARCHITECTURE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_a_i___a_r_c_h_i_t_e_c_t_u_r_e.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">AI_ARCHITECTURE </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Renderer snapshot builder details have moved out of this architecture document. See <a class="el" href="_a_i___plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a> (“Decision: Snapshot Builder”) for the authoritative policy, rebuild triggers, publish/GC protocol, and performance notes. This file focuses on PathSpace core (paths, trie storage, concurrency/wait/notify, views/alias layers, and OS I/O).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
UI/Rendering — cross-reference</h2>
<p>Present policy (backend-aware) and the software progressive present are documented in <a class="el" href="_a_i___plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a>. This architecture document focuses on PathSpace core; rendering/presenter details live in the plan. Also see “View keys (final)” and “Target keys (final)” in <a class="el" href="_a_i___plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a> for the authoritative schemas, and note that RenderSettings are a single-path atomic whole-object value; ParamUpdateMode::Queue refers to client-side coalescing before one atomic write (no server-side queue in v1).</p>
<p>See also:</p><ul>
<li><span class="tt"><a class="el" href="_a_i___plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> for the broader rendering plan and target I/O layout. If snapshot semantics change, update both documents in the same PR per <span class="tt">.rules</span>.<ul>
<li><span class="tt"><a class="el" href="_a_i___p_a_t_h_s_8md.html">docs/AI_Paths.md</a></span> for the canonical path namespaces and layout conventions; update it alongside changes to path usage and target I/O layout.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Contributing to PathSpace</h2>
<p>For AI-facing workflows (branching, PR creation, troubleshooting, commit guidelines), see AGENTS.md. This document focuses on code architecture and APIs.</p>
<p>PathSpace is a coordination language that enables insertion and extractions from paths in a thread safe datastructure. The data structure supports views of the paths similar to Plan 9. The data attached to the paths are more like a JSON datastructure than files though. The data supported is standard C++ data types and data structures from the standard library, user created structs/classes as well as function pointers, std::function or function objects for storing executions that generate values to be inserted at a path.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Path System</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Path Types</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Concrete Paths</h4>
<p>Concrete paths represent exact locations in the PathSpace hierarchy. They follow these rules:</p><ul>
<li>Must start with a forward slash (/)</li>
<li>Components are separated by forward slashes</li>
<li>Cannot contain relative path components (. or ..)</li>
<li>Names cannot start with dots</li>
<li>Components cannot be empty (// is normalized to /)</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;/data/sensors/temperature&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;/system/status/current&quot;</span></div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Glob Paths</h4>
<p>Glob paths extend concrete paths with pattern matching capabilities. They support:</p><ul>
<li><span class="tt">*</span> - Matches any sequence of characters within a component</li>
<li><span class="tt">**</span> - Matches zero or more components (super-matcher)</li>
<li><span class="tt">?</span> - Matches any single character</li>
<li><span class="tt">[abc]</span> - Matches any character in the set</li>
<li><span class="tt">[a-z]</span> - Matches any character in the range</li>
<li><span class="tt">\</span> - Escapes special characters</li>
</ul>
<p>Example patterns: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;/data/*/temperature&quot;</span>    <span class="comment">// Matches any sensor&#39;s temperature</span></div>
<div class="line"><span class="stringliteral">&quot;/data/**/status&quot;</span>       <span class="comment">// Matches status at any depth</span></div>
<div class="line"><span class="stringliteral">&quot;/sensor-[0-9]/*&quot;</span>       <span class="comment">// Matches numbered sensors</span></div>
<div class="line"><span class="stringliteral">&quot;/data/temp-?&quot;</span>          <span class="comment">// Matches single character variations</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Path Implementation</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Core Classes</h4>
<div class="fragment"><div class="line"><span class="comment">// Base path template</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Path {</div>
<div class="line">    T path;  <span class="comment">// string or string_view storage</span></div>
<div class="line">    <span class="keywordtype">bool</span> isValid() <span class="keyword">const</span>;</div>
<div class="line">    T <span class="keyword">const</span>&amp; getPath() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Concrete path types</span></div>
<div class="line"><span class="keyword">using </span>ConcretePathString = ConcretePath&lt;std::string&gt;;</div>
<div class="line"><span class="keyword">using </span>ConcretePathStringView = ConcretePath&lt;std::string_view&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Glob path types</span></div>
<div class="line"><span class="keyword">using </span>GlobPathString = GlobPath&lt;std::string&gt;;</div>
<div class="line"><span class="keyword">using </span>GlobPathStringView = GlobPath&lt;std::string_view&gt;;</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Path Component Iteration</h4>
<p>The system provides iterators to traverse path components: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>ConcreteIterator {</div>
<div class="line">    ConcreteNameStringView operator*() <span class="keyword">const</span>;  <span class="comment">// Current component</span></div>
<div class="line">    <span class="keywordtype">bool</span> isAtStart() <span class="keyword">const</span>;                    <span class="comment">// Check if at first component</span></div>
<div class="line">    std::string_view fullPath() <span class="keyword">const</span>;         <span class="comment">// Full path string</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>GlobIterator {</div>
<div class="line">    GlobName operator*() <span class="keyword">const</span>;  <span class="comment">// Current component with pattern matching</span></div>
<div class="line">    <span class="keywordtype">bool</span> isAtStart() <span class="keyword">const</span>;      <span class="comment">// Check if at first component</span></div>
<div class="line">    std::string_view fullPath() <span class="keyword">const</span>;  <span class="comment">// Full path string</span></div>
<div class="line">};</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Pattern Matching</h4>
<p>Pattern matching can handle various glob patterns:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>GlobName {</div>
<div class="line">    <span class="comment">// Returns match status</span></div>
<div class="line">    <span class="keyword">auto</span> match(<span class="keyword">const</span> std::string_view&amp; str) <span class="keyword">const</span></div>
<div class="line">        -&gt; <span class="keywordtype">bool</span> <span class="comment">/*match*/</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> isConcrete() <span class="keyword">const</span>;  <span class="comment">// Check if contains patterns</span></div>
<div class="line">    <span class="keywordtype">bool</span> isGlob() <span class="keyword">const</span>;      <span class="comment">// Check for glob characters</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Pattern matching behaviors:</p><ul>
<li><span class="tt">*</span> matches within component boundaries</li>
<li>Character classes support ranges and sets</li>
<li>Escaped characters are handled literally</li>
<li>Empty components are normalized</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Path Usage Examples</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Basic Path Operations</h4>
<div class="fragment"><div class="line">PathSpace space;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Insert at concrete path</span></div>
<div class="line">space.insert(<span class="stringliteral">&quot;/sensors/temp1/value&quot;</span>, 23.5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Insert using pattern</span></div>
<div class="line">space.insert(<span class="stringliteral">&quot;/sensors/*/value&quot;</span>, 0.0);  <span class="comment">// Reset all sensor values</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read with exact path</span></div>
<div class="line"><span class="keyword">auto</span> value = space.read&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;/sensors/temp1/value&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read with pattern</span></div>
<div class="line"><span class="keyword">auto</span> values = space.read&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;/sensors/*/value&quot;</span>);</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Pattern Matching Examples</h4>
<div class="fragment"><div class="line"><span class="comment">// Match any sensor</span></div>
<div class="line"><span class="stringliteral">&quot;/sensors/*&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Match sensors with numeric IDs</span></div>
<div class="line"><span class="stringliteral">&quot;/sensors/[0-9]*&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Match any depth under sensors</span></div>
<div class="line"><span class="stringliteral">&quot;/sensors/**/value&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Match specific character variations</span></div>
<div class="line"><span class="stringliteral">&quot;/sensor-?&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Match range of sensors</span></div>
<div class="line"><span class="stringliteral">&quot;/sensors/[1-5]&quot;</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
Path Performance Considerations</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Path Storage</h4>
<ul>
<li>Uses <span class="tt">string_view</span> for read-only operations to avoid copies</li>
<li>Maintains string ownership where needed for modifications</li>
<li>Caches path components for efficient iteration</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Pattern Matching Optimization</h4>
<ul>
<li>Early termination for non-matching patterns</li>
<li>Efficient character class evaluation</li>
<li>Optimized super-matcher (<span class="tt">**</span>) handling</li>
<li>Component-wise matching to minimize string operations</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
Memory Efficiency</h4>
<ul>
<li>Shared path component storage</li>
<li>Lazy evaluation of pattern matches</li>
<li>Efficient string views for immutable paths</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
Path Thread Safety</h3>
<p>The path system provides thread-safe operations through:</p><ul>
<li>Immutable path objects</li>
<li>Synchronized pattern matching</li>
<li>Thread-safe path resolution</li>
<li>Atomic path operations</li>
</ul>
<p>Testing guidance:</p><ul>
<li>Concurrency and scheduling changes (WaitMap, Node trie, Task/Executor) can expose intermittent races only under repeated runs.</li>
<li>Use the build helper to loop tests: <span class="tt">./scripts/compile.sh --loop[=N]</span> (default N=15) to increase the likelihood of catching rare timing issues.</li>
</ul>
<p>Wait/notify:</p><ul>
<li>Waiters are stored in a trie-backed registry keyed by concrete paths, with a separate registry for glob-pattern waiters.</li>
<li>Concrete notifications traverse the trie along the path (O(depth)), while glob notifications filter and match registered patterns.</li>
<li>All operations are synchronized with internal mutexes; waiter CVs are attached to nodes to minimize contention.</li>
</ul>
<p>Additional note:</p><ul>
<li>Task completion notifications are lifetime-safe via a NotificationSink token. Each <span class="tt">PathSpaceBase</span> owns a <span class="tt">shared_ptr&lt;NotificationSink&gt;</span> that forwards to its <span class="tt">notify(path)</span>; <span class="tt">Task</span> objects capture a <span class="tt">weak_ptr&lt;NotificationSink&gt;</span>. During shutdown, the <span class="tt">PathSpace</span> resets the <span class="tt">shared_ptr</span> so late notifications are dropped cleanly without dereferencing stale pointers.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Path Error Handling</h3>
<p>Comprehensive error handling for path operations:</p><ul>
<li>Path validation errors</li>
<li>Pattern syntax errors</li>
<li>Resolution failures</li>
<li>Type mismatches</li>
<li>Timeout conditions</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
Internal Data</h2>
<p>PathSpace stores data in a unified Node trie. Each Node contains:</p><ul>
<li>children: a concurrent hash map keyed by the next path component</li>
<li>data: an optional NodeData payload that holds serialized bytes and/or queued Task objects</li>
<li>nested: an optional nested PathSpaceBase anchored at that node</li>
</ul>
<p>Inserting more data at a path appends to the node’s NodeData sequence. Reading returns a copy of the front element; extracting pops the front element. Nodes that become empty after extraction are erased from their parent when safe.</p>
<p>Concurrency notes:</p><ul>
<li>children uses a sharded concurrent map for scalability</li>
<li>payload accesses (data/nested) are guarded by a per-node mutex to ensure safe updates under contention</li>
</ul>
<p>Additionally, nodes may hold <span class="tt">Task</span> objects representing deferred computations alongside serialized bytes. <span class="tt">NodeData</span> stores tasks (<span class="tt">std::shared_ptr&lt;Task&gt;</span>) and, when tasks complete, notifications are delivered via a <span class="tt">NotificationSink</span> interface: tasks hold a <span class="tt">std::weak_ptr&lt;NotificationSink&gt;</span> and the owning <span class="tt">PathSpaceBase</span> provides the <span class="tt">shared_ptr</span> token and forwards to <span class="tt">notify(path)</span>. This removes the need for a global registry and prevents use-after-free races during teardown (the space resets its token during shutdown, causing late notifications to be dropped safely).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Syntax Example</h2>
<div class="fragment"><div class="line">PathSpace space;</div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/numbers&quot;</span>, 5);</div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/numbers&quot;</span>, 3.5f);</div>
<div class="line">assert(space.take&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/collection/numbers&quot;</span>).value() == 5);</div>
<div class="line">assert(space.read&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;/collection/numbers&quot;</span>).value() == 3.5);</div>
<div class="line"> </div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/executions&quot;</span>, [](){<span class="keywordflow">return</span> 7;});</div>
<div class="line">assert(space.take&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/collection/executions&quot;</span>, Block{}).value() == 7);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
Polymorphism</h2>
<p>The internal spaces inside a path are implemented witha Leaf class, it's possible to inherit from that class and insert that child class in order to change the behaviour of parts of the path structure of a PathSpace instance. This can be used to have different behaviour for different sub spaces within a PathSpace. By default PathSpace will create a Leaf of the same type as the parent when creating new ones (which happens during insert of data).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
Path Globbing</h2>
<p>Paths given to insert can be a glob expression, if the expression matches the names of subspaces then the data will be inserted to all the matching subspaces. </p><div class="fragment"><div class="line">PathSpace space;</div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/numbers&quot;</span>, 5);</div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/numbers_more&quot;</span>, 4);</div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/other_things&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Globbed insert updates only paths matching the pattern &quot;numbers*&quot;</span></div>
<div class="line">space.insert(<span class="stringliteral">&quot;/collection/numbers*&quot;</span>, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Unaffected: different prefix</span></div>
<div class="line">assert(space.read&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/collection/other_things&quot;</span>).value() == 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Affected: matches &quot;numbers*&quot;</span></div>
<div class="line">assert(space.take&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/collection/numbers_more&quot;</span>).value() == 4);</div>
<div class="line">assert(space.take&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/collection/numbers_more&quot;</span>).value() == 2);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
Blocking</h2>
<p>Blocking is opt-in and expressed through the helpers in <span class="tt"><a class="el" href="_out_8hpp.html">src/pathspace/core/Out.hpp</a></span>.</p>
<ul>
<li>Passing <span class="tt">Block{}</span> to <span class="tt">read</span>/<span class="tt">take</span> (or composing <span class="tt">Out{} &amp; Block{}</span>) turns the call into a waiter when the target node is empty. The waiter is registered in the concrete or glob registry described in the wait/notify section.</li>
<li><span class="tt">Block{}</span> defaults to a very large timeout (100 years); override it with <span class="tt">Block{std::chrono::milliseconds{budget}}</span> to enforce a real deadline. When the timeout elapses, the operation returns an <span class="tt">Error::Timeout</span> in the <span class="tt">std::expected</span> result.</li>
<li>Successful reads/takes automatically deregister their waiter before returning. If the waiter is cancelled because the path is deleted or the space is shutting down, the operation reports an error so callers can retry or exit.</li>
<li>Inserts themselves do not block, but they wake both concrete and glob waiters on completion. Custom layers can tap into the same behaviour through <span class="tt"><a class="el" href="struct_block_options.html">BlockOptions</a></span> when forwarding or composing higher-level queues.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
Operations</h2>
<p>The operations in the base language are insert/read/extract, they are implemented as member functions of the PathSpace class.</p><ul>
<li><b>Insert</b>:<ul>
<li>Insert data or a Leaf to one or more paths. If the path does not exist it will be created.</li>
<li>The given path can be a concrete path in which case at most one object will be inserted or a glob expression path which could potentially insert multiple values.</li>
<li>Supports batch operations by inserting an initialiser list</li>
<li>Takes an optional In which has the following properties:<ul>
<li>Optional Execution object that describes how to execute the data (if the data is a lambda or function):<ul>
<li>Execute immediately or when the user requests the data via read/extract.</li>
<li>If the data should be cached and updated every n milliseconds.<ul>
<li>How many times the function should be executed.</li>
</ul>
</li>
<li>If the value to be stored is executed in a lazy fashion or right away.</li>
</ul>
</li>
<li>Optional Block object specifying what to do if the value does not (yet) exist, enables waiting forever or a set amount of time.</li>
</ul>
</li>
<li>The data inserted can be:<ul>
<li>Executions with signature T() or T(ConcretePath const &amp;path, PathSpace &amp;space) :<ul>
<li>Lambda</li>
<li>Function pointer</li>
<li>std::function</li>
<li>Preregistered executions for serialisation/deserialisation over the network.</li>
</ul>
</li>
<li>Data<ul>
<li>Fundamental types</li>
<li>Standard library containers if serialisable</li>
<li>User created structures/classes as long as they are serialisable</li>
</ul>
</li>
</ul>
</li>
<li>Returns an InsertReturn structure with the following information:<ul>
<li>How many items/Tasks were inserted.</li>
<li>What errors occurred during insertion.</li>
</ul>
</li>
<li>Syntax:<ul>
<li>InsertReturn PathSpace::put&lt;T&gt;(GlobPath const &amp;path, T const &amp;value, optional&lt;In&gt; const &amp;options={})</li>
</ul>
</li>
</ul>
</li>
<li><b>Read</b>:<ul>
<li>Returns a copy of the front value at the supplied path or Error if it could not be found, if for example the path did not exist or the front value had the wrong type.</li>
<li>Takes an optional ReadOptions which has the following properties:<ul>
<li>Optional Block object specifying what to do if the data does not exist or paths to the data do not exist:<ul>
<li>Wait forever if data/space does not exist</li>
<li>Wait a specified amount of milliseconds if data/space does not exist</li>
<li>Return an error</li>
</ul>
</li>
</ul>
</li>
<li>Takes a ConcretePath, does not support GlobPaths. Perhaps will implement a readMultiple later that returns a vector&lt;T&gt;</li>
<li>Syntax:<ul>
<li>std::expected&lt;T, Error&gt; PathSpace::read&lt;T&gt;(ConcretePath const &amp;path, optional&lt;ReadOptions&gt; const &amp;options={})</li>
</ul>
</li>
</ul>
</li>
<li><b>Extract</b>:<ul>
<li>Same as read but pops the front data instead of just returning a copy.</li>
<li>Syntax:<ul>
<li>std::expected&lt;T, Error&gt; PathSpace::take&lt;T&gt;(ConcretePath, Block, optional&lt;Out&gt; const &amp;options={})</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
Data Storage</h2>
<p>A normal PathSpace will store data by serialising it to a std::vector&lt;std::byte&gt;. That vector can contain data of different types and a separate vector storing std::type_id pointers together with how many objects or that type are in a row will be used to determine what parts of the data vector has what type. std::function objects will be stored in their own vector as well since they can not be serialised. Insert will append serialised data to this vector. Extract will not necessarily erase from the front of the vector since this would be too costly, a pointer to the front element will instead be stored and its position changed forward when a extract is issued. At first the serialisation will be done via the alpaca library but when a compiler supporting the C++26 serialisation functionality it will be rewritten to use that instead.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
Unit Testing</h2>
<p>Unit testing is by using the C++ doctest library.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
Exception Handling</h2>
<p>PathSpaces will not throw exceptions, all errors will be handled via the return type of the operations.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md49"></a>
Views</h2>
<p>PathSpace supports read-only projections and permission gating through <span class="tt"><a class="el" href="_path_view_8hpp.html">src/pathspace/layer/PathView.hpp</a></span> (view with a permission callback) and path aliasing/forwarding via <span class="tt"><a class="el" href="_path_alias_8hpp.html">src/pathspace/layer/PathAlias.hpp</a></span>.</p>
<ul>
<li>PathView: wraps an underlying <span class="tt">PathSpaceBase</span> and enforces a <span class="tt">Permission(Iterator)</span> policy for <span class="tt">in</span>/<span class="tt">out</span>. It can also optionally prepend a root mount prefix when forwarding paths.</li>
<li>PathAlias: a lightweight alias layer that forwards <span class="tt">in</span>/<span class="tt">out</span>/<span class="tt">notify</span> to an upstream space after path rewriting with a configurable <span class="tt">targetPrefix</span>. It uses the iterator tail (<span class="tt">currentToEnd()</span>) so nested mounts resolve correctly. It forwards <span class="tt">notify(...)</span> by mapping the notification path through the current target prefix before forwarding upstream. On retargeting, it emits a notification on its mount prefix to wake waiters and prompt re-resolution.</li>
</ul>
<p>Concurrency and notifications:</p><ul>
<li>Both layers are mount-agnostic; they adopt the parent <span class="tt">PathSpaceContext</span> when inserted so that <span class="tt">notify</span>/wait semantics flow through naturally.</li>
<li><span class="tt">PathAlias</span> forwards <span class="tt">notify(...)</span> by mapping the notification path through its current <span class="tt">targetPrefix</span> and then forwarding upstream, preserving end-to-end wait/notify semantics across the alias boundary.</li>
<li>On retargeting, <span class="tt">PathAlias</span> emits a notification on its mount prefix to wake waiters and prompt re-resolution.</li>
<li>Provider/forwarder patterns:<ul>
<li>When relaying events between providers (e.g., mouse -&gt; mixer), consume with <span class="tt">take</span> (pop) on the upstream queue so each event is forwarded exactly once; use <span class="tt">read</span> (peek) only for passive observation.</li>
<li>Providers with blocking reads should notify waiters upon enqueue (<span class="tt">notify(path)</span> or <span class="tt">notifyAll()</span>).</li>
<li>Use bounded waits and cooperative shutdown: long-running loops should check a stop flag and exit promptly; <span class="tt">PathSpace::shutdown()</span> marks shutting down and wakes waiters.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
Shutdown and Test Hooks</h3>
<ul>
<li><span class="tt">PathSpace::shutdown()</span> is the public API to cooperatively wake waiters and clear paths during teardown.</li>
<li><span class="tt">PathSpace::shutdownPublic()</span> and <span class="tt">PathSpace::notifyAll()</span> are protected test utilities. When tests need to call them, expose via a small test-only subclass, for example:<ul>
<li><span class="tt">struct TestablePathSpace : <a class="el" href="class_s_p_1_1_path_space.html">SP::PathSpace</a> { using <a class="el" href="class_s_p_1_1_path_space.html#ae5b98ebdf274c3e4a23c9133b3bafa66" title="Constructs a PathSpace object.">SP::PathSpace::PathSpace</a>; using <a class="el" href="class_s_p_1_1_path_space.html#ad136782e0b328410fb5d1d18b991c3d9">SP::PathSpace::shutdownPublic</a>; };</span></li>
</ul>
</li>
<li><span class="tt">PathSpace::peekFuture(...)</span> and <span class="tt">PathSpace::setOwnedPool(...)</span> are protected implementation details. Prefer the unified <span class="tt">read&lt;FutureAny&gt;(path)</span> and constructor injection of the executor/pool.</li>
<li>Nested spaces adopt shared context and a mount prefix internally via the protected <span class="tt">adoptContextAndPrefix(...)</span>; external callers should not invoke this directly.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
Operating System</h2>
<p>Device IO is provided by path-agnostic layers that can be mounted anywhere in a parent <span class="tt">PathSpace</span>, with platform backends feeding events into them:</p>
<ul>
<li>Keep <span class="tt">PathIO</span> base and current providers (mouse, keyboard, pointer mixer, stdout, discovery, gamepad).</li>
<li>Event providers deliver typed events via <span class="tt">out()</span>/<span class="tt">take()</span>; blocking semantics are controlled by <span class="tt">Out{doBlock, timeout}</span> and pop-vs-peek by <span class="tt">Out.doPop</span>.</li>
<li>Canonical device namespace (aligned with SceneGraph plan; see <span class="tt"><a class="el" href="_a_i___p_a_t_h_s_8md.html">docs/AI_Paths.md</a></span>):<ul>
<li>Inputs:<ul>
<li><span class="tt">/system/devices/in/pointer/default/events</span></li>
<li><span class="tt">/system/devices/in/text/default/events</span></li>
<li><span class="tt">/system/devices/in/gamepad/default/events</span></li>
</ul>
</li>
<li>Discovery mount (recommended): <span class="tt">/system/devices/discovery</span></li>
<li>Haptics (outputs): <span class="tt">/system/devices/out/gamepad/&lt;id&gt;/rumble</span></li>
</ul>
</li>
<li>Notifications: providers perform targeted <span class="tt">notify(mountPrefix)</span> and <span class="tt">notify(mountPrefix + "/events")</span> on enqueue; use <span class="tt">notifyAll()</span> only for broad updates (e.g., retargeting or clear).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
Backpressure and queue limits</h3>
<ul>
<li>Scope: Event providers (mouse/keyboard/pointer mixer/gamepad) maintain per-mount in-memory deques for pending events.</li>
<li>Complexity: enqueue/dequeue O(1); targeted notify is O(depth) along the path trie; memory is O(N) per queue.</li>
<li>Current behavior: queues are unbounded deques; no drops are performed.</li>
<li>Planned: bound queues to N events (target default ≈1024) with a configurable drop policy:<ul>
<li>Oldest-drop: drop front entries to minimize end-to-end latency on live streams.</li>
<li>Newest-drop: drop incoming events if preserving history is preferred.</li>
</ul>
</li>
<li>Blocking semantics:<ul>
<li>Non-blocking read returns <span class="tt">NoObjectFound</span> when empty.</li>
<li>Blocking read wakes on arrival or timeout; wakeups use targeted <span class="tt">notify(mountPrefix)</span> and <span class="tt">notify(mountPrefix + "/events")</span>.</li>
</ul>
</li>
<li>Mitigations:<ul>
<li>Prefer pop (<span class="tt">take</span>) to keep up; minimize work in the read loop; batch processing where possible.</li>
<li>Use mixers/aggregation to reduce per-device rates; downsample or coalesce deltas when acceptable.</li>
<li>Consider shorter time slices for provider loops once configurable wait-slice is introduced.</li>
</ul>
</li>
<li>Observability: track counters per provider (enqueued, dropped_oldest, dropped_newest); expose via a side path such as <span class="tt">.../stats</span> in a later change.</li>
<li><span class="tt"><a class="el" href="_path_i_o_mouse_8hpp.html">src/pathspace/layer/io/PathIOMouse.hpp</a></span>, <span class="tt"><a class="el" href="_path_i_o_keyboard_8hpp.html">src/pathspace/layer/io/PathIOKeyboard.hpp</a></span>, and <span class="tt"><a class="el" href="_path_i_o_gamepad_8hpp.html">src/pathspace/layer/io/PathIOGamepad.hpp</a></span> expose typed event queues (MouseEvent/KeyboardEvent/GamepadEvent) with blocking <span class="tt">out()</span>/<span class="tt">take()</span> (peek vs pop via <span class="tt">Out.doPop</span>). When mounted with a shared context, <span class="tt">simulateEvent()</span> wakes blocking readers.</li>
<li><span class="tt"><a class="el" href="_path_i_o_device_discovery_8hpp.html">src/pathspace/layer/io/PathIODeviceDiscovery.hpp</a></span> provides a simulation-backed discovery surface (classes, device IDs, per-device <span class="tt">meta</span> and <span class="tt">capabilities</span>), using iterator tail mapping for correct nested mounts; recommended mount prefix: <span class="tt">/system/devices/discovery</span>.</li>
</ul>
<p>Platform backends (unified, via compile-time macros):</p><ul>
<li><span class="tt"><a class="el" href="_path_i_o_mouse_8hpp.html">src/pathspace/layer/io/PathIOMouse.hpp</a></span> and <span class="tt"><a class="el" href="_path_i_o_keyboard_8hpp.html">src/pathspace/layer/io/PathIOKeyboard.hpp</a></span> expose start()/stop() hooks and select OS paths internally (e.g., <span class="tt">PATHIO_BACKEND_MACOS</span>) to feed events via <span class="tt">simulateEvent(...)</span>.</li>
<li>On macOS, enable with <span class="tt">-DENABLE_PATHIO_MACOS=ON</span> to define <span class="tt">PATHIO_BACKEND_MACOS</span> (CI uses simulation/no-op by default).</li>
<li>Deprecated: <span class="tt"><a class="el" href="_path_i_o__macos_8hpp.html">src/pathspace/layer/macos/PathIO_macos.hpp</a></span> is a compatibility shim only and no longer defines <span class="tt">PathIOMouseMacOS</span> or <span class="tt">PathIOKeyboardMacOS</span>. Include the unified headers instead.</li>
</ul>
<p>Note: First-class links (symlinks) are planned; in the interim, <span class="tt">PathAlias</span> offers robust forwarding/retargeting semantics without changing core trie invariants. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
