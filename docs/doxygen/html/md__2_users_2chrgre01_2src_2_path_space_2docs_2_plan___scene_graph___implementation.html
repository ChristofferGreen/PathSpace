<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: Handoff Notice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_plan___scene_graph___implementation.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Handoff Notice </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md194"></a></p>
<blockquote class="doxtable">
<p><b>Handoff note (October 21, 2025 @ shutdown):</b> Hit-test coverage now spans ordering, clip-aware picking, focus routing, the auto-render wait/notify path (<span class="tt">tests/ui/test_SceneHitTest.cpp</span> asserts ≤200 ms wake latency), DrawableBucket-backed multi-hit stacks (<span class="tt">HitTestResult::hits</span> with <span class="tt">HitTestRequest::max_results</span>), and widget focus-navigation helpers with auto-render scheduling. Keyboard/gamepad focus loops and widget golden snapshots now live in <span class="tt">tests/ui/test_Builders.cpp</span>, and presenter diagnostics continue to mirror into <span class="tt">windows/&lt;win&gt;/diagnostics/metrics/live/views/&lt;view&gt;/present</span>. Next pass should expand HTML tooling (HSAT inspectors) and finish the remaining HTML adapter notes. </p>
</blockquote>
<h1 class="doxsection"><a class="anchor" id="autotoc_md195"></a>
Scene Graph Implementation Plan</h1>
<blockquote class="doxtable">
<p><b>Context update (October 15, 2025):</b> Implementation phases now assume the assistant context introduced for this cycle; convert prior context cues to the updated vocabulary during execution. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md196"></a>
Context and Objectives</h2>
<ul>
<li>Groundwork for implementing the renderer stack described in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> and the broader architecture contract in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span>.</li>
<li>Deliver an incremental path from today's codebase to the MVP (software renderer, CAMetalLayer-based presenters, surfaces, snapshot builder), while keeping room for GPU rendering backends (Metal/Vulkan) and HTML adapters outlined in the master plan.</li>
<li>Maintain app-root atomic semantics, immutable snapshot guarantees, and observability expectations throughout the rollout.</li>
</ul>
<p>Success looks like:</p><ul>
<li>A new <span class="tt">src/pathspace/ui/</span> subsystem shipping the MVP feature set behind build flags.</li>
<li>Repeatable end-to-end tests (including 15× loop runs) covering snapshot publish/adopt, render, and present flows.</li>
<li>Documentation, metrics, and diagnostics that let maintainers debug renderer issues without spelunking through the code.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md197"></a>
Status Snapshot (October 21, 2025)</h2>
<ul>
<li>Material/shader bindings now flow through the shared descriptor cache, and Metal draws mirror the software renderer’s telemetry (<span class="tt">PathRenderer2DMetal::bind_material</span>, GPU blending UITest in place).</li>
<li>Metal presenters remain enabled by default; the 15× loop harness (20 s timeout) is green with both software and Metal suites.</li>
<li>Residency metrics under <span class="tt">diagnostics/metrics/residency/*</span> now expose raw byte counts alongside dashboard ratios/alerts; extend telemetry where gaps remain.</li>
<li>Widget bindings publish dirty hints and ops inbox events (<span class="tt">widgets/&lt;id&gt;/ops/inbox/queue</span>) so interaction reducers can react without full-scene republishes.</li>
<li>Widgets reducers drain op queues into <span class="tt">widgets/&lt;id&gt;/ops/actions/inbox/queue</span>; examples/tests confirm button/list actions round-trip through the helpers.</li>
<li>Widget gallery, HTML tooling, and diagnostics backlog items are tracked in <span class="tt">docs/AI_Todo.task</span>; no open P0 work after the binding milestone.</li>
<li>✅ (October 21, 2025) Scene hit tests now gather z-ordered multi-hit stacks, expose <span class="tt">HitTestResult::hits</span>, and honour <span class="tt">HitTestRequest::max_results</span> for drill-down; doctests cover default ordering, clipping, and bounded stacks.</li>
<li>✅ (October 21, 2025) Focus navigation helpers landed (<span class="tt">Widgets::Focus::*</span>), standardising focus rings across widgets, scheduling auto-render events on navigation, and tagging <span class="tt">widgets/&lt;id&gt;/meta/kind</span> so downstream tooling can detect widget types.</li>
<li>✅ (October 21, 2025) Widgets gallery now supports keyboard focus cycling, arrow-key slider/list control, and logs reducer-emitted actions each frame for diagnostics.</li>
<li>✅ (October 21, 2025) Window diagnostics sinks mirror presenter metrics under <span class="tt">windows/&lt;win&gt;/diagnostics/metrics/live/views/&lt;view&gt;/present</span>, keeping central telemetry aligned with per-target <span class="tt">output/v1/common/*</span> updates.</li>
<li>✅ (October 20, 2025) Residency dashboard wiring publishes CPU/GPU soft &amp; hard budget ratios plus status flags under <span class="tt">diagnostics/metrics/residency</span>, enabling external alerts without bespoke parsers.</li>
<li>✅ (October 21, 2025) <span class="tt">examples/widgets_example.cpp</span> opens the widgets gallery window, renders button/toggle/slider/list widgets with software text overlays, streams present/FPS telemetry to stdout, and republishes the gallery snapshot when LocalWindow mouse events update widget state.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md198"></a>
Workstream Overview</h2>
<ul>
<li><b>Typed wiring helpers</b> — <span class="tt">Builders.hpp</span> plus supporting utilities for app-relative path validation, target naming, and atomic parameter writes.</li>
<li><b>Scene authoring &amp; snapshot builder</b> — authoring tree schema, dirty tracking, layout, <span class="tt">DrawableBucket</span> emission, and revision lifecycle/GC.</li>
<li><b>Renderer core (software first)</b> — target settings adoption, traversal of snapshots, draw command execution, color pipeline defaults, and concurrency controls.</li>
<li><b>Surfaces &amp; presenters</b> — target configuration, render execution coordination, CAMetalLayer-backed window presentation, progressive software mode, and UI-thread integrations.</li>
<li><b>Input &amp; hit testing</b> — DrawableBucket-driven hit paths, focus routing, and notification hooks for scene edits and event delivery.</li>
<li><b>Diagnostics &amp; metrics</b> — unified <span class="tt">PathSpaceError</span> usage, per-target metrics, progressive copy counters, and troubleshooting hooks.</li>
<li><b>Resource residency &amp; tooling</b> — enforce per-resource policy, adopt fingerprints across snapshots/renderers, refresh compile commands, and extend automation/test harnesses.</li>
<li><b>Testing discipline</b> — when you discover a coverage gap, either land the test or capture the follow-up in this plan / <span class="tt">docs/AI_Todo.task</span> so the gap is visible for the next cycle.</li>
</ul>
<p>Each workstream lands independently but respects shared contracts (paths, atomic writes, revision pinning).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md199"></a>
Helper API Contract</h3>
<ul>
<li>Location: <span class="tt"><a class="el" href="_helpers_8hpp.html">src/pathspace/ui/Helpers.hpp</a></span> with namespaces <span class="tt">Scene</span>, <span class="tt">Renderer</span>, <span class="tt">Surface</span>, <span class="tt">Window</span>, and <span class="tt">Diagnostics</span>.</li>
<li>All helpers accept a <span class="tt">PathSpace&amp;</span> plus typed <span class="tt">ConcretePath</span> aliases (<span class="tt">ScenePath</span>, <span class="tt">RendererPath</span>, etc.); no raw string paths cross the boundary.</li>
<li>Responsibilities:<ul>
<li>Enforce app-root containment and canonical naming (e.g., <span class="tt">renderers/&lt;id&gt;/targets/...</span>).</li>
<li>Serialize payloads into <span class="tt">NodeData</span> using existing Alpaca/typed codecs; no helper owns synchronization beyond atomic inserts/takes.</li>
<li>Return <span class="tt"><a class="el" href="namespace_s_p.html#a0fcdfa8774c1a104175caaeea2f0b7aa">SP::Expected</a>&lt;T&gt;</span> for error propagation aligned with core PathSpace errors.</li>
</ul>
</li>
<li>Usage: SceneGraph code consumes these helpers exclusively instead of embedding path literals; tests mock them to isolate higher layers.</li>
<li>Future additions (Metal/HTML adapters) extend these namespaces rather than reaching into core PathSpace directly.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md200"></a>
Immediate Next Steps</h2>
<ul>
<li>✅ (October 17, 2025) <span class="tt">PathRenderer2D</span> executes Rect, RoundedRect, Image, TextGlyphs, Path, and Mesh commands in linear light, respecting opaque/alpha ordering and updating drawable/unsupported metrics.</li>
<li>✅ (October 16, 2025) Replaced the macOS window presenter’s CoreGraphics blit with the CAMetalLayer-backed zero-copy path, validated fullscreen resize/perf behaviour manually, and updated the example/docs.<ul>
<li>✅ (October 17, 2025) PathSurfaceSoftware and PathWindowView now share an IOSurface-backed framebuffer so the presenter can bind the surface without memcpy; the zero-copy path is the new default on macOS.</li>
</ul>
</li>
<li>✅ (October 17, 2025) PathRenderer2D now limits damage to tiles touched by drawables whose fingerprints/bounds changed, so unchanged revisions (including id renames) emit zero progressive updates; fullscreen repaints are reserved for resize/clear-color changes (see “Incremental software renderer” below for remaining diagnostics and hint work).</li>
<li>✅ (October 17, 2025) Progressive repaint flicker in <span class="tt">./build/paint_example</span> is resolved. Damage tracing (<span class="tt">PATHSPACE_TRACE_DAMAGE=1</span>) now shows the buffered framebuffer retaining previous content, and interactive runs match the automated regression (<span class="tt">Window::Present progressive updates preserve prior content</span>). Keep the loop harness green and capture traces again if the behaviour regresses.</li>
<li>✅ (October 17, 2025) End-to-end <span class="tt">Window::Present</span> coverage now codifies progressive seqlock behaviour: tests drive a presenter through the builders API, assert the <span class="tt">progressiveSkipOddSeq</span> metrics, and verify deadline bookkeeping (<span class="tt">waitBudgetMs</span>/staleness) using the new before-present hook in <span class="tt">Builders::Window::TestHooks</span>.</li>
<li>✅ (October 17, 2025) Added multi-target <span class="tt">Window::Present</span> scenarios to ensure renderer caches stay per-target: two surfaces backed by the same renderer now exercise independent frame indices, stored framebuffers, and progressive metrics through the builders API.</li>
<li>✅ (October 17, 2025) Automated the AlwaysFresh/deadline regression by reusing the before-present hook to force buffered-frame drops, asserting the skip path (<span class="tt">lastPresentSkipped</span>, <span class="tt">presentedAge*</span>, <span class="tt">waitBudgetMs</span>) and guarding against unintended auto-render enqueues.</li>
<li>✅ (October 17, 2025) Dirty hint buckets snap to progressive tile boundaries so <span class="tt">PATHSPACE_TRACE_DAMAGE=1</span> logs stay readable at 4K; doctests cover the presenter metrics emitted when hints restrict the damage region.</li>
<li>✅ (October 18, 2025) Achieved FPS parity between small and 4K windows and hardened diagnostics to catch regressions; keep monitoring traces but no longer treat as an open blocker.</li>
<li>✅ (October 17, 2025) Progressive tile fan-out now distributes work across all available CPU cores with a fixed 64 px tile size so incremental strokes remain ~140 FPS, and metrics continue to surface <span class="tt">progressiveTilesUpdated</span> / <span class="tt">progressiveBytesCopied</span>.<ul>
<li>✅ (October 17, 2025) Instrumented the fine-grained benchmark suite with per-phase timings (damage diff, encode, progressive copy, IOSurface publish, presenter present) to pinpoint 4 K full-clear hotspots; benchmark output now reports these averages.</li>
<li>✅ (October 18, 2025) Hardened <span class="tt">paint_example</span>: stroke segments now batch their dirty hints, idle frames no longer submit full-surface publishes, and surface resizing reuses the existing IOSurface allocation so long sessions stay within range-group limits.</li>
<li>✅ (October 18, 2025) Presenter now skips IOSurface-to-CPU copies unless <span class="tt">capture_framebuffer</span> is set, eliminating the 22 MB memcpy per frame while retaining a debug/toggle for diagnostics.</li>
<li>✅ (October 18, 2025) CAMetalLayer presenting now reuses a bounded IOSurface pool, preventing range-group exhaustion during long-running sessions.</li>
<li>💤 (Optional) Add stroke-compositing to <span class="tt">paint_example</span> so successive brush strokes bake into a persistent texture (or coalesced drawable) rather than growing the snapshot unbounded; keeps long-running demos at steady FPS without exhausting IOSurface range groups.</li>
<li>✅ (October 18, 2025) <span class="tt">Builders::SubmitDirtyRects</span> now normalizes and coalesces hints automatically, snapping to the surface tile grid and clamping to bounds so apps can pass raw rectangles without bespoke math.</li>
<li>✅ (October 18, 2025) <span class="tt">paint_example</span> now forwards raw brush rectangles directly to the helper; manual tile snapping and hint merging were removed.</li>
</ul>
</li>
<li>✅ (October 20, 2025) <span class="tt">paint_example</span> accepts <span class="tt">--metal</span> to opt into the Metal2D backend, auto-enables uploads when available, and keeps software as the default for CI/headless runs.</li>
<li>✅ (October 21, 2025) Added the App::Bootstrap end-to-end regression (<span class="tt">tests/ui/test_AppBootstrap.cpp</span>) that publishes a scene snapshot, renders via <span class="tt">Surface::RenderOnce</span>, presents with <span class="tt">Window::Present</span>, and asserts both target and window diagnostics; exercised under the 15× loop (20 s timeout).</li>
<li>✅ (October 21, 2025) Presenter wiring coverage now exercises multi-window/multi-surface scenarios (PathRenderer2D UITest); remaining follow-up: keep rerunning the loop harness after each integration.</li>
<li>✅ (October 21, 2025) Window diagnostics now surface the progressive-mode metrics (tile counters, copy timings, encode fan-out) mirrored from <span class="tt">output/v1/common</span> when <span class="tt">PATHSPACE_UI_DAMAGE_METRICS=1</span>; the PathRenderer2D UITest verifies <span class="tt">windows/&lt;win&gt;/diagnostics/metrics/live/views/&lt;view&gt;/present</span> receives the tile dirty/total/skipped counters alongside progressive copy telemetry.</li>
<li>✅ (October 21, 2025) Phase 5 hit-test coverage now exercises hit ordering, clip-aware picking, focus routing, and auto-render wait/notify latency (<span class="tt">test_SceneHitTest.cpp</span>); continue tightening DrawableBucket-backed picking and related scheduling hooks as new interaction types land.</li>
<li>Line up Phase 6 diagnostics/tooling work: extend error/metrics coverage, normalize <span class="tt">PathSpaceError</span> reporting, expand scripts for UI log capture, and draft the debugging playbook updates before the next hardening pass.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md201"></a>
Incremental software renderer (new priority, October 17, 2025)</h3>
<ul>
<li>Scope: keep the zero-copy path but eliminate full-surface repaints when only a small region changes.</li>
<li>Current status:<ul>
<li>✅ (October 17, 2025) PathRenderer2D now caches per-target drawable fingerprints/bounds and diffs revisions so unchanged drawables (including id renames) leave the damage region empty; idle frames report zero progressive tile updates in tests.</li>
<li>✅ (October 17, 2025) SceneSnapshotBuilder fingerprints are derived from transforms/bounds/commands (drawable ids no longer influence the hash), so renaming a drawable without changing its content reuses the cached damage state.</li>
<li>✅ (October 17, 2025) <span class="tt">paint_example</span> skips redundant publishes on resize-only frames and forwards brush dirty rectangles via the new renderer hint path, so dragging a 2560 px canvas keeps &gt;55 FPS except while actively laying down fresh strokes.</li>
</ul>
</li>
<li>Immediate next steps:<ul>
<li>✅ (October 19, 2025) Locked in the progressive tiling strategy: default tile size stays 64×64 px (≈510 tiles at 1080p, ≈920 at 1440p, ≈2 040 at 4K), and new per-frame metrics (<span class="tt">progressiveTileSize</span>, <span class="tt">progressiveWorkersUsed</span>, <span class="tt">progressiveJobs</span>, <span class="tt">encodeWorkersUsed</span>, <span class="tt">encodeJobs</span>) now track how much work hits the worker pool so multi-core utilisation remains visible in logs/dashboards.</li>
<li>✅ (October 19, 2025) Surface diagnostics around skipped tiles now land in the renderer metrics: run <span class="tt">./build/benchmarks/path_renderer2d_benchmark --metrics [--canvas=WIDTHxHEIGHT]</span> to enable <span class="tt">PATHSPACE_UI_DAMAGE_METRICS</span> and print coverage, dirty/skip ratios, and fingerprint deltas without attaching a debugger.</li>
<li>✅ (October 19, 2025) Captured updated FPS deltas after the encode parallelism landed. <span class="tt">path_renderer2d_benchmark</span> now accepts <span class="tt">--canvas=WIDTHxHEIGHT</span>, and on the reference Mac Studio the results are:<ul>
<li>3840×2160: full repaint avg 41 ms (≈24 FPS) vs incremental strokes avg 7.0 ms (≈142 FPS), encode ≈26 ms of the full repaint and ≈0.3 ms incremental.</li>
<li>1280×720: full repaint avg 4.9 ms (≈203 FPS) vs incremental strokes avg 1.1 ms (≈897 FPS), encode ≈3.1 ms of the full repaint and ≈0.3 ms incremental.</li>
<li>Progressive bytes copied per incremental stroke stay ≈0.07 MB thanks to the tile hint path; full repaints move ≈33 MB at 4K and ≈3.7 MB at 720p.</li>
</ul>
</li>
<li>✅ (October 19, 2025) Parallelized the encode phase: damage regions expand into per-tile encode jobs that run across the shared worker queue, cutting full-surface encode time and matching the progressive tiling model on multi-core hosts.</li>
</ul>
</li>
<li>Runtime targets:<ul>
<li>Incremental updates should be the steady state: typical UI strokes touch only a handful of tiles, keeping frame cost well under the 16 ms (~60 Hz) budget.</li>
<li>Full-surface repaints remain first-class. Camera moves or scene-wide changes explicitly flip the damage region to <span class="tt">set_full()</span>, then PathRenderer2D fan-outs tiles across all CPU cores (tile-per-thread queue) so repainting a 4K surface still clears ≤16 ms once the inner loops are vectorized.</li>
<li>The software path owns these full clears; GPU assists stay optional (e.g. secondary effects), not the default “draw everything every frame,” so the hybrid design preserves the progressive/tiled CPU pipeline.</li>
</ul>
</li>
<li>Validation:<ul>
<li>✅ (October 19, 2025) Added renderer doctest coverage for incremental stroke, erase, clear-color, and dirty rect hint scenarios (see <span class="tt">tests/ui/test_PathRenderer2D.cpp</span>), with explicit assertions on damage coverage, fingerprint deltas, and progressive tile counts.</li>
<li>Capture comparative FPS traces (small-vs-fullscreen) to confirm the fullscreen slowdown disappears.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md202"></a>
Phase Plan</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md203"></a>
Phase 0 — Foundations (1 sprint)</h3>
<ul>
<li>Audit existing <span class="tt">PathSpace</span> helpers for app-relative enforcement; add shared utilities if missing.</li>
<li>Introduce feature flags/CMake options (<span class="tt">PATHSPACE_ENABLE_UI</span>, <span class="tt">PATHSPACE_UI_SOFTWARE</span>, <span class="tt">PATHSPACE_UI_METAL</span>, <span class="tt">PATHSPACE_ENABLE_APP</span>, <span class="tt">PATHSPACE_ENABLE_EXTRA</span>) without functionality to keep builds green.</li>
<li>Update Doxygen/docs stubs to reserve namespaces (<span class="tt">pathspace/ui/*</span>) and ensure compile_commands integration works.</li>
<li>✅ (October 11, 2025) <span class="tt"><a class="el" href="namespace_s_p_1_1_app.html">SP::App</a></span> helpers landed in <span class="tt">src/pathspace/app/AppPaths.{hpp,cpp}</span> with root normalization, app-relative resolution, and target base validation for reuse across UI and tooling layers.</li>
<li>✅ (October 11, 2025) Top-level CMake now exposes <span class="tt">PATHSPACE_ENABLE_UI</span> (default OFF) plus <span class="tt">PATHSPACE_UI_SOFTWARE</span> / <span class="tt">PATHSPACE_UI_METAL</span>, <span class="tt">PATHSPACE_ENABLE_APP</span>, and <span class="tt">PATHSPACE_ENABLE_EXTRA</span> flags, and the library/tests gate feature-specific sources on these toggles.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md204"></a>
Phase 1 — Typed Helpers &amp; Path Semantics (1 sprint)</h3>
<p>Completed:</p><ul>
<li>✅ (October 14, 2025) Added doctest coverage in <span class="tt">tests/ui/test_Builders.cpp</span> for idempotent scene creation, cross-app rejection, and atomic <span class="tt">Renderer::UpdateSettings</span> behaviour (path containment + queue draining).</li>
<li>✅ (October 14, 2025) Validated Builders via <span class="tt">./scripts/compile.sh --loop=15 --per-test-timeout 20</span> (15 iterations, 20 s per-test timeout).</li>
<li>✅ (October 11, 2025) Initial UI helper implementations (<span class="tt"><a class="el" href="_helpers_8cpp.html">src/pathspace/ui/Helpers.cpp</a></span>) enforce app-root containment for scene/renderer/surface/window calls with accompanying doctests in <span class="tt">tests/ui/test_SceneHelpers.cpp</span>; remaining work will flesh out Builders.hpp and atomic settings writes.</li>
<li>✅ (October 14, 2025) Documented Builders usage patterns and invariants in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> (idempotent creates, atomic settings, app-root enforcement); no new canonical paths required for <span class="tt"><a class="el" href="_a_i___p_a_t_h_s_8md.html">AI_Paths.md</a></span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md205"></a>
Phase 2 — Scene Schema &amp; Snapshot Builder (2 sprints)</h3>
<p>Completed:</p><ul>
<li>✅ (October 14, 2025) <span class="tt">SceneSnapshotBuilder</span> now emits full SoA drawable data (transforms, bounds, material/pipeline metadata, command offsets/counts, command stream, opaque/alpha/per-layer indices) and documents the layout in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> / <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span>.</li>
<li>✅ (October 14, 2025) Added doctests in <span class="tt">tests/ui/test_SceneSnapshotBuilder.cpp</span> covering round-trip decoding plus retention under burst publishes.</li>
<li>✅ (October 15, 2025) Added long-running publish/prune stress coverage with metrics validation and GC metric emission (retained/evicted/last_revision/total_fingerprint_count) in <span class="tt">tests/ui/test_SceneSnapshotBuilder.cpp</span>.</li>
<li>✅ (October 15, 2025) Snapshot metadata now records resource fingerprints per revision; GC metrics aggregate total fingerprint counts for residency planning.</li>
<li>✅ (October 15, 2025) Documented the finalized binary artifact split (<span class="tt">drawables.bin</span>, <span class="tt">transforms.bin</span>, <span class="tt">bounds.bin</span>, <span class="tt">state.bin</span>, <span class="tt">cmd-buffer.bin</span>, index files) and retired the Alpaca fallback in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span> / <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md206"></a>
Phase 3 — Software Renderer Core (2 sprints)</h3>
<p>Completed:</p><ul>
<li>✅ (October 15, 2025) Builders <span class="tt">Surface::RenderOnce</span> / <span class="tt">Window::Present</span> now call <span class="tt">PathRenderer2D</span> synchronously via <span class="tt">Renderer::TriggerRender</span>, return ready <span class="tt">FutureAny</span> handles, and update target metrics; doctests cover the integration path.</li>
<li>✅ (October 16, 2025) <span class="tt">PathRenderer2D</span> now executes recorded Rect and RoundedRect commands in linear light, keeps the opaque/alpha partitioning path alive, and publishes drawable/cull/command metrics with doctest coverage for success/error flows.</li>
<li>✅ (October 16, 2025) Added a deterministic golden framebuffer harness (with <span class="tt">PATHSPACE_UPDATE_GOLDENS</span>) plus render/present loop regressions that exercise <span class="tt">Surface::RenderOnce</span> and <span class="tt">Window::Present</span> under repeated runs; comparisons are tolerance-aware to track subtle output drift.</li>
<li>✅ (October 16, 2025) Instrumented the renderer to report sort-key violations, approximate overdraw coverage, and progressive-copy counters under <span class="tt">output/v1/common/*</span> for tooling/CI.</li>
</ul>
<p>Remaining:</p><ul>
<li>Re-run the looped test suite and inspect goldens post implementation.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md207"></a>
Phase 4 — Surfaces, Presenters, and Progressive Mode (2 sprints)</h3>
<p>Completed:</p><ul>
<li>✅ (October 15, 2025) <span class="tt">PathSurfaceSoftware</span> progressive buffer + double-buffer landed with dedicated UI tests.</li>
<li>✅ (October 15, 2025) <span class="tt">PathWindowView</span> now presents buffered/progressive frames and writes presenter metrics via <span class="tt">Builders::Diagnostics::WritePresentMetrics</span>; UI tests split into <span class="tt">PathSpaceUITests</span> for isolation.</li>
<li>✅ (October 16, 2025) End-to-end scene → render → present doctests cover policy permutations, progressive copy assertions, and diagnostics outputs through <span class="tt">Builders::Window::Present</span>.</li>
<li>✅ (October 16, 2025) Presenter integration routes through <span class="tt">Window::Present</span>, emitting progressive-mode metrics, wait-budget data, and auto-render scheduling hooks that enqueue <span class="tt">AutoRenderRequestEvent</span> when frames remain stale.</li>
<li>✅ (October 16, 2025) Seqlock and deadline behaviour codified via <span class="tt">PathWindowView</span> and builder tests, ensuring wait-budget clamps and progressive copy skips are observable.</li>
<li>✅ (October 16, 2025) Compile/test loop harness revalidated after presenter integration (15× repeat, 20 s timeout) confirming stability.</li>
<li>✅ (October 16, 2025) Software presenter now publishes captured framebuffers under <span class="tt">output/v1/software/framebuffer</span>, enabling downstream inspection of rendered bytes alongside metadata.</li>
<li>✅ (October 21, 2025) <span class="tt">Window::Present</span> mirrors presenter stats into <span class="tt">windows/&lt;win&gt;/diagnostics/metrics/live/views/&lt;view&gt;/present</span> via <span class="tt">Diagnostics::WriteWindowPresentMetrics</span>, keeping central dashboards aligned with per-target telemetry.</li>
<li>✅ (October 22, 2025) Default software presents now skip serializing <span class="tt">SoftwareFramebuffer</span>; <span class="tt">Builders::Window::Present</span> only writes <span class="tt">output/v1/software/framebuffer</span> when <span class="tt">capture_framebuffer=true</span> and drains prior captures otherwise, avoiding the extra copy while leaving on-demand captures intact for diagnostics.</li>
<li>✅ (October 17, 2025) Added a minimal paint-style demo (<span class="tt">examples/paint_example.cpp</span>) that wires the scene→render→present stack together, supports dynamic canvas resizing, and interpolates mouse strokes so contributors can exercise the full software path end-to-end.</li>
<li>✅ (October 16, 2025) macOS window presentation now uses a CAMetalLayer-backed Metal swapchain (IOSurface copies + present) instead of CoreGraphics blits; fullscreen perf is no longer CPU bound.</li>
<li>✅ (October 21, 2025) Shipped <span class="tt">examples/pixel_noise_example.cpp</span>, a per-pixel noise perf harness that uses the software renderer plus a before-present hook to generate full-surface churn each frame; it now runs windowed by default (uncapped compute with presents throttled via <span class="tt">--present-refresh=&lt;hz&gt;</span>), and <span class="tt">--headless</span> keeps the UI out of the loop when you want raw throughput only (use <span class="tt">--report-metrics</span>/<span class="tt">--report-extended</span> to print diagnostics).</li>
<li>✅ (October 22, 2025) Pixel noise harness defaults to the fast path (framebuffer capture off, metrics muted, window present rate 60 Hz) with CLI escapes for diagnostics/capture (<span class="tt">--headless</span>, <span class="tt">--capture-framebuffer</span>, <span class="tt">--report-metrics</span>, <span class="tt">--report-extended</span>, <span class="tt">--present-call-metric</span>, <span class="tt">--present-refresh=&lt;hz&gt;</span>).</li>
<li>✅ (October 22, 2025) Parallelized the pixel noise generator across CPU threads so IOSurface writes scale with hardware concurrency; deterministic seeding keeps runs reproducible while eliminating the prior single-threaded hotspot.</li>
<li>✅ (October 22, 2025) Pixel noise window resizing now reconfigures the surface size live, keeping noise samples at native resolution instead of stretching when the window is maximized.</li>
<li>✅ (October 22, 2025) Pixel noise perf harness now runs in the 15× loop via the new <span class="tt">PixelNoisePerfHarness</span> CTest, executing <span class="tt">pixel_noise_example</span> headless with deterministic seeding and enforcing realtime budgets (≥50 FPS, ≤20 ms avg present/render). The example gained <span class="tt">--min-fps</span>, <span class="tt">--budget-present-ms</span>, and <span class="tt">--budget-render-ms</span> options plus a structured summary line so regressions surface immediately when the loop drops below target.</li>
</ul>
<p>Completed:</p><ul>
<li>✅ (October 18, 2025) Added fullscreen CAMetalLayer regression coverage in <span class="tt">PathSpaceUITests</span> and defaulted the presenter to zero-copy unless <span class="tt">capture_framebuffer</span> is explicitly enabled; perf regressions now fail under the UI harness.</li>
<li>(Done) IOSurface-backed software framebuffer landed with PathSurfaceSoftware/PathWindowView zero-copy integration; future work should iterate on diagnostics rather than copy elimination.</li>
</ul>
<p>Next:</p><ul>
<li>🔜 (Planned) Pixel noise harness follow-ups: integrate the new example with automated baselines and diagnostics so perf regressions stay guarded.<ul>
<li>✅ (October 22, 2025) Persist baseline metrics (frame time, residency, tile stats) from the harness under <span class="tt">docs/perf/</span> via <span class="tt">--write-baseline</span>; JSON captures live stats for regression comparisons.</li>
<li>✅ (October 22, 2025) Landed <span class="tt">scripts/capture_pixel_noise_baseline.sh</span> to produce/update versioned baselines (default output <span class="tt">docs/perf/pixel_noise_baseline.json</span>).</li>
<li>✅ (October 22, 2025) Spun a Metal-enabled variant via <span class="tt">--backend=metal</span>, captured <span class="tt">docs/perf/pixel_noise_metal_baseline.json</span>, and added the <span class="tt">PixelNoisePerfHarnessMetal</span> CTest (PATHSPACE_ENABLE_METAL_UPLOADS-gated) so the loop covers both Software2D and Metal2D backends with the same perf budgets.</li>
<li>✅ (October 22, 2025) Mirrored the harness expectations in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>, covering the new Metal2D backend switch, paired baselines, and the extended CTest coverage.</li>
<li>✅ (October 22, 2025) Documented baseline workflow in <span class="tt"><a class="el" href="_a_i___debugging___playbook_8md.html">docs/AI_Debugging_Playbook.md</a></span> (Tooling §5.1) covering capture script usage and JSON interpretation.</li>
<li>🔜 Capture a representative frame grab (e.g., <span class="tt">images/perf/pixel_noise.png</span>) so regressions include a visual reference alongside metrics.</li>
<li>✅ (October 22, 2025) Added <span class="tt">scripts/check_pixel_noise_baseline.py</span> and routed <span class="tt">PixelNoisePerfHarness</span> through it so looped runs fail whenever runtime averages exceed the baseline budgets.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md208"></a>
Phase 5 — Input, Hit Testing, and Notifications (1 sprint)</h3>
<ul>
<li>✅ (October 16, 2025) Added doctest scenarios for hit ordering, clip-aware picking, focus routing, and auto-render event scheduling via <span class="tt">Scene::HitTest</span>; notifications enqueue <span class="tt">AutoRenderRequestEvent</span> under <span class="tt">events/renderRequested/queue</span>.</li>
<li>✅ (October 16, 2025) <span class="tt">Scene::HitTest</span> now emits scene/local coordinates and per-path focus metadata so event routing can derive local offsets without re-reading scene state; doctests cover the new fields.</li>
<li>✅ (October 16, 2025) <span class="tt">Scene::MarkDirty</span> / <span class="tt">Scene::TakeDirtyEvent</span> surface dirty markers via <span class="tt">diagnostics/dirty/state</span> and a queue, and tests confirm renderers can wait on the queue without polling.</li>
<li>✅ (October 18, 2025) Exercised the blocking dirty-event wait/notify loop under the mandated 15× harness; the <span class="tt">Scene dirty event wait-notify latency stays within budget</span> doctest asserts &lt;200 ms wake latency, preserves sequence ordering, and architecture docs now capture the latency/ordering guarantee plus the Metal→software fallback rule when uploads are disabled.</li>
<li>✅ (October 21, 2025) DrawableBucket hit tests collect z-ordered stacks via `HitTestResult::hits` and respect `HitTestRequest::max_results`, enabling drill-down while keeping top-level fields backwards-compatible; doctests cover overlap, clipping, and bounded queries.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md209"></a>
Phase 6 — Diagnostics, Tooling, and Hardening (1 sprint)</h3>
<ul>
<li>✅ (October 18, 2025) Extended diagnostics coverage with unit tests that write/read present metrics (`Diagnostics::WritePresentMetrics`/`ReadTargetMetrics`) and verify error clearing; tooling now has regression coverage for metric persistence.</li>
<li>✅ (October 18, 2025) Normalized presenter/renderer error reporting around `PathSpaceError`, wiring `diagnostics/errors/live` and exposing codes/revisions via `Diagnostics::ReadTargetMetrics`.</li>
<li>✅ (October 18, 2025) Expanded `scripts/compile.sh`/CTest to cover UI components and capture failure logs via `scripts/run-test-with-logs.sh`, ensuring loop runs retain artifacts on failure.</li>
<li>✅ (October 18, 2025) Published `docs/AI_Debugging_Playbook.md` with the end-to-end diagnostics workflow and re-validated the 15× loop harness (`./scripts/compile.sh --test --loop=15 --per-test-timeout=20`).</li>
<li>✅ (October 20, 2025) Added residency dashboard outputs: `cpuSoftBudgetRatio`, `cpuHardBudgetRatio`, `gpuSoftBudgetRatio`, `gpuHardBudgetRatio`, per-budget exceed flags, and `overallStatus` now live under `diagnostics/metrics/residency/` for every target, allowing dashboards/alerts to trigger without bespoke queries.</li>
<li>✅ (October 20, 2025) Widget interaction bindings land: `Widgets::Bindings::Dispatch{Button,Toggle,Slider}` diff widget state, submit targeted dirty rect hints, enqueue ops (`WidgetOp` values) under `widgets/&lt;id&gt;/ops/inbox/queue<span class="tt">, and auto-schedule renders when configured.</span></li>
<li><span class="tt">✅ (October 22, 2025) Audited UI/renderer translation units ≥1 000 lines, documented candidates via </span>scripts/lines_of_code.sh<span class="tt">, and refactored </span>ui/Builders.cpp<span class="tt"> into focused translation units to move toward one-class-per-file modules while keeping the looped test suite green.</span></li>
<li><span class="tt">✅ (October 23, 2025) Extracted widget helper internals into </span>WidgetDrawablesDetail.inl<span class="tt"> / </span>WidgetMetadataDetail.inl<span class="tt"> and split the widget runtime across </span><a class="el" href="_widget_builders_core_8cpp.html">WidgetBuildersCore.cpp</a><span class="tt">, </span><a class="el" href="_widget_bindings_8cpp.html">WidgetBindings.cpp</a><span class="tt">, </span><a class="el" href="_widget_focus_8cpp.html">WidgetFocus.cpp</a><span class="tt">, and </span><a class="el" href="_widget_reducers_8cpp.html">WidgetReducers.cpp</a><span class="tt">, keeping each unit &lt;1 000 lines while preserving shared helpers via inline includes.</span></li>
<li><span class="tt">Enforce include hygiene during the split (IWYU or equivalent pass) so the expanded module graph keeps compile times manageable.</span></li>
<li><span class="tt">Add binary/size guardrails (e.g., </span>scripts/compile.sh &ndash;size-report<span class="tt">) to watch for example/demo growth after the refactor.</span></li>
<li><span class="tt">Split the remaining &gt;1 000 line units (</span><a class="el" href="_path_renderer2_d_8cpp.html">PathRenderer2D.cpp</a><span class="tt">, </span><a class="el" href="_scene_snapshot_builder_8cpp.html">SceneSnapshotBuilder.cpp</a><span class="tt">, and </span>WidgetDrawablesDetail.inl<span class="tt">) into focused files so every UI TU stays below the target size.</span></li>
<li><span class="tt">Refresh </span><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a><span class="tt"> and renderer diagrams once files move so architecture snapshots continue to match the code layout.</span></li>
<li><span class="tt">Add a performance regression flow that records benchmark outputs (renderer, presenter, examples) each run, stores historical snapshots, and fails when deltas exceed thresholds relative to the previous baseline; wire it into the local </span>pre-push<span class="tt"> hook so regressions are caught before pushes.</span></li>
<li><span class="tt">Build a fault-injection harness that flips Metal upload flags, simulates surface resize failures, and drops drawables mid-frame to ensure diagnostics and error paths stay actionable.</span></li>
<li><span class="tt">Add optional ASan/TSan build/test modes via </span>scripts/compile.sh` (and expose toggles for the pre-push hook) so we can spot memory/race issues on demand without introducing a nightly job.</li>
<li>Document how the expanded diagnostics map into dashboards/alerts (metrics → panels/thresholds) so maintainers know where to monitor residency, progressive tiles, and performance regression outputs.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md210"></a>
Phase 7 — Optional Backends &amp; HTML Adapter Prep (post-MVP)</h3>
<ul>
<li>✅ (October 20, 2025) <span class="tt">PathSpaceUITests</span> now cover HTML canvas replay parity and the ObjC++ Metal presenter harness, replacing the skipped scaffolding.</li>
<li>🚧 (October 18, 2025) Introduced <span class="tt">PathSurfaceMetal</span> stub (texture allocation + resize) gated behind <span class="tt">PATHSPACE_UI_METAL</span>, linked Metal/QuartzCore, ready for presenter integration.</li>
<li>🚧 (October 19, 2025) Builders can now provision Metal targets end-to-end; the software renderer still populates Metal surfaces, and optional GPU uploads are gated on <span class="tt">PATHSPACE_ENABLE_METAL_UPLOADS=1</span> so CI remains headless-safe. Builder/UI tests publish a minimal snapshot before touching Metal paths to guarantee the software renderer has drawables to consume.</li>
<li>✅ (October 19, 2025) PathSurfaceMetal now caches the shared material descriptors emitted by PathRenderer2D so GPU uploads reuse the same shading telemetry when <span class="tt">PATHSPACE_ENABLE_METAL_UPLOADS=1</span>.</li>
<li>✅ (October 19, 2025) Renderer residency metrics now aggregate software surfaces and cached image payloads, publishing accurate CPU/GPU byte totals for diagnostics before enabling GPU shading.</li>
<li>✅ (October 19, 2025) Adaptive progressive tile sizing tightens tile dimensions for localized damage so brush-sized updates stick to 32–64 px tiles instead of full-surface fan-out, trimming encode work ahead of FPS parity tuning.</li>
<li>Extended Metal renderer (GPU raster path) gated by <span class="tt">PATHSPACE_UI_METAL</span>; build atop the baseline Metal presenter, confirm ObjC++ integration, and expand CI coverage. <b>Implementation plan map (Oct 18, 2025, updated Oct 19):</b></li>
</ul>
<ol type="1">
<li><b>Renderer kind plumbing</b><ul>
<li>✅ (October 19, 2025) <span class="tt">Builder::Renderer::Create</span> metadata now persists the requested <span class="tt">RendererKind</span>, and helpers/tests consume the new params signature.</li>
<li>✅ (October 19, 2025) <span class="tt">prepare_surface_render_context</span> resolves renderer kind per target, routing targets through cached software or Metal surfaces while keeping the software fallback as default when uploads stay disabled.</li>
</ul>
</li>
<li><b>Surface cache &amp; rendering loop</b><ul>
<li>✅ (October 19, 2025) Split render helpers so Metal targets reuse the shared cache but funnel through a backend-aware <span class="tt">render_into_target</span>; contexts fall back to software when uploads are disabled and tests exercise the unified path.</li>
</ul>
</li>
</ol>
<ul>
<li>✅ (October 19, 2025) PathRenderer2D now streams Metal frames directly into the cached CAMetalLayer texture (skipping the software upload hop when Metal uploads are enabled) while keeping residency metrics in sync.</li>
<li>✅ (October 19, 2025) <span class="tt">Renderer::TriggerRender</span> now reuses the shared surface caches (software and Metal) so ad-hoc renders avoid reallocating per call.</li>
<li>✅ (October 20, 2025) <span class="tt">PathRenderer2DMetal</span> now renders rects, rounded rects, text quads, and textured images directly on the GPU, with shared material/shader keys driving pipeline state so GPU frames mirror software telemetry; glyph/material pipeline parity will continue to build on the descriptor cache.<ul>
<li>🚧 (Follow-up) Keep the existing glyph-quads text path as a supported fallback/regression harness once the full text-shaping renderer lands; ensure tests cover both paths so fallback builds stay viable.</li>
</ul>
</li>
</ul>
<p><b>Presenter integration</b></p><ul>
<li>✅ (October 21, 2025) <span class="tt">PathWindowView::Present</span> (Apple) now handles both <span class="tt">PathSurfaceSoftware</span> and <span class="tt">PathSurfaceMetal</span> stats, acquiring the CAMetalLayer drawable and issuing the Metal blit inside the presenter so builders/tests exercise the shared path instead of relying on the legacy window pump.</li>
<li>✅ (October 19, 2025) Replaced the sample-specific <span class="tt">WindowEventPump.mm</span> with the shared <span class="tt">LocalWindowBridge</span> in the UI library; examples now consume the bridge and keep only input wiring.</li>
<li>✅ (October 19, 2025) PathWindowView now drives CAMetalLayer presents via the UI library, records GPU encode/present timings, and exposes configuration hooks; example harnesses only forward window/layer handles. Remaining platform scaffolding will shrink to input/event dispatch as the shared bridge matures.</li>
</ul>
<p><b>Settings &amp; diagnostics</b></p><ul>
<li>✅ (October 19, 2025) Extended <span class="tt">SurfaceDesc</span>/<span class="tt">RenderSettings</span> with Metal options (storage mode, usage flags, iosurface backing) and recorded the resolved backend/Metal upload state per frame so diagnostics retain GPU context alongside timings/errors.</li>
<li>✅ (October 19, 2025) Persist <span class="tt">diagnostics/errors/live</span> / <span class="tt">output/v1/common</span> updates for Metal frames (frameIndex, renderMs, GPU timings) and gate residency/cache metrics under <span class="tt">diagnostics/metrics/residency</span> so dashboards can track resource pressure.</li>
<li>✅ (October 19, 2025) PathRenderer2D now maintains a shared material descriptor cache so Metal and software paths emit identical shading telemetry across backends.</li>
</ul>
<p><b>Testing &amp; CI</b></p><ul>
<li>✅ (October 19, 2025) Added a PATHSPACE_ENABLE_METAL_UPLOADS-gated ObjC++ PathSpaceUITest (<span class="tt">tests/ui/test_PathWindowView_Metal.mm</span>) that exercises the CAMetalLayer presenter when Metal uploads are enabled.</li>
<li>✅ (October 20, 2025) Added GPU blending coverage (<span class="tt">tests/ui/test_PathWindowView_Metal.mm</span>: "PathRenderer2DMetal honors material blending state") to confirm material-driven pipeline state matches software behaviour.<ul>
<li>✅ (October 19, 2025) Local <span class="tt">pre-push</span> hook now auto-enables Metal presenter coverage (<span class="tt">--enable-metal-tests</span>) on macOS hosts, while respecting <span class="tt">DISABLE_METAL_TESTS=1</span> to fall back when GPU access is unavailable.</li>
<li>✅ (October 19, 2025) GitHub Actions now runs a macOS job that invokes <span class="tt">./scripts/compile.sh --enable-metal-tests --test --loop=1</span>, while tests continue to skip gracefully when Metal uploads remain disabled or unsupported.</li>
<li>Builders/UI diagnostic suites leave Metal-specific assertions to the gated UITest so the core builders coverage stays backend-agnostic even when PATHSPACE_ENABLE_METAL_UPLOADS=1.</li>
</ul>
</li>
<li>✅ (October 20, 2025) <span class="tt">./scripts/compile.sh</span> enables Metal tests by default; use <span class="tt">--disable-metal-tests</span> only when the host cannot provide a compatible GPU.</li>
</ul>
<p><b>Follow-ups</b></p><ul>
<li>✅ (October 19, 2025) Renderer stats and diagnostics now cover GPU error paths end-to-end; tests assert Diagnostics::ReadTargetMetrics surfaces Metal presenter failures.</li>
<li>✅ (October 19, 2025) Shader/material system parity established by deriving shared shader keys from software pipeline flags and exposing them to the Metal surface.</li>
<li>✅ (October 19, 2025) Resource residency metrics now aggregate texture usage for GPU paths; Metal surfaces track resource fingerprints and publish residency totals.</li>
</ul>
<p>✅ (October 19, 2025) PATHSPACE_ENABLE_METAL_UPLOADS coverage now exercises the full Metal present path, checks shader/material descriptor parity, and asserts residency/cache metrics (cpu/gpu bytes) are published so dashboards/CI immediately flag resource pressure regressions (<span class="tt">tests/ui/test_PathWindowView_Metal.mm</span>: "Metal pipeline publishes residency metrics and material descriptors").</p><ul>
<li><b>HTML follow-ups (October 19, 2025):</b> remaining work is documenting fidelity troubleshooting (see Phase 7 items 5–6); new CI harness (<span class="tt">HtmlCanvasVerify</span>) is in place—keep it updated when adapter schemas evolve.<ul>
<li>✅ (October 22, 2025) Added themed widget scene replays to <span class="tt">HtmlCanvasVerify</span>, hashing native vs HTML replays so palette and typography drifts surface immediately when either pipeline diverges.</li>
<li>✅ (October 22, 2025) Published <span class="tt"><a class="el" href="_h_t_m_l___adapter___quickstart_8md.html">docs/HTML_Adapter_Quickstart.md</a></span> with the harness workflow, HSAT tooling steps, and troubleshooting signatures so future cycles can validate HTML fidelity without rediscovering the flow.</li>
<li><b>Oct 21, 2025 update:</b> PathSpace core now preserves <span class="tt">Html::Asset</span> vectors across translation units (see commit <span class="tt">fix(ui): ensure html assets survive cross-tu reads</span>). The new <span class="tt">Html assets round-trip without HtmlSerialization include</span> UITest guards the regression. Resume the documentation follow-ups under Phase 7 items 5–6.</li>
</ul>
</li>
<li>HTML adapter scaffolding (command stream emitter + replay harness) behind experimental flag. <b>Implementation plan map (Oct 18, 2025):</b><ol type="1">
<li><b>Adapter core API</b><ul>
<li>✅ (October 19, 2025) <span class="tt">Html::Adapter::emit</span> now produces DOM/CSS/canvas outputs and honours emit options.</li>
<li>✅ (October 19, 2025) Snapshot traversal supplies drawable buckets and fingerprints directly to the adapter.</li>
</ul>
</li>
<li><b>Command stream emitter</b><ul>
<li>✅ (October 19, 2025) DOM serializer and canvas JSON fallback reuse the drawable command stream while respecting node budgets and fallback policy.</li>
<li>✅ (October 21, 2025) Html adapter now resolves asset blobs (images/fonts) via fingerprint paths using the renderer-provided loader, so emitted assets carry real bytes without post-processing.</li>
</ul>
</li>
<li><b>Replay harness</b><ul>
<li>✅ (October 19, 2025) Added standalone HTML runner (tests/ui + example) that replays canvas command streams and checks parity with PathRenderer2D output.</li>
<li>✅ (October 19, 2025) Doctest coverage compares PathRenderer2D framebuffer against replayed canvas output to guard regressions.</li>
</ul>
</li>
<li><b>Builder integration</b><ul>
<li>✅ (October 19, 2025) Renderer targets now emit HTML outputs under <span class="tt">output/v1/html/{dom,css,commands,assets}</span> using the adapter and persist the applied options.</li>
<li>✅ (October 19, 2025) HTML <span class="tt">Window::Present</span> now enforces the <span class="tt">AlwaysLatestComplete</span> policy, writes diagnostics/residency metrics, and is covered by doctests (<span class="tt">Window::Present writes HTML present metrics and residency</span>).</li>
</ul>
</li>
<li><b>Tooling &amp; CI</b><ul>
<li>✅ (October 19, 2025) Added the Node-based <span class="tt">HtmlCanvasVerify</span> CTest (backed by <span class="tt">scripts/verify_html_canvas.js</span>) so CI exercises DOM vs Canvas outputs when <span class="tt">node</span> is present and emits a skip notice otherwise.</li>
</ul>
</li>
<li><b>Documentation</b><ul>
<li>✅ (October 19, 2025) Documented HTML adapter fidelity tiers, configuration knobs (<span class="tt">max_dom_nodes</span>, <span class="tt">prefer_dom</span>, <span class="tt">allow_canvas_fallback</span>), asset hydration, and debugging steps in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>; keep the section current as adapter behavior evolves.</li>
</ul>
</li>
</ol>
</li>
<li>✅ (October 20, 2025) Resource loader integration (HTML + renderers) now hydrates image/font assets and persists them under <span class="tt">output/v1/html/assets</span> using a stable binary <span class="tt">Html::Asset</span> codec; <span class="tt">Renderer::RenderHtml hydrates image assets into output</span> and the new <span class="tt">Html::Asset vectors survive PathSpace round-trip</span> doctest both pass with hydrated bytes.</li>
<li>✅ (October 20, 2025) Documented the HTML asset codec (HSAT framing, legacy migration) in <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>; update the renderer plan when fields or versions change.</li>
<li>✅ (October 20, 2025) Removed the legacy Alpaca serializer fallback; HSAT payloads are now required for <span class="tt">output/v1/html/assets</span>.</li>
<li>✅ (October 21, 2025) Added the <span class="tt">pathspace_hsat_inspect</span> CLI plus <span class="tt">HtmlAssetInspect</span> regression (Node harness) to decode HSAT payloads; extend the fixture when new asset fields (e.g., material descriptors) land.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md211"></a>
Phase 8 — Widget Toolkit &amp; Interaction Surfaces (post-MVP)</h3>
<ul>
<li><b>Objective:</b> ship reusable UI widgets (button, toggle, slider, list) that sit on top of the existing scene/render/present stack while reusing PathSpace paths for state and events.</li>
<li><b>Scene authoring</b><ul>
<li>✅ (October 21, 2025) Defined canonical widget scene snippets under <span class="tt">scenes/widgets/&lt;widget&gt;/states/*</span>, publishing idle/hover/pressed/disabled snapshots for each widget builder so state transitions reuse authored revisions.</li>
</ul>
</li>
<li>✅ (October 19, 2025) Added lightweight builders for buttons and toggles (<span class="tt">Builders::Widgets::CreateButton</span>, <span class="tt">CreateToggle</span>) that publish authoring data, bind to app-relative state paths, and express layout metadata (bounds, z-order).</li>
<li>✅ (October 20, 2025) Added a slider builder (<span class="tt">Builders::Widgets::CreateSlider</span>) with theme metadata, range/state storage, and snapshot generation for the minimal 2D theme.</li>
<li>✅ (October 20, 2025) Added a list builder (<span class="tt">Builders::Widgets::CreateList</span>) that publishes canonical list scenes, metadata (<span class="tt">meta/style</span>, <span class="tt">meta/items</span>), and default selection state while validating item identifiers.</li>
<li>✅ (October 21, 2025) Added a reusable stroke primitive (polyline/triangle strip) so paint examples track a point list per stroke instead of emitting per-dab rects; renderer + HTML adapter now consume the command and paint_example switched to the new primitive.<ul>
<li>✅ (October 21, 2025) Provide styling hooks (colors, corner radius, typography) so demos can skin widgets without forking scenes. <span class="tt">Widgets::WidgetTheme</span> centralises per-widget styles, builders publish the metadata, and <span class="tt">widgets_example</span> now loads a theme selectable via <span class="tt">WIDGETS_EXAMPLE_THEME</span> (default or <span class="tt">sunset</span>).</li>
</ul>
</li>
<li><b>Interaction contract</b><ul>
<li>✅ (October 21, 2025) Hit-test authoring ids now embed canonical <span class="tt">/widgets/&lt;id&gt;/authoring/...</span> paths and <span class="tt">Widgets::ResolveHitTarget</span>/<span class="tt">WidgetBindings::PointerFromHit</span> helpers normalize hover/press routing into the existing bindings + <span class="tt">ops/</span> queues.</li>
<li>✅ (October 21, 2025) Focus navigation helpers (<span class="tt">Widgets::Focus</span>) reuse <span class="tt">Scene::HitTest</span> metadata, maintain canonical focus state under <span class="tt">widgets/focus/current</span>, toggle widget scene states, and enqueue auto-render requests so highlight transitions redraw immediately.</li>
<li>✅ (October 21, 2025) Added UITest coverage for keyboard (Tab/Shift+Tab) and gamepad focus hops (<span class="tt">tests/ui/test_Builders.cpp</span>), asserting focus state transitions and <span class="tt">focus-navigation</span> auto-render scheduling so the 15× loop flags regressions immediately.</li>
<li>✅ (October 21, 2025) Documented the canonical widget state schema and confirmed updates stay atomic:<ul>
<li><span class="tt">widgets/&lt;id&gt;/state</span>, <span class="tt">widgets/&lt;id&gt;/enabled</span>, and <span class="tt">widgets/&lt;id&gt;/label</span> hold the live state tuple authored by builders.</li>
<li>Interaction queues live under <span class="tt">widgets/&lt;id&gt;/ops/inbox/queue</span> and reducer outputs land in <span class="tt">widgets/&lt;id&gt;/ops/actions/inbox/queue</span>.</li>
<li>Canonical state snapshots reside in <span class="tt">scenes/widgets/&lt;id&gt;/states/{idle,hover,pressed,disabled}</span> and are reused by bindings, reducer tests, and golden renders.</li>
</ul>
</li>
</ul>
</li>
<li><b>State binding &amp; data flow</b></li>
<li>✅ (October 19, 2025) Introduced initial state update helpers for buttons/toggles that coalesce redundant writes and mark the owning scene <span class="tt">DirtyKind::Visual</span> only when values change.</li>
<li>✅ (October 20, 2025) Binding layer (<span class="tt">Widgets::Bindings::Dispatch{Button,Toggle,Slider}</span>) watches widget state, emits dirty hints, and writes interaction ops (press/release/hover/toggle/slider events) into <span class="tt">widgets/&lt;id&gt;/ops/inbox/queue</span>. Reducer samples live in this plan’s appendix; schema covers <span class="tt">WidgetOpKind</span>, pointer metadata, value payloads, and timestamps for reducers to consume via wait/notify.</li>
<li>✅ (October 20, 2025) Added list state/update helpers (<span class="tt">Widgets::UpdateListState</span>) plus bindings (<span class="tt">CreateListBinding</span>/<span class="tt">DispatchList</span>) that emit <span class="tt">ListHover</span>, <span class="tt">ListSelect</span>, <span class="tt">ListActivate</span>, and <span class="tt">ListScroll</span> ops with dirty rect + auto-render integration.</li>
<li>✅ (October 20, 2025) Introduced reducer helpers (<span class="tt">Widgets::Reducers::ReducePending</span> / <span class="tt">PublishActions</span>) so apps can drain widget op queues into <span class="tt">ops/actions/inbox/queue</span>; example + doctests cover button activation and list selection flows.</li>
<li><b>Testing</b><ul>
<li>✅ (October 21, 2025) <span class="tt">PathSpaceUITests</span> now render button/toggle/slider/list goldens and replay hover/press/disabled sequences in <span class="tt">tests/ui/test_Builders.cpp</span>, keeping the 15× loop sensitive to widget regressions.</li>
<li>✅ (October 22, 2025) Added doctest coverage that exercises binding helpers with auto-render disabled (<span class="tt">Widgets::Bindings::DispatchButton honors auto-render flag</span>) ensuring dirty hints still emit without queueing <span class="tt">renderRequested</span> events; existing focus/navigation tests continue to cover focus routing.</li>
<li>✅ (October 21, 2025) Added adjacent-widget dirty propagation coverage (<span class="tt">tests/ui/test_Builders.cpp</span>: "Widgets dirty hints cover adjacent widget bindings"), confirming overlapping dirty hints schedule renders for neighbouring widgets while their state remains unchanged.</li>
<li>✅ (October 23, 2025) Introduced a widget reducers/bindings fuzz harness (<span class="tt">tests/ui/test_WidgetReducersFuzz.cpp</span>) that randomizes pointer and keyboard sequences, validates dirty hints and auto-render events, drains reducers, and republishes actions to assert queue invariants.</li>
</ul>
</li>
<li><b>Tooling &amp; docs</b></li>
<li>✅ (October 19, 2025) Expanded <span class="tt">examples/widgets_example.cpp</span> to publish button + toggle widgets and demonstrate state updates; grow into a full gallery as additional widgets land.</li>
<li>✅ (October 20, 2025) widgets_example now instantiates slider and list widgets, exercises the state helpers, and prints the relevant path wiring to guide gallery expansion; continue instrumenting interaction telemetry in follow-up work.</li>
<li>✅ (October 21, 2025) widgets_example now drives the gallery window, renders all shipped widgets with inline text labels, logs per-second FPS/present telemetry using the software presenter, and feeds LocalWindow mouse input through widget bindings to republish the gallery snapshot on interaction.</li>
<li>✅ (October 21, 2025) widgets_example adds keyboard focus cycling (Tab/Shift+Tab), arrow-key slider/list control, and reducer action logging so gallery runs surface queue activity without external tooling.</li>
<li>✅ (October 21, 2025) Introduced <span class="tt">Builders::App::Bootstrap</span> helper so examples/tests can create renderer/surface/window defaults for a scene with one call; docs/onboarding updated alongside the helper.</li>
<li>✅ (October 21, 2025) widgets_example now consumes <span class="tt">Widgets::WidgetTheme</span> output (and <span class="tt">WIDGETS_EXAMPLE_THEME</span>) so demos can swap color palettes and typography without rewriting scenes; theme defaults live next to the builders for reuse.<ul>
<li>✅ (October 23, 2025) Added a theme hot-swap UITest (<span class="tt">tests/ui/test_Builders.cpp</span>: "Widgets::WidgetTheme hot swap repaints button scenes and marks dirty") that applies default/sunset themes in-place, asserts scene/state revisions bump, and verifies metadata + drawable colors update without stale cache artifacts.</li>
<li>Cover <span class="tt">Builders::App::Bootstrap</span> in doctests/PathSpaceUITests so examples/tests migrating to the helper keep setup/regression coverage as bespoke scaffolding is removed.</li>
<li>Author a widget-contribution quickstart doc outlining required paths, reducer hooks, theme integration, accessibility metadata, and the new test harnesses so additions land consistently.</li>
<li>Ship a capture/replay harness script (<span class="tt">scripts/record_widget_session.sh</span> + <span class="tt">scripts/replay_widget_session.sh</span>) so bug reports can include deterministic pointer/keyboard traces for widgets_example and UITests.</li>
<li>Add layout/container widgets (horizontal/vertical stacks, grid) that arrange child widgets, emit spacing/alignment metadata, and propagate dirty hints when layout changes; cover the behaviour with UITests and gallery demos.</li>
<li>Build a tree view widget that supports expand/collapse, selection, and async data loading hooks, complete with bindings, reducer support, canonical paths, and gallery/UITest coverage.</li>
<li>Extend <span class="tt">widgets_example</span> to showcase layout containers and the tree view, wiring state paths, reducers, and telemetry so contributors can exercise them interactively.</li>
</ul>
</li>
<li>Update <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> and <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span> with widget path conventions, builder usage, and troubleshooting steps.</li>
<li>Document widget ops schema: queue path (<span class="tt">widgets/&lt;id&gt;/ops/inbox/queue</span>), <span class="tt">WidgetOp</span> fields (kind, pointer metadata, value, timestamp) and reducer sample wiring.</li>
<li>✅ (October 20, 2025) Reducer samples now live in <span class="tt">Widgets::Reducers</span>, publishing actions under <span class="tt">widgets/&lt;id&gt;/ops/actions/inbox/queue</span>; keep telemetry/docs in sync when new action fields or op kinds land.</li>
</ul>
<p><b>Widget ops schema (October 20, 2025)</b></p><ul>
<li>Queue path: <span class="tt">widgets/&lt;id&gt;/ops/inbox/queue</span> (per-widget FIFO consumed via <span class="tt">take&lt;WidgetOp&gt;</span>).</li>
<li><span class="tt">WidgetOp</span> payload: <span class="tt">{ kind: WidgetOpKind, widget_path: string, pointer: { scene_x, scene_y, inside, primary }, value: float, sequence: uint64, timestamp_ns: uint64 }</span>.</li>
<li>Supported kinds (October 20, 2025): <span class="tt">HoverEnter</span>, <span class="tt">HoverExit</span>, <span class="tt">Press</span>, <span class="tt">Release</span>, <span class="tt">Activate</span>, <span class="tt">Toggle</span>, <span class="tt">SliderBegin</span>, <span class="tt">SliderUpdate</span>, <span class="tt">SliderCommit</span>, <span class="tt">ListHover</span>, <span class="tt">ListSelect</span>, <span class="tt">ListActivate</span>, <span class="tt">ListScroll</span> (document new ones alongside widget additions and clamp indices via widget metadata before mutating app state).</li>
<li>Reducer shape: wait/notify loop blocks on the queue, translates ops into app actions (<span class="tt">ops/&lt;action&gt;/inbox</span>) and calls <span class="tt">Widgets::Update*State</span> helpers to keep scenes in sync without republishing whole snapshots.<ul>
<li>Capture authoring guidelines in <span class="tt"><a class="el" href="_plan___scene_graph___implementation_8md.html">docs/Plan_SceneGraph_Implementation.md</a></span>'s appendix so contributors can add new widgets consistently.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md212"></a>
Dependencies and Ordering</h2>
<ul>
<li>Helpers (Phase 1) unblock snapshot builder and surfaces/presenters by standardizing paths.</li>
<li>Snapshot builder (Phase 2) must land before renderer to provide immutable input revisions.</li>
<li>Renderer (Phase 3) depends on RenderSettings semantics and DrawableBucket schema from Phase 2.</li>
<li>Surfaces/presenters (Phase 4) rely on renderer outputs and present policy definitions; progressive mode requires renderer metrics hooks.</li>
<li>Input/hit testing &amp; notifications (Phase 5) relies on renderer outputs, snapshot metadata, and presenter hooks established in earlier phases.</li>
<li>Diagnostics/tooling (Phase 6) builds on metrics and error reporting emitted by previous phases; schedule alongside hardening once core flows stabilize.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md213"></a>
Cross-Cutting Concerns</h2>
<ul>
<li><b>Atomicity</b> — All settings and publish operations must remain single-path replacements; tests should assert no partial reads/writes occur.</li>
<li><b>Concurrency</b> — Rely on PathSpace’s atomic reads/writes, revision epochs, and wait/notify primitives; avoid external mutexes and validate the data-driven coordination model via tests.</li>
<li><b>GC &amp; retention</b> — Implement revision pinning and cleanup thresholds (retain ≥3 revisions or ≥2 minutes) early to avoid storage issues.</li>
<li><b>Instrumentation</b> — Ensure every phase exposes metrics compatible with the frame profiler plan (<span class="tt">output/v1/common</span>, progressive stats, diagnostics rings).</li>
<li><b>Notifications</b> — Align dirty markers, wait queues, and auto-render triggers with the scheduling model; cover producer/consumer wakeups in tests.</li>
<li><b>Resources</b> — Respect per-item residency policies, propagate fingerprints consistently, and validate cache eviction rules with tests.</li>
<li><b>Documentation discipline</b> — Mirror behavioral changes in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">AI_Architecture.md</a></span>, update diagrams as necessary, and capture CLI/tool scripts.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md214"></a>
Testing Strategy</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md215"></a>
Current Automation Snapshot (October 19, 2025)</h3>
<ul>
<li><span class="tt">./scripts/compile.sh --test --loop=1 --per-test-timeout 20</span> offers a fast smoke run when chasing regressions.</li>
<li><span class="tt">./scripts/compile.sh --enable-metal-tests --test --loop=1 --per-test-timeout 20</span> exercises the Metal presenter path on macOS hosts; keep it gated behind <span class="tt">PATHSPACE_ENABLE_METAL_UPLOADS</span> in CI.</li>
<li>The local <span class="tt">pre-push</span> hook (<span class="tt">scripts/git-hooks/pre-push.local.sh</span>) enables Metal presenter coverage by default; export <span class="tt">DISABLE_METAL_TESTS=1</span> when GPU access is unavailable.</li>
<li>CI currently runs the Linux matrix plus a macOS job invoking <span class="tt">./scripts/compile.sh --enable-metal-tests --test --loop=1</span> to guard the presenter path.</li>
<li>Draft a Linux/Wayland bring-up checklist (toolchain flags, presenter shims, input adapters, CI coverage) so non-macOS contributors know the remaining gaps for the UI stack.</li>
<li>Extend <span class="tt">scripts/compile.sh</span> to cover new targets and maintain the 15× loop with 20 s timeout.</li>
<li>Add deterministic golden outputs (framebuffers, DrawableBucket metadata) with tolerance-aware comparisons.</li>
<li>Stress tests: concurrent edits vs renders, present policy edge cases, progressive tile churn, input-routing races, error-path validation (missing revisions, bad settings).</li>
<li>CI gating: require looped CTest run and lint/format checks before merging.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md216"></a>
Open Questions to Resolve Early</h2>
<ul>
<li>Finalize <span class="tt">DrawableBucket</span> binary schema (padding, endianness, checksum) before snapshot/renderer work diverges.</li>
<li>Decide on minimum color management scope for MVP (srgb8 only vs optional linear FP targets).</li>
<li>Clarify resource manager involvement for fonts/images in MVP vs deferred phases.</li>
<li>Validate CAMetalLayer drawable lifetime, IOSurface reuse, and runloop coordination during resize/fullscreen transitions for the Metal presenter.</li>
<li>Nail down metrics format (<span class="tt">output/v1/common</span> vs <span class="tt">diagnostics/metrics</span>) to keep profiler expectations stable.</li>
<li>Define sequencing for path-traced lighting and tetrahedral acceleration work (post-MVP vs incremental alongside GPU backends).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md217"></a>
Documentation &amp; Rollout Checklist</h2>
<ul>
<li>Update <span class="tt">README.md</span> build instructions once UI flags ship.</li>
<li>Keep <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span> cross-references aligned; link to this implementation plan from that doc and vice versa.</li>
<li>Add developer onboarding snippets (how to run tests, inspect outputs) to <span class="tt">docs/</span>.</li>
<li>Track milestone completion in <span class="tt">AI_Todo.task</span> or equivalent planning artifact.</li>
<li>As of October 19, 2025, <span class="tt"><a class="el" href="_a_i___onboarding_8md.html">docs/AI_Onboarding.md</a></span>, <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span>, <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>, and <span class="tt"><a class="el" href="_a_i___debugging___playbook_8md.html">docs/AI_Debugging_Playbook.md</a></span> already capture the Metal presenter metrics, residency counters, and looped test workflow; keep future changes synchronized across those references.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md218"></a>
Related Documents</h2>
<ul>
<li>Specification: <span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span></li>
<li>Core architecture overview: <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_Architecture.md</a></span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md219"></a>
Maintenance Considerations</h2>
<ul>
<li>Ensure feature flags allow partial builds (e.g., disable UI pipeline when unsupported).</li>
<li>Monitor binary artifact sizes for snapshots; consider tooling to inspect revisions.</li>
<li>Plan for future GPU backend work without blocking MVP—keep interfaces abstract and avoid hard-coding software assumptions.</li>
<li>Establish guardrails for progressive mode defaults to avoid regressing latency-sensitive apps.</li>
<li>Respect residency policies and track resource lifecycle metrics so caches stay healthy. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
