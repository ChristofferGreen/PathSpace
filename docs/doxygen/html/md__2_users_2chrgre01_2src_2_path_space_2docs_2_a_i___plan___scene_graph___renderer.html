<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: PathSpace — Scene Graph and Renderer Plan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_a_i___plan___scene_graph___renderer.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">PathSpace — Scene Graph and Renderer Plan </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md78"></a></p>
<p>Scope: UI surfaces, renderers, presenters, multi-scene targets; atomic params and snapshot-based rendering</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md79"></a>
Goals</h1>
<ul>
<li>Application-scoped resources: windows, scenes, renderers, and surfaces live under one app root so removing the root tears everything down</li>
<li>Multi-scene renderers: a single renderer can render multiple scenes concurrently; consumers select a scene via per-target configuration</li>
<li>Window-agnostic surfaces: offscreen render targets (software or GPU) that can be presented by multiple windows within the same application</li>
<li>Typed wiring: small C++ helpers return canonical paths; avoid string concatenation; validate same-app containment</li>
<li>Atomicity and concurrency: prepare off-thread, publish atomically, and render from immutable snapshots for both target parameters and scene data</li>
<li>Cross-platform path: start with software on macOS; add Metal; keep Vulkan as a future option</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md80"></a>
Application roots and ownership</h1>
<p>Applications are mounted under:</p><ul>
<li>System-owned: <span class="tt">/system/applications/&lt;app&gt;</span></li>
<li>User-owned: <span class="tt">/users/&lt;user&gt;/system/applications/&lt;app&gt;</span></li>
</ul>
<p>Everything an application needs is a subtree below the app root. No cross-app sharing of surfaces or renderers. All references are app-relative (no leading slash) and must resolve within the app root. See <a class="el" href="_a_i___p_a_t_h_s_8md.html">docs/AI_PATHS.md</a> for the canonical path namespaces and layout conventions.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md81"></a>
App-internal layout (standardized)</h1>
<p>Path shorthand guide</p><ul>
<li>The docs use shorthand like targets/&lt;tid&gt;/... and windows/&lt;win&gt;/views/&lt;view&gt;/... to keep examples concise.</li>
<li>Shorthand expands relative to the app root to full paths:<ul>
<li>targets/&lt;tid&gt;/... =&gt; &lt;app&gt;/renderers/&lt;renderer-id&gt;/targets/&lt;kind&gt;/&lt;name&gt;/...</li>
<li>scenes/&lt;sid&gt;/... =&gt; &lt;app&gt;/scenes/&lt;scene-id&gt;/...</li>
<li>windows/&lt;win&gt;/views/&lt;view&gt;/... =&gt; &lt;app&gt;/windows/&lt;window-id&gt;/views/&lt;view&gt;/...</li>
</ul>
</li>
<li>In code and tests, prefer full app-root paths and validate containment. Shorthand is documentation-only.</li>
<li><span class="tt">scenes/&lt;scene-id&gt;/</span> — authoring tree (<span class="tt">src/...</span>), immutable builds (<span class="tt">builds/&lt;revision&gt;/...</span>), and <span class="tt">current_revision</span></li>
<li><span class="tt">renderers/&lt;renderer-id&gt;/</span> — renderer with per-target subtrees (multi-scene capable)</li>
<li><span class="tt">surfaces/&lt;surface-id&gt;/</span> — offscreen render targets; coordinate with a renderer target</li>
<li><span class="tt">windows/&lt;window-id&gt;/</span> — platform window shell and views (presenters)</li>
</ul>
<p>Example (abridged): </p><div class="fragment"><div class="line">/system/applications/notepad/</div>
<div class="line">  scenes/</div>
<div class="line">    main/</div>
<div class="line">      src/...</div>
<div class="line">      builds/&lt;revision&gt;/...</div>
<div class="line">      current_revision</div>
<div class="line">    settings/</div>
<div class="line">      src/...</div>
<div class="line">      builds/&lt;revision&gt;/...</div>
<div class="line">      current_revision</div>
<div class="line">  renderers/</div>
<div class="line">    2d/</div>
<div class="line">      caps</div>
<div class="line">      targets/</div>
<div class="line">        surfaces/editor/</div>
<div class="line">          scene                         # &quot;scenes/main&quot; (app-relative)</div>
<div class="line">          desc                          # SurfaceDesc/TextureDesc/HtmlTargetDesc</div>
<div class="line">          desc/active                   # mirror written by renderer (optional)</div>
<div class="line">          settings                      # single RenderSettings value (atomic whole-object replace)</div>
<div class="line">          render                        # Execution: render one frame</div>
<div class="line">          output/</div>
<div class="line">            v1/</div>
<div class="line">              software/framebuffer      # pixels + stride</div>
<div class="line">              common/                   # timings, indices, etc.</div>
<div class="line">                frameIndex</div>
<div class="line">                revision</div>
<div class="line">                renderMs</div>
<div class="line">                lastError</div>
<div class="line">  surfaces/</div>
<div class="line">    editor/</div>
<div class="line">      renderer = &quot;renderers/2d&quot;</div>
<div class="line">      scene    = &quot;scenes/main&quot;</div>
<div class="line">      render   # Execution: coordinates with renderer target</div>
<div class="line">  windows/</div>
<div class="line">    MainWindow/</div>
<div class="line">      title = &quot;Notepad — Main&quot;</div>
<div class="line">      window</div>
<div class="line">      views/</div>
<div class="line">        editor/</div>
<div class="line">          surface = &quot;surfaces/editor&quot;</div>
<div class="line">          present  # Execution: blit/draw surface into the window</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md82"></a>
Entities and responsibilities</h1>
<p>Entity (renderer-facing, renderable-only)</p><ul>
<li>Purpose: the renderable view of a domain object. The true/authoritative object lives elsewhere (physics/sim/scripts); the renderer never serves data back to them.</li>
<li>Identity: stable per-Entity id suitable for caching, hit testing, and routing; derived deterministically from the source object id plus a stable sub-draw index.</li>
<li>Components (renderer-facing): world transform (with transformEpoch), geometry/material/texture references (with contentEpoch), pipeline flags, and world-space bounds (sphere/box).</li>
<li>Snapshot immutability: Entities and their referenced resources are immutable within a published revision; changes produce a new revision unless explicitly marked dynamic (streaming).</li>
</ul>
<p>Per-item residency/storage policy (standard PathSpace values)</p><ul>
<li>Policy is defined per resource under authoring: <span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/*</span>:<ul>
<li>allowed: backends the item may reside in, e.g., ["gpu","ram","disk"]</li>
<li>preferred: backend ordering hints, e.g., ["gpu","ram"]</li>
<li>durability: "ephemeral" | "cacheable" | "durable" (restart-survivable if not ephemeral)</li>
<li>max_bytes, cache_priority, eviction_group: admission/eviction controls</li>
</ul>
</li>
<li>The renderer’s resource manager enforces residency/eviction according to policy and watermarks; backend mapping (RAM/SHM/FS/GPU) is internal and opaque to callers.</li>
</ul>
<p>Authoring concurrency (proposed vs resolved)</p><ul>
<li>Producers write proposals under <span class="tt">scenes/&lt;sid&gt;/src/objects/&lt;oid&gt;/proposed/&lt;source&gt;/&lt;component&gt;/*</span> (e.g., physics, script).</li>
<li>A coalescer resolves to <span class="tt">.../resolved/&lt;component&gt;/*</span> using per-component policy: ownership, priority, or merge. Resolved components carry epochs/versions.</li>
<li>The builder latches a consistent resolved view (epochs) and publishes an immutable snapshot under <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/*</span>; then updates <span class="tt">current_revision</span>. Renderers latch <span class="tt">current_revision</span> per frame and never re-read mid-frame.</li>
<li>Window (shell)<ul>
<li>Platform-native window; emits state/events (resize, focus, close)</li>
<li>Lives under <span class="tt">windows/&lt;id&gt;/window</span> and is unaware of rendering</li>
</ul>
</li>
<li>Presenter/View (window view)<ul>
<li>Lives under <span class="tt">windows/&lt;id&gt;/views/&lt;view-id&gt;/...</span></li>
<li>Reads its <span class="tt">surface</span> (app-relative), optionally triggers a frame on the surface, and presents:<ul>
<li>Software: blit bytes to the native window</li>
<li>Metal/Vulkan: draw a textured quad sampling the offscreen texture/image into the window’s drawable/swapchain</li>
</ul>
</li>
</ul>
</li>
<li>Surface (offscreen render target)<ul>
<li>Lives under <span class="tt">surfaces/&lt;id&gt;/...</span></li>
<li>Holds <span class="tt">renderer</span> and <span class="tt">scene</span> (both app-relative strings); usable in any number of windows within the same app</li>
<li><span class="tt">render</span> coordinates a target-scoped render with its renderer, then exposes output (framebuffer or GPU handles)</li>
</ul>
</li>
<li>Renderer (multi-scene)<ul>
<li>Lives under <span class="tt">renderers/&lt;id&gt;/...</span></li>
<li>Stateless w.r.t. windows; serves work per target:<ul>
<li><span class="tt">targets/&lt;target-id&gt;/scene</span> — app-relative scene path to render</li>
<li><span class="tt">targets/&lt;target-id&gt;/settings</span> — single whole <span class="tt">RenderSettings</span> value (atomic whole-object replace)</li>
<li><span class="tt">targets/&lt;target-id&gt;/render</span> — execution that renders one frame for this target</li>
<li><span class="tt">targets/&lt;target-id&gt;/output/v1/...</span> — per-target outputs and stats (software/GPU/HTML)</li>
</ul>
</li>
<li>Target-id convention: use the consumer’s app-local path, e.g., <span class="tt">surfaces/&lt;surface-name&gt;</span> or <span class="tt">textures/&lt;texture-name&gt;</span></li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md83"></a>
Atomicity and concurrency</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md84"></a>
Render settings atomicity (per renderer target)</h2>
<ul>
<li>Single-path settings:<ul>
<li>Authoritative path: <span class="tt">settings</span></li>
<li>Writers construct a complete <span class="tt">RenderSettings</span> object (or nested subtree) off-thread and atomically replace the value at this path in one insert.</li>
<li>Do not split settings across multiple child paths if you require atomic reads.</li>
</ul>
</li>
<li>Renderer latch (per frame):<ul>
<li>At frame start, read <span class="tt">settings</span> once and use that snapshot for the entire frame (no mid-frame reads).</li>
</ul>
</li>
<li>Multi-producer guidance:<ul>
<li>Prefer a single logical owner (aggregator) that merges inputs and performs the atomic replace; if multiple producers write directly, last-writer-wins applies at the single path.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md85"></a>
Scene graph concurrency (authoring vs rendering)</h2>
<ul>
<li>Authoring tree is mutable: <span class="tt">scenes/&lt;sid&gt;/src/...</span></li>
<li>Builds (snapshots) are immutable, versioned by revision:<ul>
<li><span class="tt">scenes/&lt;sid&gt;/builds/&lt;revision&gt;/...</span> — pre-baked display list (world transforms, z-order, draw commands)</li>
<li><span class="tt">scenes/&lt;sid&gt;/current_revision</span> — pointer to the latest published build (single-value register)</li>
</ul>
</li>
<li>Build pipeline: 1) Edits to <span class="tt">src</span> mark dirty and trigger a debounced layout/build 2) A builder computes a display-list snapshot off-thread 3) Build written under <span class="tt">builds/&lt;new_revision&gt;/...</span> 4) Publish via atomic replace of <span class="tt">scenes/&lt;sid&gt;/current_revision</span> to <span class="tt">&lt;new_revision&gt;</span> 5) Optionally GC old snapshots once not in use</li>
<li>Renderers read a consistent build (<span class="tt">current_revision</span> latched per frame) with no global locks</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md86"></a>
Locking strategy</h2>
<ul>
<li>No global locks for scene edits; builders work from <span class="tt">src</span> to a new immutable snapshot</li>
<li>Renderer param adoption uses a short local mutex; the render loop reads from adopted, immutable state</li>
<li>Presenters marshal final present to the correct thread/runloop (e.g., macOS/Metal)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md87"></a>
Frame orchestration</h1>
<p>Renderer (per target): 1) Read settings once from <span class="tt">settings</span> (atomic single-path value for the whole frame). Mid-frame writes to <span class="tt">settings</span> do not affect the in-flight frame; adoption occurs at the next frame start (no cancellation). 2) Resolve <span class="tt">targets/&lt;tid&gt;/scene</span> against the app root; validate it stays within the same app subtree 3) Read <span class="tt">scenes/&lt;sid&gt;/current_revision</span>; latch for this render 4) Traverse <span class="tt">scenes/&lt;sid&gt;/builds/&lt;revision&gt;/...</span> and render:</p><ul>
<li>Software: produce a framebuffer (pixels + stride)</li>
<li>GPU: render into an offscreen texture/image 5) Write <span class="tt">targets/&lt;tid&gt;/output/v1/...</span> and stamp <span class="tt">frameIndex</span> + <span class="tt">revision</span></li>
</ul>
<p>Presenter (per window view): 1) Read <span class="tt">windows/&lt;win&gt;/views/&lt;view&gt;/{surface, windowTarget, present/{policy,params}}</span> once per present; resolve to <span class="tt">renderers/&lt;rid&gt;/targets/surfaces/&lt;sid&gt;</span> or <span class="tt">renderers/&lt;rid&gt;/targets/windows/&lt;wid&gt;</span>; do not re-read mid-present 2) For surfaces:</p><ul>
<li>Optionally call <span class="tt">surfaces/&lt;sid&gt;/render</span>, which:<ul>
<li>Writes a whole <span class="tt">RenderSettings</span> to <span class="tt">renderers/&lt;rid&gt;/targets/surfaces/&lt;sid&gt;/settings</span></li>
<li>Triggers <span class="tt">renderers/&lt;rid&gt;/targets/surfaces/&lt;sid&gt;/render</span> For windows targets:</li>
</ul>
</li>
<li>Acquire the window drawable/swapchain for <span class="tt">&lt;wid&gt;</span> on the platform UI/present thread; present for windowTarget occurs on that thread. Surface blits occur on the UI thread after render completes. 3) Present:</li>
<li>Software (surface): read framebuffer and blit to the window</li>
<li>GPU (surface): draw a textured quad sampling the offscreen texture/image to the window drawable/swapchain</li>
<li>GPU (windows target): present the acquired drawable/swapchain image (direct-to-window)</li>
</ul>
<p>Present policy (backend-aware)</p><ul>
<li>Modes:<ul>
<li>AlwaysFresh<ul>
<li>Software: UI thread waits up to a tight deadline for a new framebuffer; if not ready by deadline, skip this present rather than blitting stale pixels.</li>
<li>GPU: wait on the offscreen render fence until (vsync_deadline − ε) or frame_timeout_ms. If not signaled, either draw the previous offscreen texture or skip present (configurable).</li>
<li>HTML: treated as AlwaysLatestComplete (policy ignored).</li>
</ul>
</li>
<li>PreferLatestCompleteWithBudget (default)<ul>
<li>Software: if a fresh framebuffer can complete by now + staleness_budget_ms, wait; else blit last-complete. Never block the UI thread beyond budget.</li>
<li>GPU: if the offscreen fence is likely to signal by (vsync_deadline − ε), wait; else draw the previous offscreen texture this vsync.</li>
<li>HTML: AlwaysLatestComplete.</li>
</ul>
</li>
<li>AlwaysLatestComplete<ul>
<li>Software/GPU: present whatever output is complete now; do not wait.</li>
<li>HTML: same.</li>
</ul>
</li>
</ul>
</li>
<li>Parameters:<ul>
<li>staleness_budget_ms: float (default 8.0)</li>
<li>max_age_frames: uint (default 1)</li>
<li>frame_timeout_ms: float (default 20.0)</li>
<li>vsync_align: bool (default true)</li>
<li>auto_render_on_present: bool (default true)</li>
</ul>
</li>
<li>Semantics (per present): 1) Latch target base and current_revision at present start. 2) If auto_render_on_present and output age &gt; staleness_budget_ms, enqueue a render (idempotent if already in-flight). 2a) If output age in frames exceeds max_age_frames, enqueue a render (idempotent). Age in frames counts completed frames since the output’s revision was produced; skipped presents do not reset age. 3) Compute deadline:<ul>
<li>AlwaysFresh: deadline = min(vsync_deadline, now + frame_timeout_ms)</li>
<li>PreferLatestCompleteWithBudget: deadline = min(vsync_deadline, now + staleness_budget_ms)</li>
<li>AlwaysLatestComplete: deadline = now 4) If a newer frame completes before deadline, present it; else present last-complete if policy allows.</li>
<li>AlwaysFresh: skip present when the deadline is missed.</li>
<li>If age_frames &gt; max_age_frames and a fresh frame is not ready by the deadline:<ul>
<li>PreferLatestCompleteWithBudget / AlwaysLatestComplete: present the last-complete and keep the queued render.</li>
<li>AlwaysFresh: still skip present.</li>
</ul>
</li>
</ul>
</li>
<li>Backend notes:<ul>
<li>Timing source: vsync_deadline comes from platform presentation timing APIs when available (e.g., CVDisplayLink/CAMetalLayer on macOS); otherwise estimate from a monotonic clock and known refresh.</li>
<li>Software:<ul>
<li>Keep double-buffering for buffered mode; reserve a blit_budget_ms derived from width×height×bytes_per_pixel to avoid missing vsync on large frames.</li>
<li>Never block the UI thread longer than min(staleness_budget_ms, frame_timeout_ms) − blit_budget_ms.</li>
</ul>
</li>
<li>GPU (Metal/Vulkan):<ul>
<li>Use a fence/completion handler for offscreen completion; align waits to (vsync_deadline − ε).</li>
<li>If drawable acquisition fails or is late, skip present and set a status message; keep last-complete texture for the next tick.</li>
</ul>
</li>
<li>HTML:<ul>
<li>Policy ignored; DOM/CSS adapter always presents the latest complete output without waiting.</li>
</ul>
</li>
</ul>
</li>
<li>Configuration (presenter-owned; per view):<ul>
<li>windows/&lt;win&gt;/views/&lt;view&gt;/present/policy: enum { AlwaysFresh, PreferLatestCompleteWithBudget, AlwaysLatestComplete }</li>
<li>windows/&lt;win&gt;/views/&lt;view&gt;/present/params:<ul>
<li>staleness_budget_ms: float</li>
<li>max_age_frames: uint</li>
<li>frame_timeout_ms: float</li>
<li>vsync_align: bool</li>
<li>auto_render_on_present: bool</li>
</ul>
</li>
</ul>
</li>
<li>Per-call overrides (Builders):<ul>
<li>present_view(..., optional policyOverride, optional paramsOverride)</li>
</ul>
</li>
<li>Metrics (written by presenter to output/v1/common):<ul>
<li>presentedRevision: uint64</li>
<li>presentedAgeMs: double</li>
<li>presentedMode: string</li>
<li>stale: bool</li>
<li>waitMs: double</li>
<li>skippedPresent: bool (GPU)</li>
<li>drawableUnavailable: bool (GPU)</li>
</ul>
</li>
</ul>
<p>Pacing:</p><ul>
<li>Default: match the display device’s refresh/vsync for the window/surface (variable-refresh compatible)</li>
<li>HTML: <span class="tt">requestAnimationFrame</span></li>
<li>Headless/offscreen: on-demand; if continuous, timer-driven execution</li>
<li>Optional user cap: effective rate = min(display refresh, user cap)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
Hierarchical coordinates and layout</h1>
<ul>
<li>Authoring nodes in <span class="tt">scenes/&lt;sid&gt;/src/...</span> store local transforms, layout hints, and style</li>
<li>Snapshot builder computes:<ul>
<li>World transforms and bounds, z-order, batching, text glyph runs, image resolves, optional clip/stencil</li>
</ul>
</li>
<li>Snapshots store pre-baked draw commands for fast traversal, and the builder materializes the <span class="tt">DrawableBucket</span> staging arrays (flat, sorted/bucketed) corresponding to the published revision</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
DrawableBucket (no widget-tree traversal at render time)</h2>
<ul>
<li>Maintain a flat registry per scene for render-time iteration. In snapshot-driven mode, the builder populates arrays from <span class="tt">src</span> into <span class="tt">builds/&lt;revision&gt;</span>; publishing updates <span class="tt">current_revision</span></li>
<li>The renderer iterates contiguous arrays (or a few arrays by layer) for visibility/culling/sorting and issuing draw commands</li>
<li>TLAS/BLAS integration (software path tracer): the active <span class="tt">DrawableBucket</span> also materializes acceleration views per snapshot revision<ul>
<li>TLAS (instances): one record per drawable instance with world transform, <span class="tt">MaterialKey</span>, <span class="tt">pipelineFlags</span>, <span class="tt">layer</span>, and a reference to a deduplicated BLAS id derived from <span class="tt">drawRef</span></li>
<li>BLAS (unique geometry): table of unique geometry payloads (rects, rounded-rects, images, glyph meshes, paths, meshes) with optional per-face BVH; deduped across instances within a revision</li>
<li>Global surface-face BVH (when applicable) plus optional tetrahedral face adjacency for objects that carry tet connectivity; used by the tet-walk traversal in the software renderer</li>
<li>Publish emits TLAS/BLAS alongside the draw lists; the renderer latches both with the same <span class="tt">revision</span> and can choose raster (draw lists) or path tracing (TLAS→BLAS) without re-traversing the widget tree</li>
</ul>
</li>
</ul>
<p>Conceptual API (builder/widget-facing; not used by the renderer during a frame):</p><ul>
<li><span class="tt">register(widgetId) -&gt; handle</span></li>
<li><span class="tt">update(handle, {worldTransform, boundsLocal, material, layer, z, visibility, contentEpoch, transformEpoch, drawRef})</span></li>
<li><span class="tt">deregister(handle)</span></li>
<li><span class="tt">markDirty(handle, flags)</span></li>
</ul>
<p>Entry data (per drawable):</p><ul>
<li>Identifiers: <span class="tt">widgetId</span>, stable <span class="tt">handle</span></li>
<li>Transforms: local and world matrices; <span class="tt">transformEpoch</span></li>
<li>Bounds: local/world <span class="tt">BoundingSphere</span> and <span class="tt">BoundingBox</span> (AABB; optional OBB)</li>
<li>Draw metadata: <span class="tt">layer</span>, <span class="tt">z</span>, pipeline flags (opaque/alpha), <span class="tt">materialId</span></li>
<li>Draw commands: cached list pointer/handle + <span class="tt">contentEpoch</span> (or a prepare callback)</li>
<li>Visibility flag</li>
</ul>
<p>Double-buffering:</p><ul>
<li>Keep <span class="tt">staging</span> and <span class="tt">active</span> arrays per scene. The builder/authoring side updates <span class="tt">staging</span>; publishing a new snapshot atomically swaps <span class="tt">staging</span> to <span class="tt">active</span></li>
<li>The renderer latches <span class="tt">current_revision</span> at the start of a frame and reads only from the matching <span class="tt">active</span> arrays (no renderer-owned swaps)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
DrawableBucket — v1 contract</h3>
<p>Handles and IDs</p><ul>
<li>DrawableId: 64-bit stable identifier scoped to a scene; reused only after a generation bump</li>
<li>Generation: 32-bit counter incremented on reuse from a free-list; handle = (id, generation)</li>
<li>Free-list and tombstones: removals push ids into a free-list with tombstone count; reuse occurs only when generation++ and all references to the old revision are gone</li>
<li>Stability: within minor edits (no removal), drawables keep the same (id, generation); indices into SoA arrays may change between revisions, but ids do not</li>
<li>Mapping: authoring node id → 1..N drawables (e.g., text can expand to multiple drawables); record this mapping in snapshot metadata for diagnostics</li>
</ul>
<p>SoA layout (per snapshot revision)</p><ul>
<li>Arrays sized N drawables unless stated otherwise, tightly packed, immutable per revision:<ul>
<li>world: Transform[N]</li>
<li>boundsWorld: Bounds[N] (contains sphereWorld and boxWorld; boxWorld optional/empty if unused)</li>
<li>layer: uint32[N]</li>
<li>z: float[N] (quantized for sort keys; keep float for accuracy)</li>
<li>materialId: uint32[N]</li>
<li>pipelineFlags: uint32[N] (blend/clip/scissor/etc.)</li>
<li>visible: uint8[N] (0/1)</li>
<li>cmdOffset: uint32[N], cmdCount: uint32[N] into the command buffer</li>
</ul>
</li>
<li>Command buffer:<ul>
<li>cmdKinds: uint32[M] (enum per command)</li>
<li>cmdPayload: contiguous blob; per-kind fixed headers with offsets to variable-size payloads</li>
</ul>
</li>
<li>Optional index arrays (to avoid re-partitioning at render time):<ul>
<li>opaqueIndices[]: uint32[K_opaque] (pre-filtered by visibility and pipelineFlags)</li>
<li>alphaIndices[]: uint32[K_alpha]</li>
<li>per-layer indices: indices/layer/&lt;layer&gt;.bin if layer-local traversal is desired</li>
</ul>
</li>
<li>Alignment/versioning:<ul>
<li>All binary buffers are 64-bit aligned; headers include magic, version, endianness, counts, checksum</li>
</ul>
</li>
</ul>
<p>Sorting keys (render-time)</p><ul>
<li>Opaque: stable 64-bit key encouraging state locality then depth order<ul>
<li>Key(materialId ↑, pipelineFlags ↑, layer ↑, zQuant ↑) where zQuant is an implementation-defined monotone quantization of z</li>
</ul>
</li>
<li>Alpha: stable 64-bit key for painter’s algorithm within layers<ul>
<li>Key(layer ↑, zQuant ↓, materialId ↑, pipelineFlags ↑)</li>
</ul>
</li>
<li>Renderers may derive keys on the fly from SoA or use precomputed indices; key layout is not persisted across revisions (avoid baking it into the snapshot unless profiling says so)</li>
</ul>
<p>Draw command encoding (per drawable range)</p><ul>
<li>Multi-command drawables use [cmdOffset, cmdCount] into the command buffer; no pointers in persisted files</li>
<li>Command kinds (minimum):<ul>
<li>Rect, RoundedRect, Image, TextGlyphs, Path, Mesh</li>
</ul>
</li>
<li>Payloads:<ul>
<li>Rect/RoundedRect: geometry params, stroke/fill data</li>
<li>Image: atlas/texture id, UV rect, sampling flags</li>
<li>TextGlyphs: glyph-run id, per-glyph quad/atlas refs (pre-shaped); see text shaping cache notes in “Decision: Snapshot Builder (resolved)”</li>
<li>Path/Mesh: handle to geometry blob within the same command buffer</li>
</ul>
</li>
<li>Pipeline constraints:<ul>
<li>pipelineFlags define ordering barriers (e.g., clip groups) that prevent batching across incompatible states</li>
<li>Backends map commands 1:1 to software raster ops or to GPU vertex/index streams without walking the widget tree</li>
</ul>
</li>
</ul>
<p>Bounds and culling</p><ul>
<li>Target-specific requirements:<ul>
<li>2D software/GPU: BoundingSphere in world space (required); r_world = r_local × maxScale(world). AABB is optional for tighter viewport clipping.</li>
<li>3D ray tracing: BoundingSphere and per-drawable AABB are both required (TLAS/BLAS also carry AABBs for instances/geometry).</li>
<li>HTML: Neither sphere nor AABB is required by the renderer; authoring may omit bounds entirely.</li>
</ul>
</li>
<li>Per pass:<ul>
<li>Opaque: frustum/viewport cull then sort by opaque key; depth early-out favored</li>
<li>Alpha: frustum/viewport cull then back-to-front within layer</li>
</ul>
</li>
<li>Invariants:<ul>
<li>boundsWorld must enclose the drawable’s rendered pixels; violations are validation errors</li>
</ul>
</li>
</ul>
<p>Validations (loader/renderer)</p><ul>
<li>Array sizes equal N; indices within range; cmdOffset+cmdCount within M</li>
<li>(id, generation) uniqueness within snapshot; materialId/pipelineFlags known to pipeline</li>
<li>Optional: checksum of buffers; reject snapshot on mismatch and report to <span class="tt">output/v1/common/lastError</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
Snapshot layout (builds/&lt;revision&gt;)</h3>
<p>On-disk schema (per scene, per revision)</p><ul>
<li>Path: <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/bucket/</span><ul>
<li>drawables.bin — header (magic, version, counts, checksum) + SoA layout descriptor</li>
<li>transforms.bin — world transforms (N)</li>
<li>bounds.bin — Bounds[N] with sphereWorld always present; boxWorld optional</li>
<li>state.bin — layer[N], z[N], materialId[N], pipelineFlags[N], visible[N]</li>
<li>cmd-buffer.bin — cmdKinds[M] + payload blob</li>
<li>indices/opaque.bin — optional opaqueIndices[]</li>
<li>indices/alpha.bin — optional alphaIndices[]</li>
<li>indices/layer/*.bin — optional per-layer indices (see naming/format below)</li>
<li>meta.json — small JSON with revision, created_at, tool versions, and authoring→drawable id map summary</li>
<li>trace/tlas.bin — optional (software path tracer; instances carry AABBs)</li>
<li>trace/blas.bin — optional (software path tracer; geometry bounds/AABBs per BLAS)</li>
</ul>
</li>
<li>Binary headers:<ul>
<li>All *.bin start with: magic(4), version(u32), endianness(u8), reserved, counts/offsets(u64), checksum(u64)</li>
</ul>
</li>
<li>Per-layer index naming/format:<ul>
<li>File name: indices/layer/&lt;layer&gt;.bin where &lt;layer&gt; is the decimal text of the uint32 layer id (e.g., indices/layer/3.bin).</li>
<li>Encoding: little-endian, 64-bit aligned, with the same header (magic, version, endianness, counts/offsets, checksum).</li>
<li>Payload: a tightly packed array of uint32 indices into the drawables SoA for that layer; count is recorded in the header.</li>
</ul>
</li>
</ul>
<p>Publish/adopt/GC protocol</p><ul>
<li>Build writes to <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;.staging/*</span>, fsyncs, then atomically renames to <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;</span></li>
<li>Publish: atomically replace <span class="tt">scenes/&lt;sid&gt;/current_revision</span> with <span class="tt">&lt;rev&gt;</span></li>
<li>Renderer adopts by reading <span class="tt">current_revision</span> once per frame, mapping only <span class="tt">/&lt;rev&gt;/bucket/*</span> for that frame; the revision is pinned until frame end</li>
<li>GC: retain last K revisions (default 3) or T minutes (default 2m), whichever greater; never delete a pinned revision. Effective deletion cutoff = min(count-cutoff, time-cutoff, (minActiveLeaseRev - 1) if leases present). Never delete <span class="tt">current_revision</span> and always retain at least one revision.</li>
<li>Observability: renderer writes <span class="tt">frameIndex</span>, <span class="tt">revision</span>, <span class="tt">renderMs</span>, <span class="tt">lastError</span> under <span class="tt">targets/&lt;tid&gt;/output/v1/common/*</span> (see “Target keys (final)”)</li>
</ul>
<blockquote class="doxtable">
<p>Note — Revision allocation and error handling</p><ul>
<li>current_revision type and allocation: uint64, builder-assigned, strictly monotonically increasing per scene. Builders are responsible for generating new revisions; do not reuse old values.</li>
<li>Renderer behavior on read failure:<ul>
<li>If <span class="tt">scenes/&lt;sid&gt;/current_revision</span> is missing or unreadable, set a concise message in <span class="tt">targets/&lt;tid&gt;/output/v1/common/lastError</span> and skip the frame (or render a clear color) without crashing.</li>
<li>If <span class="tt">current_revision</span> points to a missing or partial <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/*</span>, also report a concise error and skip/clear; recover automatically when a valid revision is published.</li>
</ul>
</li>
<li>Adoption invariants: renderers latch <span class="tt">current_revision</span> once at frame start; all reads during the frame must come from that latched revision. </li>
</ul>
</blockquote>
<p>Cross-references</p><ul>
<li>Changes to publish/adopt, snapshot schema, or DrawableBucket invariants must be reflected in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> and associated tests</li>
<li>For output paths and timings, see “Target keys (final)” and “RenderSettings v1 (final)”; keep examples and path references stable</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
Transforms without per-frame traversal</h2>
<ul>
<li>Hierarchy is for authoring/layout; propagate transforms on change, not per frame:<ul>
<li><span class="tt">world = parentWorld * local</span></li>
<li>Update world bounds; bump <span class="tt">transformEpoch</span></li>
<li>Push updated entry to <span class="tt">DrawableBucket</span> <span class="tt">staging</span>; enqueue children updates if needed</li>
</ul>
</li>
<li>Result: render-time is O(n_visible) with no parent walks</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
Bounding volumes and culling</h2>
<ul>
<li>Target-specific bounds policy:<ul>
<li>2D software/GPU: store world <span class="tt">BoundingSphere</span> (required); <span class="tt">BoundingBox</span> (AABB) optional for tighter viewport clipping.</li>
<li>3D ray tracing: store both world <span class="tt">BoundingSphere</span> and per-drawable <span class="tt">BoundingBox</span> (AABB) (both required).</li>
<li>HTML: bounds not required by the renderer; may be omitted.</li>
<li>Sphere for broad-phase; <span class="tt">r_world = r_local * maxScale(world)</span></li>
</ul>
</li>
<li>Per view/camera:<ul>
<li>Frustum against spheres first; optional AABB vs viewport for 2D</li>
<li>Maintain buckets by layer/material to improve cache locality and reduce state changes</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
Draw command generation and caching</h2>
<ul>
<li>Widgets expose either:<ul>
<li>A stable <span class="tt">DrawCommands</span> object + <span class="tt">contentEpoch</span>, or</li>
<li>A prepare function to (re)build commands into a command allocator off-thread when <span class="tt">contentEpoch</span> changes</li>
</ul>
</li>
<li>Renderer requests commands only when <span class="tt">contentEpoch</span> differs from last seen (retained rendering). Software UI may still redraw every frame; dirty-rects can follow later. Command preparation should be off-thread to avoid blocking the render loop</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
Sorting and batching</h2>
<ul>
<li>Partition visible drawables:<ul>
<li>Opaque pass: sort by material/pipeline then by <span class="tt">z</span> (or depth); write-friendly for depth early-out</li>
<li>Alpha pass: back-to-front by <span class="tt">z</span> within layer</li>
</ul>
</li>
<li>Batch small UI ops (rects, rounded rects, images, glyph quads) into SoA buffers for software rasterization</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
Rendering pipeline specifics (v1)</h1>
<p>Overview</p><ul>
<li>The renderer consumes pre-baked commands and issues draw work with no widget-tree traversal. State changes are governed by <span class="tt">pipelineFlags</span> and <span class="tt">materialId</span>.</li>
<li>Two backends are targeted in v1: a software rasterizer (2D UI focus) and a GPU path (Metal first; Vulkan later). Both follow the same ordering and blending rules.</li>
</ul>
<p>Common state model and ordering</p><ul>
<li>Passes:<ul>
<li>Opaque pass: drawables with no blending (alpha == 1 or fully opaque material). Sorted by material → pipeline → z.</li>
<li>Alpha pass: drawables requiring blending. Sorted back-to-front by z within layer.</li>
</ul>
</li>
<li>Clipping:<ul>
<li>Clip rectangles: can be mapped to scissor on GPU and fast rect-mask in software.</li>
<li>Clip paths: require stencil/subpass on GPU; in software, draw into a coverage/stencil buffer.</li>
<li>Clip stack barriers are expressed in the command stream via <span class="tt">pipelineFlags</span> transitions; batching must not cross incompatible clip state.</li>
</ul>
</li>
<li>Color pipeline:<ul>
<li>Render-time is linear. Textures flagged as sRGB are linearized on sample. Framebuffer conversion to target color space (e.g., sRGB) happens on write-out.</li>
<li>Premultiplied alpha is the default format for images and intermediate surfaces.</li>
</ul>
</li>
</ul>
<p>Software renderer (2D UI)</p><ul>
<li>Primitives:<ul>
<li>Rect, RoundedRect: analytic edge coverage AA (1x sampling with coverage), optional multi-sample tiles for stress cases.</li>
<li>Path: even-odd or non-zero fill; analytic coverage preferred; stroke join/cap styles supported.</li>
<li>Image: bilinear sampling; optional mip selection; sRGB decoding on sample when flagged.</li>
<li>TextGlyphs: pre-shaped glyph quads; support grayscale and optional subpixel LCD rendering.</li>
</ul>
</li>
<li>Anti-aliasing:<ul>
<li>Analytic coverage AA at edges; gamma-aware compositing. LCD subpixel AA available when <span class="tt">TextLCD</span> is set and background constraints allow.</li>
</ul>
</li>
<li>Blending:<ul>
<li>Default Porter-Duff SrcOver with premultiplied alpha. Optional blend modes (Multiply, Screen) can be added via <span class="tt">BlendMode</span> bits.</li>
</ul>
</li>
<li>Clipping:<ul>
<li>ClipRect: SIMD rect mask per tile.</li>
<li>ClipPath: software stencil/coverage buffer; commands between clip begin/end respect the active mask.</li>
</ul>
</li>
<li>Color management:<ul>
<li>Linear working space. Inputs decode per asset flags; outputs encode to target color space (e.g., sRGB) with optional dithering for 8-bit.</li>
<li>DisplayP3 handling: when assets declare DisplayP3 or targets request DisplayP3, convert between working linear space and the target/display space via ICC or well-defined matrix transforms. For software paths, encode to sRGB or DisplayP3 at store-time; for GPU, use appropriate formats and perform conversion on write-out. Avoid double conversion when using sRGB/linear attachments.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
Color management (v1)</h2>
<p>Policy</p><ul>
<li>Working space: linear light for all shading and blending.</li>
<li>Framebuffer encoding: default sRGB 8-bit with linear→sRGB encode on write; optional linear FP formats (e.g., RGBA16F/32F) for HDR.</li>
<li>Alpha: premultiplied everywhere by default.</li>
</ul>
<p>Inputs</p><ul>
<li>Solid colors are authored in sRGB; convert to linear at material upload.</li>
<li>Images: honor embedded ICC when present; otherwise assume sRGB. Convert to the working space at decode, or sample from sRGB textures with automatic decode-to-linear.</li>
<li>Text/MSDF: decode in linear; blend premultiplied in linear. LCD subpixel only when the target is sRGB8 and transforms preserve subpixel geometry.</li>
</ul>
<p>Flags and semantics</p><ul>
<li>SrgbFramebuffer: target expects sRGB-encoded output; encode on write-out; blending remains in linear.</li>
<li>LinearFramebuffer: target is linear (e.g., FP16/FP32); do not sRGB-encode on write.</li>
<li>UnpremultipliedSrc: source is straight alpha; convert to premultiplied in the draw path before blending; discourage use for general content.</li>
</ul>
<p>Backend notes</p><ul>
<li>Software: composite in linear float; encode to target color space on store; optional dithering for 8-bit.</li>
<li>Metal/Vulkan: prefer sRGB formats with automatic decode-to-linear sampling; select FP formats for HDR paths.</li>
</ul>
<p>Defaults and tests</p><ul>
<li>Defaults: sRGB working space, srgb8 framebuffer, premultiplied alpha.</li>
<li>Tests: golden semi-transparent composites, software vs GPU parity, MSDF edge quality and LCD downgrade behavior.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
Progressive present (software, non-buffered)</h2>
<p>Overview</p><ul>
<li>Low-latency mode for the software path using a single shared framebuffer with progressive tile updates.</li>
<li>Presenter blits only tile-aligned dirty regions that are consistent; no full-frame commit is required.</li>
</ul>
<p>Shared framebuffer and tiles</p><ul>
<li>One CPU pixel buffer sized to the target (physical pixels; respect dpi_scale). Pixel format: RGBA8 premultiplied alpha with sRGB encoding on store (linear working space → sRGB on write-out). The presenter blits bytes as-is (no further color conversion).</li>
<li>Fixed tile size (e.g., 32×32 or 64×64). Per-tile seqlock metadata:<ul>
<li>seq: uint32 (even=stable, odd=being-written)</li>
<li>pass: enum { None, OpaqueDone, AlphaDone }</li>
<li>epoch: uint64 (increments each time a tile reaches AlphaDone)</li>
</ul>
</li>
</ul>
<p>Renderer protocol per tile</p><ul>
<li>Writer atomics: <span class="tt">seq</span> is a std::atomic&lt;uint32_t&gt;. Begin: <span class="tt">seq.fetch_add(1)</span> to odd. Write tile pixels. Publish with <span class="tt">std::atomic_thread_fence(std::memory_order_release)</span>. End: <span class="tt">seq.fetch_add(1)</span> to even.</li>
<li>Publish pass/epoch atomically: <span class="tt">pass.store(OpaqueDone|AlphaDone, std::memory_order_release)</span> only after the corresponding tile pixels are visible; <span class="tt">epoch.store(newEpoch, std::memory_order_release)</span> when a tile reaches AlphaDone. Readers use <span class="tt">memory_order_acquire</span> on <span class="tt">seq/pass/epoch</span>. If <span class="tt">seq</span> changes between pre- and post-copy reads, discard that tile copy.</li>
</ul>
<p>Dirty region feed</p><ul>
<li>Renderer enqueues tile-aligned dirty rects to a lock-free queue.</li>
<li>Presenter drains and coalesces rects on the UI thread; for each tile:<ul>
<li>Read seq; if odd, skip; if even, copy; re-check seq after copy; if changed, discard that tile copy (avoid tearing).</li>
</ul>
</li>
<li>Use platform partial redraw APIs (e.g., setNeedsDisplayInRect) to schedule partial blits.</li>
</ul>
<p>Two-phase progressive draw (optional)</p><ul>
<li>Present opaque-complete tiles immediately for quick stabilization; blend alpha tiles progressively as they complete.</li>
</ul>
<p>Input-priority micro-updates</p><ul>
<li>Pointer interactions enqueue high-priority dirty regions around the cursor/control (e.g., 64–128 px neighborhood) to maintain perceived low latency.</li>
</ul>
<p>Policy interaction</p><ul>
<li>PreferProgressive (software-only) can be selected per view or auto-chosen when budget is tight.</li>
<li>Mapping:<ul>
<li>AlwaysLatestComplete: buffered; if presentedAgeMs &gt; staleness_budget_ms, temporarily switch to progressive until stabilized.</li>
<li>PreferLatestCompleteWithBudget (default): progressive for late tiles beyond budget; otherwise buffered.</li>
<li>AlwaysFresh: prefer buffered; progressive only if a full frame cannot meet the deadline.</li>
</ul>
</li>
<li>Settings (per view)</li>
<li>windows/&lt;win&gt;/views/&lt;view&gt;/present/policy: may be PreferProgressive on software targets</li>
<li>windows/&lt;win&gt;/views/&lt;view&gt;/present/params.software.progressive:<ul>
<li>enable: bool (default true)</li>
<li>tile_size: int (32|64)</li>
<li>alpha_two_phase: bool (default true)</li>
<li>max_dirty_per_vsync: int (coalescing cap)</li>
</ul>
</li>
<li>Pacing note: user pacing caps (user_cap_fps) do not change <span class="tt">RenderSettings.time.delta_ms</span> beyond the actual elapsed time between frames; if frames are skipped due to pacing, <span class="tt">delta_ms</span> still reflects real elapsed time so animations advance correctly.</li>
</ul>
<p>Metrics (software presenter)</p><ul>
<li>progressiveTilesCopied, progressiveRectsCoalesced, progressiveSkipOddSeq, progressiveRecopyAfterSeqChange</li>
<li>presentLatencyMs (min/avg/max), copyBytesPerSecond</li>
</ul>
<p>Safety and correctness</p><ul>
<li>Seqlock per tile avoids locks and prevents torn reads.</li>
<li>Presenter never blocks the UI thread on renderer work; cap coalesced rects per vsync to avoid starvation.</li>
<li>macOS note: shared buffer → Core Graphics blits of dirty rects; IOSurface/Core Animation can be considered later to reduce copies.</li>
</ul>
<p>GPU renderer (Metal/Vulkan)</p><ul>
<li>Targets:<ul>
<li>Offscreen texture/image matching the target descriptor (size/format/color space). For sRGB targets, enable framebuffer sRGB encode or explicit conversion in shader.</li>
</ul>
</li>
<li>Pipelines:<ul>
<li>Pipeline state keyed by {program, blend, clip mode, sample count, color space/sRGB encode, premultiplied, debug flags}.</li>
<li>For 2D UI, depth test off; depth write off; cull mode none. Optional depth for 3D overlays later.</li>
</ul>
</li>
<li>Vertex formats:<ul>
<li>Rects/Images/TextGlyphs: instanced quads with per-instance attributes (transform/z/layer/material/UV).</li>
<li>Path: tessellated fills/strokes or signed-distance fields; choice is backend-specific and off the command encoding.</li>
</ul>
</li>
<li>Clipping:<ul>
<li>ClipRect → scissor. ClipPath → stencil (separate pass to populate, then draw with ref test).</li>
<li>Clip stack changes introduce ordering barriers; do not batch across incompatible clip state.</li>
</ul>
</li>
<li>Batching:<ul>
<li>Sort opaque by (materialId, pipelineFlags, zQuant), alpha back-to-front; submit in batches grouped by the active pipeline state.</li>
</ul>
</li>
<li>Synchronization:<ul>
<li>Target-local synchronization only in the render loop. Presentation is marshaled by the presenter on the UI thread.</li>
</ul>
</li>
</ul>
<p>pipelineFlags mapping (v1)</p><ul>
<li>Flags classify drawables for pass selection and encode per-pass state. Multiple bits may be combined; batching must respect incompatible combinations.</li>
<li>Classification:<ul>
<li>Opaque vs Alpha is derived from flags: <span class="tt">AlphaBlend</span> implies alpha pass; absence implies opaque pass.</li>
<li>Clip presence selects stencil/scissor paths; <span class="tt">ClipPath</span> requires stencil-capable pipelines.</li>
</ul>
</li>
<li>Invariants:<ul>
<li>When <span class="tt">AlphaBlend</span> is set without <span class="tt">UnpremultipliedSrc</span>, inputs are treated as premultiplied alpha.</li>
<li><span class="tt">TextLCD</span> implies background constraints (no rotation/scaling that breaks subpixel layout); otherwise render as grayscale text.</li>
</ul>
</li>
</ul>
<p>Example (non-exhaustive) flags </p><div class="fragment"><div class="line"><span class="keyword">enum</span> PipelineFlags : uint32_t {</div>
<div class="line">  <span class="comment">// Pass and blend</span></div>
<div class="line">  Opaque               = 0x00000001, <span class="comment">// hint; absence of AlphaBlend implies opaque</span></div>
<div class="line">  AlphaBlend           = 0x00000002, <span class="comment">// src-over premultiplied unless UnpremultipliedSrc is set</span></div>
<div class="line">  UnpremultipliedSrc   = 0x00000004, <span class="comment">// request conversion to premultiplied before blend</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clipping</span></div>
<div class="line">  ClipRect             = 0x00000010,</div>
<div class="line">  ClipPath             = 0x00000020,</div>
<div class="line">  ScissorEnabled       = 0x00000040, <span class="comment">// GPU-only optimization hint (maps from ClipRect when possible)</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Text rendering</span></div>
<div class="line">  TextLCD              = 0x00000100, <span class="comment">// subpixel AA for text</span></div>
<div class="line">  TextNoSubpixel       = 0x00000200, <span class="comment">// force grayscale AA</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Color pipeline</span></div>
<div class="line">  SrgbFramebuffer      = 0x00001000, <span class="comment">// target expects sRGB encode on write-out</span></div>
<div class="line">  LinearFramebuffer    = 0x00002000, <span class="comment">// target expects linear; convert assets accordingly</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Debug/diagnostics</span></div>
<div class="line">  DebugOverdraw        = 0x00010000,</div>
<div class="line">  DebugWireframe       = 0x00020000,</div>
<div class="line">};</div>
</div><!-- fragment --><p>Notes</p><ul>
<li>Materials own shader program and textures; <span class="tt">materialId</span> selects programs and resource bindings. <span class="tt">pipelineFlags</span> selects pipeline variants and state bits.</li>
<li>If this section changes (blend behavior, flags, or color pipeline), update examples and tests, and reflect any core behavior impacts in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
Culling and spatial acceleration (v1)</h1>
<p>Target policies</p><ul>
<li>2D software/GPU:<ul>
<li>Broad-phase: world-space sphere vs frustum/viewport (required).</li>
<li>Narrow-phase: optional world-space AABB vs viewport for tighter rejection.</li>
</ul>
</li>
<li>3D ray tracing:<ul>
<li>Required per-drawable BoundingSphere and AABB for culling and correctness.</li>
<li>TLAS/BLAS also carry AABBs (instances and geometry) and are used for traversal; per-drawable tests happen before instance-level traversal when beneficial.</li>
</ul>
</li>
<li>HTML:<ul>
<li>Bounds not required by the renderer; culling disabled; rely on DOM layout rules in adapters.</li>
</ul>
</li>
</ul>
<p>Per-pass algorithm</p><ul>
<li>Opaque pass:<ul>
<li>Sphere cull → optional AABB viewport clip (2D) → sort by opaque key (materialId, pipelineFlags, layer, zQuant) → draw.</li>
</ul>
</li>
<li>Alpha pass:<ul>
<li>Sphere cull → optional AABB viewport clip (2D) → sort back-to-front within layer → draw.</li>
</ul>
</li>
</ul>
<p>Optional acceleration indices (deferred by default)</p><ul>
<li>Precomputed index buffers may be emitted by the builder per revision:<ul>
<li>opaqueIndices[], alphaIndices[], indices/layer/&lt;layer&gt;.bin.</li>
</ul>
</li>
<li>Enable heuristics:<ul>
<li>N ≥ 50k drawables and cull rejection ≥ 60%, or stable camera with repeated views where indices amortize sort cost.</li>
</ul>
</li>
<li>For 3D/path tracing, rely on TLAS/BLAS for traversal; no per-drawable spatial trees in MVP.</li>
</ul>
<p>Metrics and observability</p><ul>
<li>Record per-frame:<ul>
<li>totalDrawables, culledBySphere, culledByAABB, visibleAfterCull.</li>
<li>opaqueCount, alphaCount, batchCount, sortMs, cullMs.</li>
</ul>
</li>
<li>Surface target writes high-level timings to <span class="tt">output/v1/common/*</span>; renderer-specific counters may be exposed under a debug path.</li>
</ul>
<p>Future work</p><ul>
<li>Add opt-in grids/BVH for 2D when N is large and camera stable.</li>
<li>Consider OBBs or oriented bounds where rotation precision matters.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
Coordinate systems and cameras (v1)</h1>
<p>Spaces</p><ul>
<li>Local space: per-node transform space used during authoring/layout.</li>
<li>World space: accumulated parent→child transforms; snapshot builder writes world transforms for render.</li>
<li>View space: world transformed by the active camera.</li>
<li>Clip space: normalized device coordinates after projection.</li>
<li>Screen space: pixel coordinates in the render target; y-down for UI.</li>
</ul>
<p>Units and DPI</p><ul>
<li>RenderSettings.surface.size_px gives framebuffer size in physical pixels; dpi_scale indicates device pixel ratio.</li>
<li>UI logical units are device-independent pixels (dp). World-space units for 2D UI equal logical px; physical px = logical px × dpi_scale.</li>
</ul>
<p>Orthographic UI defaults (2D)</p><ul>
<li>Projection: Orthographic with y-down. Screen origin at top-left of the target; +X right, +Y down. Matrices are column-major; vectors are column vectors; compose with post-multiply (world = parentWorld * local; clip = P*V*M*pos).</li>
<li>Default world-to-screen mapping: x_world,y_world interpreted as logical pixels; z defaults to 0 unless specified.</li>
<li>Z-ordering for 2D:<ul>
<li>Primary ordering by <span class="tt">layer</span> (ascending).</li>
<li>Within a layer, z is used for sorting: opaque pass sorts z ascending; alpha pass sorts z descending (painter’s algorithm).</li>
<li>Ties are broken by stable <span class="tt">DrawableId</span> to ensure determinism.</li>
</ul>
</li>
<li>Depth buffer is disabled in the 2D UI pipeline; z participates only in sorting, not depth testing.</li>
</ul>
<p>3D conventions (ray tracing and future 3D overlays)</p><ul>
<li>World: right-handed. +X right, +Y up, camera looks toward −Z by default.</li>
<li>Camera:<ul>
<li>Projection: <span class="tt">Orthographic</span> (2D UI) or <span class="tt">Perspective</span> (3D).</li>
<li>Parameters from RenderSettings.camera: zNear, zFar in view space; must satisfy zNear &lt; zFar.</li>
</ul>
</li>
<li>Z semantics:<ul>
<li>Opaque: sort by increasing camera-space depth (consistent with z ascending in our sort key).</li>
<li>Alpha: sort back-to-front by camera-space depth within layer.</li>
<li>When depth testing is enabled (future 3D overlays), sorting may be reduced to state-locality plus depth test.</li>
</ul>
</li>
</ul>
<p>Cameras in RenderSettings</p><ul>
<li>RenderSettings v1 carries an optional <span class="tt">camera</span>:<ul>
<li><span class="tt">Projection { Orthographic, Perspective }</span></li>
<li><span class="tt">zNear: float</span>, <span class="tt">zFar: float</span></li>
</ul>
</li>
<li>UI default if camera is absent:<ul>
<li>Orthographic y-down mapping sized to the surface in logical pixels.</li>
<li>zNear/zFar default to [-1, +1] in view space for sorting; depth test remains off.</li>
</ul>
</li>
</ul>
<p>Cross-references</p><ul>
<li>See “RenderSettings v1 (final)” for camera fields and invariants; “Rendering pipeline specifics (v1)” for pass sorting and blending rules.</li>
<li>Changes that affect coordinate systems or camera semantics should be reflected in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
Input, hit testing, and focus (v1)</h1>
<p>Coordinate mapping</p><ul>
<li>Event spaces:<ul>
<li>OS/window coords → screen space (pixels in the render target; y-down for UI)</li>
<li>Screen → view space via inverse projection (orthographic for UI)</li>
<li>View → world via inverse camera/view transform</li>
<li>World → local (optional) via inverse node transform for precise tests</li>
</ul>
</li>
<li>DPI:<ul>
<li>Convert device coordinates using <span class="tt">RenderSettings.surface.dpi_scale</span> so hit tests operate in logical pixels for 2D UI</li>
</ul>
</li>
<li>Camera:<ul>
<li>If <span class="tt">RenderSettings.camera</span> is absent, use orthographic y-down mapping sized to the surface (see “Coordinate systems and cameras (v1)”)</li>
</ul>
</li>
</ul>
<p>Hit testing (DrawableBucket-driven)</p><ul>
<li>Snapshot consistency:<ul>
<li>Latch <span class="tt">scenes/&lt;sid&gt;/current_revision</span> at event time; use that revision’s <span class="tt">DrawableBucket</span> for the entire hit test</li>
</ul>
</li>
<li>Ordering:<ul>
<li>Evaluate candidates by descending priority: higher <span class="tt">layer</span> first; within a layer, sort by z descending (painter’s order). Use stable <span class="tt">DrawableId</span> to break ties deterministically</li>
</ul>
</li>
<li>Broad/narrow phases:<ul>
<li>Broad: test point or pick ray against <span class="tt">BoundingSphere</span> (required) to prune</li>
<li>Narrow (2D UI):<ul>
<li>Optional AABB vs viewport or point-in-rect test for tighter rejection</li>
<li>Exact shape test when needed:<ul>
<li>Rect/RoundedRect: analytic edge test</li>
<li>Image: alpha-threshold test (premultiplied) with UV lookup; respect clip</li>
<li>TextGlyphs: quad bounds; optional glyph coverage test per glyph</li>
<li>Path: winding/even-odd test against path geometry</li>
</ul>
</li>
<li>Respect active clip stack (rect or path) when present; clipped drawables do not receive hits outside the clip</li>
</ul>
</li>
<li>3D ray tracing:<ul>
<li>Build a pick ray in view space; test per-drawable AABB (required for 3D) before invoking TLAS/BLAS traversal for precise intersections when applicable</li>
</ul>
</li>
</ul>
</li>
<li>Results:<ul>
<li>Return the topmost hit target plus an ordered list of ancestors for routing; include local/world coords, uv (if image/text), and modifiers</li>
</ul>
</li>
</ul>
<p>Event routing</p><ul>
<li>Phases:<ul>
<li>Capture: root → target ancestor chain</li>
<li>Target: target receives the event</li>
<li>Bubble: target ancestor chain → root</li>
</ul>
</li>
<li>Controls:<ul>
<li>stopPropagation: halts further capture/bubble</li>
<li>preventDefault: signals default behavior should not run (app-defined)</li>
</ul>
</li>
<li>Common events:<ul>
<li>Pointer: down/up/move/enter/leave/cancel, wheel, button, modifiers</li>
<li>Keyboard: keydown/keyup/text input, repeat flags, modifiers</li>
<li>Touch: start/move/end/cancel with contact ids</li>
</ul>
</li>
</ul>
<p>Focus and IME</p><ul>
<li>Focus model:<ul>
<li>One focused element per scene; store focused <span class="tt">DrawableId</span> (or authoring node id) and revision</li>
<li>Focus traversal: next/prev order is app-defined; default traversal by DOM-like preorder if unspecified</li>
</ul>
</li>
<li>Text input/IME:<ul>
<li>Composition events are delivered to the focused text-editable element</li>
<li>Caret and selection rectangles map from local to screen for IME candidate windows; update on transform/content changes</li>
</ul>
</li>
<li>Accessibility hooks (forward-looking):<ul>
<li>Expose semantic roles and focus order; coordinate with platform accessibility APIs (not in MVP)</li>
</ul>
</li>
</ul>
<p>Threading and staleness</p><ul>
<li>Event delivery targets the authoring tree; the snapshot builder publishes revisions asynchronously</li>
<li>Hit testing uses the latest available revision; if a new revision lands mid-routing, continue routing using the latched revision to stay consistent for that event</li>
<li>Presenters may show last-complete outputs while handling input; see staleness policy in Frame orchestration</li>
</ul>
<p>HTML adapter differences</p><ul>
<li>HTML targets delegate hit testing and focus to the browser’s DOM</li>
<li>The adapter maps DOM events to scene events where applicable; geometry-level tests are not run in the renderer for HTML targets</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
GPU backend architecture (v1)</h1>
<p>Scope</p><ul>
<li>Applies to GPU targets (Metal first; Vulkan later). Focuses on device/queue ownership, thread affinity, synchronization, resources/reconfigure, command encoding, pipeline caches, color formats, device loss, and observability.</li>
</ul>
<p>Device and queue ownership</p><ul>
<li>Each renderer instance owns its GPU device/context and one or more queues:<ul>
<li>Metal: MTLDevice + MTLCommandQueue (one graphics queue per renderer; optional transfer-only queue in future)</li>
<li>Vulkan: VkDevice + graphics queue (and present queue when applicable); command pools are per-thread</li>
</ul>
</li>
<li>Surfaces/textures render offscreen; windows targets render directly to the window drawable/swapchain. Presenters handle acquisition and present on the UI/present thread (e.g., CAMetalLayer).</li>
</ul>
<p>Thread affinity and submission</p><ul>
<li>Command encoding happens on a renderer worker thread per target (no UI thread dependency)</li>
<li>Metal objects with thread affinity (e.g., CAMetalDrawable) are handled by the presenter. For surfaces/textures, renderers consume offscreen textures/images; for windows targets, the presenter acquires the drawable and the renderer encodes directly against it before the presenter submits/presents on the UI thread.</li>
<li>Vulkan command pools are thread-bound; allocate and reset per-thread pools</li>
</ul>
<p>Synchronization model</p><ul>
<li>Per-target synchronization only; no global renderer lock</li>
<li>CPU side:<ul>
<li>Short mutex to read <span class="tt">settings</span> at frame start; snapshot read is lock-free after latching <span class="tt">current_revision</span></li>
</ul>
</li>
<li>GPU side:<ul>
<li>One command buffer per frame per target (or a small ring); fences/semaphores wait for completion before resource reuse</li>
<li>Avoid cross-target synchronization; each target’s timeline is independent</li>
</ul>
</li>
<li>Present:<ul>
<li>Software: blit framebuffer to window on UI thread (unchanged)</li>
<li>Metal:<ul>
<li>Offscreen targets (surfaces/textures): presenter draws a textured quad sampling the offscreen texture into CAMetalDrawable</li>
<li>Windows targets: renderer renders directly into CAMetalDrawable acquired by the presenter; presenter calls presentDrawable on the UI thread</li>
</ul>
</li>
<li>Vulkan:<ul>
<li>Offscreen targets: presenter composites the offscreen image/quad into the view’s drawable</li>
<li>Windows targets: renderer renders directly into the acquired swapchain image; presenter queues vkQueuePresentKHR and handles SUBOPTIMAL/OUT_OF_DATE by recreating the swapchain</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Resources and reconfigure</p><ul>
<li>Target descriptor changes (<span class="tt">desc</span>) trigger reconfigure:<ul>
<li>Recreate offscreen textures/images with new size/format/color space</li>
<li>Rebuild or rebind framebuffers/render passes as needed</li>
</ul>
</li>
<li>Resources:<ul>
<li>Immutable assets (images, glyph atlases) are cached per renderer; lifetime spans multiple frames</li>
<li>Per-frame: transient buffers for instance data and uniform blocks; ring-allocated to avoid stalls</li>
</ul>
</li>
</ul>
<p>Command encoding (per backend)</p><ul>
<li>Metal:<ul>
<li>One MTLCommandBuffer per frame; one MTLRenderCommandEncoder for opaque, one for alpha (or separate passes when stencil is needed)</li>
<li>ClipRect → scissor; ClipPath → stencil prepass and test; bind materials (pipeline state + textures + constants)</li>
</ul>
</li>
<li>Vulkan:<ul>
<li>One primary command buffer per frame; subpasses when stencil is required</li>
<li>Dynamic states for scissor/viewport; descriptor sets for materials; pipeline barriers confined within the frame’s scope</li>
</ul>
</li>
</ul>
<p>Pipeline caches</p><ul>
<li>Pipeline state keyed by {program/material, blend mode, clip mode, sample count, color space encode, premultiplied, debug flags}</li>
<li>Cache lookup per batch; LRU eviction for rarely used variants</li>
<li>Warmup common pipelines at startup to reduce first-frame stutter</li>
</ul>
<p>Color formats and spaces</p><ul>
<li>Framebuffer formats:<ul>
<li>sRGB: prefer SRGB8A8 for UI when available; enable automatic sRGB encode on write-out</li>
<li>Linear: RGBA8 for linear targets; explicit encode when presenting to sRGB displays</li>
</ul>
</li>
<li>Textures:<ul>
<li>Respect asset color space flags; sRGB textures sampled with automatic decode; linear textures sampled as-is</li>
</ul>
</li>
<li>Premultiplied alpha as default for images/intermediates; <span class="tt">UnpremultipliedSrc</span> flag triggers conversion on sample/blend</li>
</ul>
<p>Device loss and recovery</p><ul>
<li>Detect device loss or drawable acquisition failures; set <span class="tt">status/device_lost</span> and write <span class="tt">lastError</span></li>
<li>Attempt reinitialize-on-demand for subsequent frames; if recovery fails, keep reporting error and skip rendering work for the target</li>
</ul>
<p>Observability</p><ul>
<li>Per-frame metrics written to <span class="tt">output/v1/common/*</span>: <span class="tt">frameIndex</span>, <span class="tt">revision</span>, <span class="tt">renderMs</span>, <span class="tt">lastError</span></li>
<li>Optional GPU counters (backend-specific) may be exposed under a debug subtree for diagnostics; avoid mandatory dependencies on profiling APIs</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Minimal types (sketch)</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Transform { <span class="keywordtype">float</span> m[16]; }; <span class="comment">// Column-major 4x4; column vectors; post-multiply (world = parentWorld * local; clip = P*V*M*pos). 3D; 2D via orthographic with z=0</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>BoundingSphere { <span class="keywordtype">float</span> cx, cy, cz, r; };</div>
<div class="line"><span class="keyword">struct </span>BoundingBox { <span class="keywordtype">float</span> min[3], max[3]; };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Bounds {</div>
<div class="line">  <span class="comment">// Runtime: sphereWorld is required; boxWorld is optional (hasBoxWorld=false when omitted).</span></div>
<div class="line">  <span class="comment">// Authoring-only locals (sphereLocal/boxLocal) are not persisted in runtime snapshots.</span></div>
<div class="line">  BoundingSphere sphereWorld;</div>
<div class="line">  <span class="keywordtype">bool</span>           hasBoxWorld;</div>
<div class="line">  BoundingBox    boxWorld; <span class="comment">// only valid if hasBoxWorld</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DrawCommand {</div>
<div class="line">  uint32_t type;                  <span class="comment">// Rect, RoundedRect, Image, TextGlyphs, Mesh, Path, ...</span></div>
<div class="line">  uint32_t materialId;</div>
<div class="line">  uint32_t pipelineFlags;         <span class="comment">// opaque/alpha, blend, etc.</span></div>
<div class="line">  uint32_t vertexOffset, vertexCount; <span class="comment">// or payload handle</span></div>
<div class="line">  <span class="comment">// software-specific payload as needed</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DrawableEntry {</div>
<div class="line">  uint64_t          id;</div>
<div class="line">  Transform         world;</div>
<div class="line">  Bounds            bounds;</div>
<div class="line">  uint32_t          layer;</div>
<div class="line">  <span class="keywordtype">float</span>             z;</div>
<div class="line">  uint32_t          pipelineFlags;</div>
<div class="line">  uint32_t          materialId;</div>
<div class="line">  uint64_t          transformEpoch;</div>
<div class="line">  uint64_t          contentEpoch;</div>
<div class="line">  <span class="keyword">const</span> DrawCommand* cmds;</div>
<div class="line">  uint32_t          cmdCount;</div>
<div class="line">  <span class="keywordtype">bool</span>              visible;</div>
<div class="line">};</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
Scene authoring model (C++ API)</h1>
<ul>
<li>Authoring is via typed C++ helpers; no JSON authoring</li>
<li>Scene content lives under <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;/src/...</span>; a commit barrier can signal atomic batches</li>
<li>Minimal node kinds: <span class="tt">Container</span>, <span class="tt">Rect</span>, <span class="tt">Text</span>, <span class="tt">Image</span></li>
<li>Transforms: 2D TRS per node (position, rotationDeg, scale), relative to parent</li>
<li>Layout: <span class="tt">Absolute</span> and <span class="tt">Stack</span> (vertical/horizontal) in v1</li>
<li>Style: opacity (inherits multiplicatively), fill/stroke, strokeWidth, cornerRadius, <span class="tt">clip</span> flag (on containers)</li>
<li>Z-order: by <span class="tt">(zIndex asc, then children[] order)</span> within a parent. Mapping to runtime: the snapshot builder assigns <span class="tt">layer</span> from the nearest layer-bearing ancestor (default 0) and derives per-drawable <span class="tt">z</span> from authoring <span class="tt">zIndex</span> within that layer; ties are broken by stable <span class="tt">DrawableId</span> for determinism.</li>
</ul>
<p>Preferred authoring pattern: nested PathSpace mount</p><ul>
<li>Build the scene in a temporary, unmounted <span class="tt">PathSpace</span>:<ul>
<li>Insert nodes under its <span class="tt">/src/...</span> subtree (typed inserts)</li>
<li>Set <span class="tt">/src/nodes/root</span> and <span class="tt">/src/root</span> when ready</li>
</ul>
</li>
<li>Atomically publish by mounting:<ul>
<li>Insert the local <span class="tt">PathSpace</span> into the main <span class="tt">PathSpace</span> at <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;</span> using <span class="tt">std::unique_ptr&lt;PathSpace&gt;</span></li>
<li>A single notify wakes waiters (e.g., the snapshot builder)</li>
</ul>
</li>
</ul>
<p>Example: atomic publish via nested PathSpace </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_s_p_1_1_path_space.html">SP::PathSpace</a> ps;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build scene in a local (unmounted) PathSpace</span></div>
<div class="line"><span class="keyword">auto</span> local = std::make_unique&lt;SP::PathSpace&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Author nodes under the local space&#39;s /src subtree (typed inserts)</span></div>
<div class="line">local-&gt;insert(<span class="stringliteral">&quot;/src/nodes/card&quot;</span>, RectNode{</div>
<div class="line">  .style  = Style{ .fill = Color{0.29f,0.56f,0.89f,1}, .cornerRadius = 12 },</div>
<div class="line">  .layout = Absolute{ .x = 40, .y = 30, .w = 200, .h = 120 }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">local-&gt;insert(<span class="stringliteral">&quot;/src/nodes/title&quot;</span>, TextNode{</div>
<div class="line">  .text   = TextProps{ .content = <span class="stringliteral">&quot;Hello, PathSpace!&quot;</span>, .font = <span class="stringliteral">&quot;16px system-ui&quot;</span> },</div>
<div class="line">  .layout = Absolute{ .x = 56, .y = 70 } <span class="comment">// auto size for text</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">local-&gt;insert(<span class="stringliteral">&quot;/src/nodes/root&quot;</span>, ContainerNode{</div>
<div class="line">  .layout   = Absolute{ .x = 0, .y = 0, .w = 800, .h = 600 },</div>
<div class="line">  .children = std::vector&lt;NodeId&gt;{ id(<span class="stringliteral">&quot;card&quot;</span>), id(<span class="stringliteral">&quot;title&quot;</span>) }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the root reference within the local space</span></div>
<div class="line">local-&gt;insert(<span class="stringliteral">&quot;/src/root&quot;</span>, std::string{<span class="stringliteral">&quot;root&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Atomically publish the completed scene by mounting it</span></div>
<div class="line">ps.<a class="code hl_function" href="class_s_p_1_1_path_space_base.html#a7f160bb41b90202c97f3581612e22001">insert</a>(<span class="stringliteral">&quot;apps/demo/scenes/home&quot;</span>, std::move(local));</div>
<div class="ttc" id="aclass_s_p_1_1_path_space_base_html_a7f160bb41b90202c97f3581612e22001"><div class="ttname"><a href="class_s_p_1_1_path_space_base.html#a7f160bb41b90202c97f3581612e22001">SP::PathSpaceBase::insert</a></div><div class="ttdeci">auto insert(S const &amp;pathIn, DataType &amp;&amp;data, In const &amp;options={}) -&gt; InsertReturn</div><div class="ttdef"><b>Definition</b> PathSpaceBase.hpp:51</div></div>
<div class="ttc" id="aclass_s_p_1_1_path_space_html"><div class="ttname"><a href="class_s_p_1_1_path_space.html">SP::PathSpace</a></div><div class="ttdef"><b>Definition</b> PathSpace.hpp:23</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
Stack layout (v1)</h2>
<p>Fields:</p><ul>
<li><span class="tt">axis</span>: Vertical (top→bottom) or Horizontal (left→right)</li>
<li><span class="tt">spacing</span>: gap between adjacent children (main axis)</li>
<li><span class="tt">alignMain</span>: <span class="tt">Start | Center | End</span> — pack sequence if there’s slack</li>
<li><span class="tt">alignCross</span>: <span class="tt">Start | Center | End | Stretch</span> — cross-axis placement/sizing</li>
<li>Per-child <span class="tt">weight</span> (&gt;= 0): shares leftover main-axis space; <span class="tt">0</span> = fixed</li>
<li>Per-child min/max hints on both axes (optional)</li>
</ul>
<p>Main-axis sizing: 1) Measure fixed items (<span class="tt">weight==0</span>): explicit size else intrinsic; clamp to min/max 2) <span class="tt">available = containerMain - (sumFixed + spacing*(N-1))</span> 3) Distribute to weighted items: <span class="tt">available * (weight_i / totalWeight)</span> 4) Clamp weighted items to min/max iteratively; redistribute remaining among unclamped until stable 5) Overflow: if content exceeds container, no auto-shrink in v1; items overflow sequentially. If <span class="tt">container.clip</span>, overflow is clipped</p>
<p>Cross-axis sizing:</p><ul>
<li>If explicit cross size: use it</li>
<li>Else if <span class="tt">alignCross=Stretch</span>: child cross size = container cross size (then clamp)</li>
<li>Else: intrinsic cross size; position by <span class="tt">alignCross</span></li>
</ul>
<p>Positioning:</p><ul>
<li>Start <span class="tt">offset = 0</span>; adjust by <span class="tt">alignMain</span> when <span class="tt">totalChildrenSize &lt; containerMain</span></li>
<li>Place child at <span class="tt">(offset, crossOffset)</span>, then <span class="tt">offset += childMain + spacing</span></li>
<li>Child transform applies post-layout (visual only; does not affect layout in v1)</li>
</ul>
<p>Z-order and hit testing:</p><ul>
<li>Order within a stack remains <span class="tt">(zIndex asc, then children[] order)</span></li>
<li>If <span class="tt">container.clip==true</span>, descendants are clipped for draw and hit testing</li>
</ul>
<p>Text and images:</p><ul>
<li>Text wraps when width is implicit via <span class="tt">Stretch</span> on cross-axis (vertical stack) or explicit width; height grows</li>
<li>Otherwise, single-line intrinsic size; may overflow unless clipped</li>
<li>Image natural size if no explicit size; otherwise apply fit (<span class="tt">contain | cover | fill | none</span>)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
Authoring publish strategies</h2>
<ul>
<li>Atomic mount (preferred):<ul>
<li>Build in a temporary <span class="tt">PathSpace</span> and insert it at <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;</span> (<span class="tt">unique_ptr&lt;PathSpace&gt;</span>)</li>
<li>Single notify wakes waiters (e.g., the snapshot builder)</li>
<li>Avoids partial reads without extra synchronization</li>
</ul>
</li>
<li>Commit barrier (incremental authoring):<ul>
<li>For streaming/incremental edits to <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;/src</span>, writers may update nodes and then bump <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;/src/commit</span> as a publish hint</li>
<li>Builders can listen to <span class="tt">src/commit</span> to rebuild immediately; non-commit edits may be debounced (e.g., ~16 ms)</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
Builder: waiting for mount or revision</h3>
<p>Atomic mount detection (poll until <span class="tt">/src/root</span> exists): </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line">Expected&lt;void&gt; wait_for_scene_ready(<a class="code hl_class" href="class_s_p_1_1_path_space.html">SP::PathSpace</a>&amp; ps, std::string <span class="keyword">const</span>&amp; app, std::string <span class="keyword">const</span>&amp; sid) {</div>
<div class="line">  <span class="keyword">const</span> std::string rootPath = app + <span class="stringliteral">&quot;/scenes/&quot;</span> + sid + <span class="stringliteral">&quot;/src/root&quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="keyword">auto</span> root = ps.<a class="code hl_function" href="class_s_p_1_1_path_space_base.html#a2941f2763aad2813c12a9a886ccf5961">read</a>&lt;std::string&gt;(rootPath, Block{50ms});</div>
<div class="line">    <span class="keywordflow">if</span> (root) <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_s_p_1_1_path_space_base_html_a2941f2763aad2813c12a9a886ccf5961"><div class="ttname"><a href="class_s_p_1_1_path_space_base.html#a2941f2763aad2813c12a9a886ccf5961">SP::PathSpaceBase::read</a></div><div class="ttdeci">auto read(S const &amp;pathIn, Out const &amp;options={}) const -&gt; Expected&lt; DataType &gt;</div><div class="ttdef"><b>Definition</b> PathSpaceBase.hpp:86</div></div>
</div><!-- fragment --><p>Incremental edits with commit barrier: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> wait_for_commit_and_rebuild(<a class="code hl_class" href="class_s_p_1_1_path_space.html">SP::PathSpace</a>&amp; ps, std::string <span class="keyword">const</span>&amp; app, std::string <span class="keyword">const</span>&amp; sid) {</div>
<div class="line">  <span class="keyword">const</span> std::string commitPath = app + <span class="stringliteral">&quot;/scenes/&quot;</span> + sid + <span class="stringliteral">&quot;/src/commit&quot;</span>;</div>
<div class="line">  uint64_t last = ps.<a class="code hl_function" href="class_s_p_1_1_path_space_base.html#a2941f2763aad2813c12a9a886ccf5961">read</a>&lt;uint64_t&gt;(commitPath).value_or(0);</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="keyword">auto</span> cur = ps.<a class="code hl_function" href="class_s_p_1_1_path_space_base.html#a2941f2763aad2813c12a9a886ccf5961">read</a>&lt;uint64_t&gt;(commitPath, Block{500ms}); <span class="comment">// wakes on commit writes</span></div>
<div class="line">    <span class="keywordflow">if</span> (cur &amp;&amp; *cur != last) {</div>
<div class="line">      last = *cur;</div>
<div class="line">      <span class="comment">// trigger rebuild for sid</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Waiting for a new published revision: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line">uint64_t wait_for_new_revision(<a class="code hl_class" href="class_s_p_1_1_path_space.html">SP::PathSpace</a>&amp; ps, std::string <span class="keyword">const</span>&amp; app, std::string <span class="keyword">const</span>&amp; sid, uint64_t known) {</div>
<div class="line">  <span class="keyword">const</span> std::string revPath = app + <span class="stringliteral">&quot;/scenes/&quot;</span> + sid + <span class="stringliteral">&quot;/current_revision&quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="keyword">auto</span> rev = ps.<a class="code hl_function" href="class_s_p_1_1_path_space_base.html#a2941f2763aad2813c12a9a886ccf5961">read</a>&lt;uint64_t&gt;(revPath, Block{250ms});</div>
<div class="line">    <span class="keywordflow">if</span> (rev &amp;&amp; *rev != known) <span class="keywordflow">return</span> *rev;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
Renderer loop outline</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> renderTarget(<span class="keyword">const</span> Camera&amp; cam,</div>
<div class="line">                  <span class="keyword">const</span> DrawableEntry* entries, <span class="keywordtype">size_t</span> count,</div>
<div class="line">                  Surface&amp; surface)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// 1) Frustum cull (sphere), optional AABB vs viewport for 2D</span></div>
<div class="line">  <span class="comment">// 2) Partition opaque/alpha</span></div>
<div class="line">  <span class="comment">// 3) Sort opaque by pipeline/material then z; sort alpha back-to-front</span></div>
<div class="line">  <span class="comment">// 4) Opaque pass: depth-friendly or painter’s order for 2D</span></div>
<div class="line">  <span class="comment">// 5) Alpha pass: blend back-to-front</span></div>
<div class="line">  <span class="comment">// 6) Execute DrawCommands into software raster (or GPU encoder)</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
Notifications and scheduling</h1>
<ul>
<li>Edits set a scene dirty flag/counter and notify a layout worker (debounced)</li>
<li>Commit barrier monotonicity: <span class="tt">&lt;app&gt;/scenes/&lt;sid&gt;/src/commit</span> is a monotonically increasing uint64 counter; writers increment it by at least 1 per publish. Readers ignore equal or lower values.</li>
<li>Renderers may watch target scene subtrees to mark targets dirty</li>
<li>Modes:<ul>
<li>Explicit: surfaces/presenters trigger frames</li>
<li>On-notify: renderer schedules frames for dirty targets</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
Safety and validation</h1>
<ul>
<li>App-relative resolution: a path without a leading slash is resolved against the app root</li>
<li>Same-app validation: after resolution, verify the target path still lies within the app root; reject otherwise</li>
<li>Symlink/alias containment (filesystem-backed paths): when resolving any filesystem path, resolve symlinks/aliases to absolute paths and verify containment within the app root to prevent escapes.</li>
<li>Platform handle hygiene:<ul>
<li>Use opaque typed wrappers for <span class="tt">CAMetalLayer*</span>, <span class="tt">VkImage</span>, etc.</li>
<li>Document ownership and thread affinity (present must occur on the correct thread)</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
Performance notes</h1>
<ul>
<li>Software path introduces an extra copy (renderer → presenter blit)<ul>
<li>Mitigate with double-buffering and mapped memory; reuse buffers on resize where possible</li>
</ul>
</li>
<li>GPU path uses an offscreen pass plus a present pass<ul>
<li>Optionally allow a presentable-surface mode (direct-to-window) when multi-window reuse is not needed</li>
</ul>
</li>
<li>Debounce layout and frame triggers to avoid overdraw on bursty updates</li>
<li>Constrain retained snapshots; share resources across snapshots where safe</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
Builder/helpers (typed wiring)</h1>
<p>Introduce small C++ helpers to avoid brittle path-string glue.</p>
<p>Responsibilities:</p><ul>
<li>Resolve app-relative paths and validate containment</li>
<li>Manage target-id convention (<span class="tt">targets/surfaces/&lt;name&gt;</span>)</li>
<li>Use PathSpace atomic primitives:<ul>
<li>Single-value replace for small configs (e.g., <span class="tt">desc</span>)</li>
<li>Param updates (Queue) are client-side coalescing, then a single atomic write to <span class="tt">&lt;target&gt;/settings</span> (no server-side queue in v1)</li>
<li>Snapshot revision flip (single write) for scene publish (builder concern)</li>
</ul>
</li>
<li>Provide readable errors with context (target-id, frame index, snapshot revision)</li>
</ul>
<p>Helper API (schema-as-code; returns canonical absolute paths; excerpt): </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>SP::ui {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>AppRoot = std::string;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>SceneParams    { std::string name; std::string description; };</div>
<div class="line"><span class="keyword">enum class</span> RendererKind { Software2D, Metal2D, Vulkan2D };</div>
<div class="line"><span class="keyword">struct </span>RendererParams { std::string name; RendererKind kind; std::string description; };</div>
<div class="line"><span class="keyword">struct </span>SurfaceDesc    { <span class="comment">/* backend, size, format, colorSpace, etc. */</span> };</div>
<div class="line"><span class="keyword">struct </span>SurfaceParams  { std::string name; SurfaceDesc desc; std::string renderer; };</div>
<div class="line"><span class="keyword">struct </span>WindowParams   { std::string name, title; <span class="keywordtype">int</span> width=0, height=0; <span class="keywordtype">float</span> scale=1.0f; std::string background; };</div>
<div class="line"> </div>
<div class="line">Expected&lt;std::string&gt; resolve_app_relative(AppRoot <span class="keyword">const</span>&amp; appRoot, std::string_view maybeRel);</div>
<div class="line">std::string derive_target_base(AppRoot <span class="keyword">const</span>&amp; appRoot, std::string <span class="keyword">const</span>&amp; rendererPathAbs, std::string <span class="keyword">const</span>&amp; targetPathAbs);</div>
<div class="line"> </div>
<div class="line">Expected&lt;std::string&gt; create_scene   (PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;, SceneParams <span class="keyword">const</span>&amp;);</div>
<div class="line">Expected&lt;std::string&gt; create_renderer(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;, RendererParams <span class="keyword">const</span>&amp;);</div>
<div class="line">Expected&lt;std::string&gt; create_surface (PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;, SurfaceParams <span class="keyword">const</span>&amp;);</div>
<div class="line">Expected&lt;std::string&gt; create_window  (PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;, WindowParams <span class="keyword">const</span>&amp;);</div>
<div class="line"> </div>
<div class="line">Expected&lt;void&gt; attach_surface_to_view(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;,</div>
<div class="line">                                      std::string windowPathOrName, std::string_view viewName,</div>
<div class="line">                                      std::string surfacePathOrName);</div>
<div class="line"> </div>
<div class="line">Expected&lt;void&gt; set_surface_scene(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;,</div>
<div class="line">                                 std::string surfacePathOrName, std::string scenePathOrName);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>RenderSettings { <span class="comment">/* see RenderSettings v1 (final) */</span> };</div>
<div class="line"><span class="keyword">enum class</span> ParamUpdateMode { Queue, ReplaceActive }; <span class="comment">// v1 semantics: Queue = client-side coalesce then atomic single-path replace; no server-side queue</span></div>
<div class="line"> </div>
<div class="line">Expected&lt;void&gt; update_target_settings(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;,</div>
<div class="line">                                      std::string targetPathOrSpec,</div>
<div class="line">                                      RenderSettings <span class="keyword">const</span>&amp;,</div>
<div class="line">                                      ParamUpdateMode mode = ParamUpdateMode::Queue);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FutureAny {}; <span class="comment">// opaque future type for completion tracking</span></div>
<div class="line"> </div>
<div class="line">Expected&lt;FutureAny&gt; render_target_once(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;,</div>
<div class="line">                                       std::string targetPathOrSpec,</div>
<div class="line">                                       std::optional&lt;RenderSettings&gt; overrides = std::nullopt);</div>
<div class="line"> </div>
<div class="line">Expected&lt;void&gt; present_view(PathSpace&amp;, AppRoot <span class="keyword">const</span>&amp;,</div>
<div class="line">                            std::string windowPathOrName, std::string_view viewName);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>RendererCaps {};</div>
<div class="line">Expected&lt;RendererCaps&gt; get_renderer_caps(PathSpace <span class="keyword">const</span>&amp;, AppRoot <span class="keyword">const</span>&amp;, std::string rendererPathOrName);</div>
<div class="line">Expected&lt;SurfaceDesc&gt;  get_surface_desc (PathSpace <span class="keyword">const</span>&amp;, AppRoot <span class="keyword">const</span>&amp;, std::string surfacePathOrName);</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace SP::ui</span></div>
</div><!-- fragment --><p>Source layout (proposed):</p><ul>
<li><span class="tt">include/pathspace/ui/Builders.hpp</span></li>
<li><span class="tt">src/pathspace/ui/</span><ul>
<li><span class="tt">scene/SceneSnapshotBuilder.{hpp,cpp}</span></li>
<li><span class="tt">renderer/PathRenderer2D.{hpp,cpp}</span></li>
<li><span class="tt">renderer/DrawableBucket.{hpp,cpp}</span></li>
<li><span class="tt">surface/PathSurface.hpp</span></li>
<li><span class="tt">surface/PathSurfaceSoftware.{hpp,cpp}</span></li>
<li><span class="tt">surface/PathSurfaceMetal.{hpp,mm}</span> (ObjC++ on Apple)</li>
<li><span class="tt">surface/SurfaceTypes.hpp</span></li>
<li><span class="tt">window/PathWindow.{hpp,mm}</span></li>
<li><span class="tt">window/PathWindowView.{hpp,cpp|mm}</span></li>
<li><span class="tt">platform/macos/...</span>, <span class="tt">platform/win32/...</span>, <span class="tt">platform/x11|wayland/...</span></li>
</ul>
</li>
</ul>
<p>CMake options (single library, feature-gated): </p><div class="fragment"><div class="line">option(PATHSPACE_ENABLE_UI &quot;Build UI (surfaces/renderers/windows)&quot; ON)</div>
<div class="line">option(PATHSPACE_UI_SOFTWARE &quot;Enable software surface&quot; ON)</div>
<div class="line">option(PATHSPACE_UI_METAL &quot;Enable Metal surface/presenter (Apple)&quot; ON)</div>
<div class="line"> </div>
<div class="line">if(PATHSPACE_ENABLE_UI)</div>
<div class="line">  target_sources(PathSpace PRIVATE</div>
<div class="line">    include/pathspace/ui/Builders.hpp</div>
<div class="line">    src/pathspace/ui/renderer/PathRenderer2D.cpp</div>
<div class="line">    src/pathspace/ui/renderer/PathRenderer2D.hpp</div>
<div class="line">    src/pathspace/ui/renderer/DrawableBucket.cpp</div>
<div class="line">    src/pathspace/ui/renderer/DrawableBucket.hpp</div>
<div class="line">    src/pathspace/ui/scene/SceneSnapshotBuilder.cpp</div>
<div class="line">    src/pathspace/ui/scene/SceneSnapshotBuilder.hpp</div>
<div class="line">    src/pathspace/ui/surface/SurfaceTypes.hpp</div>
<div class="line">  )</div>
<div class="line">  if(PATHSPACE_UI_SOFTWARE)</div>
<div class="line">    target_sources(PathSpace PRIVATE</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceSoftware.cpp</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceSoftware.hpp</div>
<div class="line">    )</div>
<div class="line">  endif()</div>
<div class="line">  if(APPLE AND PATHSPACE_UI_METAL)</div>
<div class="line">    enable_language(OBJCXX)</div>
<div class="line">    target_sources(PathSpace PRIVATE</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceMetal.mm</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceMetal.hpp</div>
<div class="line">      src/pathspace/ui/window/PathWindowView.mm</div>
<div class="line">      src/pathspace/ui/window/PathWindowView.hpp</div>
<div class="line">    )</div>
<div class="line">    target_link_libraries(PathSpace PRIVATE &quot;-framework Cocoa&quot; &quot;-framework Metal&quot; &quot;-framework QuartzCore&quot;)</div>
<div class="line">    if(CMAKE_OBJCXX_COMPILER_ID MATCHES &quot;Clang&quot;)</div>
<div class="line">      set_source_files_properties(</div>
<div class="line">        src/pathspace/ui/surface/PathSurfaceMetal.mm</div>
<div class="line">        src/pathspace/ui/window/PathWindowView.mm</div>
<div class="line">        PROPERTIES COMPILE_FLAGS &quot;-fobjc-arc&quot;</div>
<div class="line">      )</div>
<div class="line">    endif()</div>
<div class="line">  endif()</div>
<div class="line">endif()</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
Examples (creation with parameter structs)</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_path_space_8hpp.html">pathspace/PathSpace.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pathspace/ui/Builders.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_s_p.html">SP</a>;</div>
<div class="line"><span class="keyword">using namespace </span>SP::ui;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <a class="code hl_class" href="class_s_p_1_1_path_space.html">PathSpace</a> space;</div>
<div class="line">  AppRoot app = <span class="stringliteral">&quot;/system/applications/notepad&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 1) Create a scene</span></div>
<div class="line">  SceneParams scene{ .name = <span class="stringliteral">&quot;main&quot;</span>, .description = <span class="stringliteral">&quot;Main UI scene&quot;</span> };</div>
<div class="line">  <span class="keyword">auto</span> scenePath = create_scene(space, app, scene).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2) Create a renderer</span></div>
<div class="line">  RendererParams rparams{ .name = <span class="stringliteral">&quot;2d&quot;</span>, .kind = RendererKind::Software2D, .description = <span class="stringliteral">&quot;Software 2D renderer&quot;</span> };</div>
<div class="line">  <span class="keyword">auto</span> rendererPath = create_renderer(space, app, rparams).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3) Create a surface linked to the renderer</span></div>
<div class="line">  SurfaceDesc sdesc; sdesc.size_px = {1280, 720};</div>
<div class="line">  SurfaceParams sparams{ .name = <span class="stringliteral">&quot;editor&quot;</span>, .desc = sdesc, .renderer = <span class="stringliteral">&quot;2d&quot;</span> };</div>
<div class="line">  <span class="keyword">auto</span> surfacePath = create_surface(space, app, sparams).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 4) Create a window</span></div>
<div class="line">  WindowParams wparams{ .name = <span class="stringliteral">&quot;MainWindow&quot;</span>, .title = <span class="stringliteral">&quot;Notepad — Main&quot;</span>, .width = 1280, .height = 720, .scale = 2.0f };</div>
<div class="line">  <span class="keyword">auto</span> windowPath = create_window(space, app, wparams).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 5) Wire: attach surface to window view and pick a scene for the surface</span></div>
<div class="line">  attach_surface_to_view(space, app, <span class="stringliteral">&quot;MainWindow&quot;</span>, <span class="stringliteral">&quot;editor&quot;</span>, <span class="stringliteral">&quot;editor&quot;</span>).value();</div>
<div class="line">  set_surface_scene(space, app, surfacePath, <span class="stringliteral">&quot;scenes/main&quot;</span>).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 6) Update settings (queued: client-side coalesce, then a single atomic write) and render once</span></div>
<div class="line">  RenderSettings rs; rs.surface.size_px = {1280, 720}; rs.surface.dpi_scale = 2.0f;</div>
<div class="line">  update_target_settings(space, app, <span class="stringliteral">&quot;renderers/2d/targets/surfaces/editor&quot;</span>, rs).value();</div>
<div class="line">  <span class="keyword">auto</span> fut = render_target_once(space, app, <span class="stringliteral">&quot;renderers/2d/targets/surfaces/editor&quot;</span>).value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 7) Present the view</span></div>
<div class="line">  present_view(space, app, windowPath, <span class="stringliteral">&quot;editor&quot;</span>).value();</div>
<div class="line">}</div>
<div class="ttc" id="a_path_space_8hpp_html"><div class="ttname"><a href="_path_space_8hpp.html">PathSpace.hpp</a></div></div>
<div class="ttc" id="anamespace_s_p_html"><div class="ttname"><a href="namespace_s_p.html">SP</a></div><div class="ttdef"><b>Definition</b> ElementType.hpp:7</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md114"></a>
HTML/Web output (optional adapter)</h1>
<p>Motivation: preview/export UI scenes to browsers without changing the core pipeline</p>
<p>Approach: semantic HTML/DOM adapter mapping widgets to native elements with CSS-based layout/animation. No ray tracing, no canvas command stream, no WebGL.</p>
<p>Paths (under a renderer target base):</p><ul>
<li><span class="tt">output/v1/html/dom</span> — full HTML document as a string (may inline CSS/JS)</li>
<li><span class="tt">output/v1/html/css</span> — CSS string, if split</li>
<li><span class="tt">output/v1/html/commands</span> — Canvas JSON fallback command stream</li>
<li><span class="tt">output/v1/html/assets/&lt;name&gt;</span> — optional assets (base64 or URLs)</li>
</ul>
<p>Mapping hints:</p><ul>
<li>Rects/rounded-rects → <span class="tt">div</span> with <span class="tt">border-radius</span></li>
<li>Images → <span class="tt">img</span> or CSS <span class="tt">background-image</span> on <span class="tt">div</span></li>
<li>Text → DOM text (or pre-shaped glyph spans later)</li>
<li>Transforms → CSS <span class="tt">matrix()/matrix3d()</span></li>
<li>Shadows → CSS <span class="tt">box-shadow</span></li>
<li>Z-order → <span class="tt">z-index</span> stacking contexts</li>
<li>Clipping → <span class="tt">overflow:hidden</span> or CSS <span class="tt">clip-path</span></li>
</ul>
<p>Example (DOM/CSS): </p><div class="fragment"><div class="line">&lt;!doctype html&gt;</div>
<div class="line">&lt;html&gt;</div>
<div class="line">&lt;head&gt;</div>
<div class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</div>
<div class="line">&lt;title&gt;PathSpace UI — target preview&lt;/title&gt;</div>
<div class="line">&lt;style&gt;</div>
<div class="line">  .root { position: relative; width: 640px; height: 360px; background: #202020; }</div>
<div class="line">  .rect { position: absolute; left: 40px; top: 30px; width: 200px; height: 120px;</div>
<div class="line">          background: #4a90e2; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.25); }</div>
<div class="line">  .text { position: absolute; left: 56px; top: 50px; color: white; font: 16px/20px system-ui, sans-serif; }</div>
<div class="line">&lt;/style&gt;</div>
<div class="line">&lt;/head&gt;</div>
<div class="line">&lt;body&gt;</div>
<div class="line">&lt;div class=&quot;root&quot;&gt;</div>
<div class="line">  &lt;div class=&quot;rect&quot;&gt;&lt;/div&gt;</div>
<div class="line">  &lt;div class=&quot;text&quot;&gt;Hello, PathSpace!&lt;/div&gt;</div>
<div class="line">&lt;/div&gt;</div>
<div class="line">&lt;/body&gt;</div>
<div class="line">&lt;/html&gt;</div>
</div><!-- fragment --><p>Notes:</p><ul>
<li>Semantic DOM/CSS only; no ray tracing or canvas/WebGL in this adapter</li>
<li>Text fidelity improves if we pre-shape glyphs in the snapshot and emit positioned spans</li>
<li>Optional adapter; does not affect software/GPU outputs</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md115"></a>
Software renderer — path tracing with tetrahedral acceleration</h1>
<p>Status: resolved plan for software renderer pipeline</p>
<p>Summary:</p><ul>
<li>Scenes are often static; we prioritize incremental refinement via path tracing with snapshot-integrated acceleration structures</li>
<li>Acceleration is snapshot-integrated:<ul>
<li>TLAS per revision over instances; BLAS per unique geometry (deduped)</li>
<li>Tetrahedral face adjacency enables “tet-walk” traversal between neighboring tets for multi-bounce paths</li>
</ul>
</li>
</ul>
<p>Caching for fast edits:</p><ul>
<li>Per-pixel <span class="tt">PixelHitCache</span> stores primary hit data and accumulation state; supports targeted invalidation</li>
<li>Per-face reservoirs (ReSTIR-style) store reusable direct- and indirect-light samples to guide secondary rays</li>
</ul>
<p>Geometry and traversal:</p><ul>
<li>Mesh: tetrahedra with precomputed face table and adjacency (two incident tets per face; boundary sentinel)</li>
<li>Surface classification: a face is a “surface” when adjacent media differ (or one side is boundary); shading happens on surfaces</li>
<li>Primary rays: TLAS → BLAS (face BVH) intersection</li>
<li>Secondary rays: start from a hit face and tet-walk across faces inside the same medium; intersect surface faces; fall back to BVH if needed</li>
</ul>
<p>Per-pixel cache (primary visibility and accumulation):</p><ul>
<li>Store per pixel: <span class="tt">instanceIndex</span>, <span class="tt">primIndex</span>, <span class="tt">t</span>, <span class="tt">barycentrics</span>, <span class="tt">uv</span>, packed normal, <span class="tt">materialId</span>, flags <span class="tt">hitValid/shadeValid</span></li>
<li>Invalidate selectively:<ul>
<li>Material shading-only change → <span class="tt">shadeValid = 0</span> (no retrace)</li>
<li>Material visibility/alpha/displacement → <span class="tt">hitValid = 0</span> (retrace)</li>
<li>Instance transform/visibility → <span class="tt">hitValid = 0</span> for that instance’s pixels</li>
<li>Camera/viewport change → full reset (or reprojection heuristics)</li>
</ul>
</li>
<li>Use per-tile (e.g., 16×16) inverted indices mapping <span class="tt">materialId/instanceIndex</span> → bitsets of affected pixels for O(tiles) invalidation</li>
</ul>
<p>Per-face reservoirs and guiding (reuse across pixels/frames):</p><ul>
<li>Direct lighting: small ReSTIR DI reservoir per face; sample from it and update with new candidates each iteration</li>
<li>Indirect lighting (optional): GI reservoirs per face capturing incoming direction/radiance; guide BSDF sampling</li>
<li>Spatial reuse: reseed from adjacent faces via tet adjacency for sparse-history faces</li>
<li>Guiding: optionally fit a lightweight directional PDF (e.g., 1–2 vMF lobes) from reservoir history; mix with BSDF and apply MIS</li>
</ul>
<p>Iteration pipeline (per frame/refinement step): 1) Acquire snapshot revision and settings; map TLAS/BLAS, face adjacency; allocate per-frame state 2) For each visible pixel:</p><ul>
<li>If <span class="tt">hitValid</span>, reuse primary hit; else regenerate and update <span class="tt">PixelHitCache</span></li>
<li>Direct light via DI reservoir + BSDF importance sampling (MIS)</li>
<li>Spawn secondary ray(s), guided by face GI/DI where available; walk via tet-walk until a surface is hit; accumulate contribution</li>
<li>Update per-face reservoirs at landing faces with MIS-consistent weights 3) Write accumulated color; update per-tile indices for invalidation</li>
</ul>
<p>Settings (software renderer):</p><ul>
<li><span class="tt">rt.enable</span>, <span class="tt">rt.raysPerPixel</span>, <span class="tt">rt.maxDepth</span>, <span class="tt">rt.branching (4|8)</span>, <span class="tt">rt.leafMaxPrims</span>, <span class="tt">rt.quantization (none|aabb16)</span>, <span class="tt">rt.tileSize (8|16|32)</span></li>
<li><span class="tt">reuse</span>: <span class="tt">di.enable</span>, <span class="tt">gi.enable</span>, <span class="tt">reuseStrength</span></li>
<li><span class="tt">caches</span>: <span class="tt">pixelCache.enable</span>, <span class="tt">faceReservoirs.enable</span>, <span class="tt">faceReservoirs.capacity</span></li>
<li><span class="tt">debug</span>: <span class="tt">showTetWalk</span>, <span class="tt">showSurfaceFaces</span>, <span class="tt">showInvalidation</span>, <span class="tt">showReservoirs</span></li>
</ul>
<p>Stats (<span class="tt">output/v1/common</span> and <span class="tt">output/v1/rt_stats</span>):</p><ul>
<li><span class="tt">cpu_build_ms</span>, <span class="tt">traversal_ms</span>, <span class="tt">shading_ms</span></li>
<li><span class="tt">tlas_nodes</span>, <span class="tt">blas_nodes_total</span>, <span class="tt">rays_traced</span>, <span class="tt">hits</span>, <span class="tt">miss_rate</span></li>
<li><span class="tt">retraced_pixels</span>, <span class="tt">reshaded_pixels</span>, <span class="tt">reservoir_updates</span></li>
</ul>
<p>Failure modes and fallbacks:</p><ul>
<li>If TLAS/BLAS not ready: render with cached primary where valid; schedule (re)build within budget; optionally hybrid raster primary as fallback</li>
<li>If adjacency is non-manifold/degenerate in a region: fall back to BVH traversal there; log once</li>
</ul>
<p>Cross-reference:</p><ul>
<li>When snapshot semantics or acceleration formats evolve, reflect changes in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> (Snapshot Builder and Rebuild Policy)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md116"></a>
Tetrahedral face adjacency</h1>
<p>Purpose:</p><ul>
<li>Provide a watertight, deterministic connectivity index over tetrahedral meshes to enable fast multi-bounce path tracing (tet-walk) and robust physics sweeps without re-entering a BVH at every step</li>
</ul>
<p>Data model:</p><ul>
<li>Face table (one record per unique triangle):<ul>
<li>Canonical vertex triplet (deterministic winding)</li>
<li>Incident tetrahedra: up to two per face; boundary has one</li>
<li>Per-incidence metadata: local face index in the tet, winding parity vs canonical</li>
<li>Precomputed plane (<span class="tt">n.xyz, d</span>), optional tangent frame and area</li>
<li>Optional per-side medium/material id to classify “surface” faces (medium change)</li>
</ul>
</li>
<li>Tet table (one record per tetrahedron):<ul>
<li>Vertex indices <span class="tt">[a,b,c,d]</span></li>
<li>Global <span class="tt">faceId[4]</span> mapping local faces to face table</li>
<li><span class="tt">neighborTet[4]</span> and <span class="tt">neighborLocalFace[4]</span> across local faces (or <span class="tt">-1</span> for boundary)</li>
</ul>
</li>
</ul>
<p>Canonical local faces (for tet <span class="tt">[a,b,c,d]</span>):</p><ul>
<li><span class="tt">f0</span> (opposite <span class="tt">a</span>): <span class="tt">(b,c,d)</span></li>
<li><span class="tt">f1</span> (opposite <span class="tt">b</span>): <span class="tt">(a,d,c)</span></li>
<li><span class="tt">f2</span> (opposite <span class="tt">c</span>): <span class="tt">(a,b,d)</span></li>
<li><span class="tt">f3</span> (opposite <span class="tt">d</span>): <span class="tt">(a,c,b)</span></li>
</ul>
<p>Build algorithm (deterministic):</p><ul>
<li>For each tet local face, compute a sorted triplet key (ascending vertex ids) to deduplicate faces</li>
<li>First incidence sets the face’s canonical winding (use the tet’s local winding)</li>
<li>Second incidence fills neighbor links and winding parity</li>
<li>Compute planes once per face from canonical winding; assign medium ids per side if available</li>
<li>Validate: flag non-manifold faces (&gt;2 incidences) and zero-area faces for fallback</li>
</ul>
<p>Traversal (renderer/physics):</p><ul>
<li>Secondary rays: start at a surface face; choose entering tet by sign of <span class="tt">d·n</span>; repeatedly intersect current tet’s face planes and cross to the next tet until reaching a surface/boundary face; only intersect triangles at surface faces. Fall back to BVH in degenerate regions</li>
<li>Physics shape-casts/CCD: same face-to-face stepping with conservative inflation; use the static TLAS for broad-phase, adjacency for narrow-phase marching</li>
</ul>
<p>Medium transitions (disjoint air/object):</p><ul>
<li>Keep separate adjacency for object and air; no need to stitch meshes</li>
<li>Surface portals (precomputed):<ul>
<li>For each surface face, store <span class="tt">1..K</span> candidate entry air tet ids on the outward side; build by offsetting a point on the face along outward normal by <span class="tt">ε</span> and locating the containing air tet via an air AABB BVH + point-in-tet test. Sample a few intra-face points for robustness</li>
<li>At runtime, after shading with an outgoing direction into air, jump to the portal’s air tet and begin the air tet-walk from there</li>
</ul>
</li>
<li>Clip-and-test fallback:<ul>
<li>While walking in air (or object), compute exit distance to the next tet face; clip <span class="tt">[t_cur, t_exit]</span> and test that short segment against the global surface-face BVH. If a hit occurs before exit, transition media at that face; otherwise cross to the neighbor tet and continue</li>
<li>Guarantees correctness when portals are missing or ambiguous; short coherent segments make tests cheap</li>
</ul>
</li>
<li>Build-time guarantees:<ul>
<li>Provide an air boundary layer so every surface face has an air tet within <span class="tt">ε</span> outward; refine locally if needed</li>
<li>Maintain a global surface-face BVH (where medium changes) as the transition oracle</li>
</ul>
</li>
<li>Edge handling:<ul>
<li>Nudge <span class="tt">ε</span> into the target medium to avoid re-hitting the same face; deterministically break ties for near-coplanar/edge cases</li>
<li>If a portal’s tet fails the point-in-tet check at runtime, fall back to BVH-based point location in air and continue</li>
</ul>
</li>
</ul>
<p>Caching and invalidation:</p><ul>
<li>Per-face lighting reservoirs (DI/GI) keyed by <span class="tt">faceId</span>; invalidate by material/region; optionally diffuse seeds to neighbors</li>
<li><span class="tt">PixelHitCache</span> remains per-pixel for primary visibility; instance/material edits flip hit/shade validity via per-tile bitmaps</li>
</ul>
<p>Robustness:</p><ul>
<li>Watertightness via shared canonical planes for both incident tets</li>
<li>Deterministic next-face selection; small forward epsilon step when crossing faces</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md117"></a>
MVP plan</h1>
<p>1) Scaffolding and helpers</p><ul>
<li>Add <span class="tt">src/pathspace/ui/</span> with stubs for <span class="tt">PathRenderer2D</span>, <span class="tt">PathSurfaceSoftware</span>, and <span class="tt">PathWindowView</span> (presenter)</li>
<li>Add <span class="tt">ui/Builders.hpp</span> (header-only) with comments explaining atomicity and path resolution behavior 2) Software-only pipeline (macOS-friendly)</li>
<li>Implement <span class="tt">PathSurfaceSoftware</span> with pixel buffer + double-buffer</li>
<li>Implement <span class="tt">PathRenderer2D</span> with target params, commit protocol, and simple rect/text rendering</li>
<li>Implement <span class="tt">PathWindowView</span> that blits buffers into a simple window (pair with Cocoa event pump) 3) Scene snapshots (minimal)</li>
<li>Define <span class="tt">scenes/&lt;sid&gt;/src/...</span>, <span class="tt">builds/&lt;revision&gt;/...</span>, <span class="tt">current_revision</span></li>
<li>Implement a minimal snapshot builder (stacking/absolute layout)</li>
<li>Integrate renderer to read snapshots by <span class="tt">current_revision</span> 4) Notifications and scheduling</li>
<li>Debounced layout when <span class="tt">src</span> changes</li>
<li>Optional renderer auto-schedule on notify; otherwise explicit trigger via surface/frame 5) Tests and docs</li>
<li>Golden tests for snapshots and target param atomicity</li>
<li>Concurrency tests (hammer edits while rendering)</li>
<li>Update <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> if any core semantics change 6) Metal backend (next)</li>
<li><span class="tt">PathSurfaceMetal</span> producing an offscreen <span class="tt">MTLTexture</span></li>
<li>Presenter draws textured quad into <span class="tt">CAMetalLayer</span> drawable on the UI thread</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md118"></a>
Gaps and Decisions (unresolved areas)</h1>
<p>The following items are intentionally unresolved and tracked as backlog. Promote items to “Decision” when resolved and keep in sync with <span class="tt">docs/AI_TODO.task</span> and code/tests.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md119"></a>
Decision: HTML adapter fidelity (resolved)</h1>
<p>Summary:</p><ul>
<li>Adopt DOM/CSS as the default v1 adapter for preview/export of 2D UI scenes.</li>
<li>Provide an automatic fallback to a compact Canvas JSON + tiny runtime when DOM node budgets or fidelity constraints are exceeded.</li>
<li>Defer WebGL to a later phase; only consider if performance or blend/clip fidelity requires it.</li>
</ul>
<p>Scope and constraints (v1):</p><ul>
<li>Supported: rect/rrect, images, text, 2D transforms, z-order, rect/rrect clipping, shadows; sRGB color and premultiplied alpha semantics approximated via CSS.</li>
<li>Out of scope: 3D transforms, advanced blend modes beyond normal alpha, non-rectangular hit regions, Display P3 targets, GPU lighting.</li>
</ul>
<p>Output paths:</p><ul>
<li>output/v1/html/dom — full HTML document (may inline CSS/JS)</li>
<li>output/v1/html/css — optional CSS string</li>
<li>output/v1/html/commands — Canvas JSON fallback command stream</li>
<li>output/v1/html/assets/* — assets referenced by DOM/CSS or Canvas JSON</li>
</ul>
<p>Fidelity tiers and selection:</p><ul>
<li>Tier 1: DOM/CSS (default)<ul>
<li>Semantic elements and CSS transforms; overflow/clip-path for safe cases.</li>
<li>Deterministic stacking via z-index and DOM order; stable ids for tie-breaks.</li>
</ul>
</li>
<li>Tier 2: Canvas JSON (fallback)<ul>
<li>Emit a compact command stream (moveTo/lineTo/arc/clip/drawImage/drawGlyph) and include a minimal replay runtime (&lt;10 KB) in the DOM or as an asset.</li>
<li>Switch when:<ul>
<li>Estimated DOM node count exceeds maxDomNodes (default 10k).</li>
<li>Scene uses clip/blend features that DOM/CSS cannot match acceptably.</li>
</ul>
</li>
</ul>
</li>
<li>Tier 3: WebGL (deferred)<ul>
<li>Not implemented in v1; revisit only if necessary.</li>
</ul>
</li>
</ul>
<p>Text shaping strategy (v1):</p><ul>
<li>Primary: consume pre-shaped glyph runs from the snapshot builder (HarfBuzz + FreeType, per existing decision).</li>
<li>DOM/CSS mode:<ul>
<li>Emit absolutely positioned glyph spans (one per glyph for complex scripts; coalesce safe clusters), with CSS transforms for subpixel placement.</li>
<li>Optional simplified mode for trivial Latin runs: native DOM text to reduce node count.</li>
</ul>
</li>
<li>Canvas JSON mode:<ul>
<li>Replay positioned glyphs; MSDF atlas path may be added later but is not required for v1.</li>
</ul>
</li>
<li>Fonts:<ul>
<li>Emit @font-face rules referencing output/v1/html/assets/fonts/*; optional later subsetting to WOFF2.</li>
</ul>
</li>
</ul>
<p>Mapping:</p><ul>
<li>Rect/rrect → div + border-radius (fallback to clip-path for non-uniform radii as needed).</li>
<li>Paths more complex than rrect → Canvas JSON fallback; DOM clip-path used only for well-supported, simple shapes.</li>
<li>Images → img with explicit width/height; use CSS object-fit when needed.</li>
<li>Transforms → CSS matrix() composed in the snapshot order.</li>
<li>Stacking/blending → z-index and element opacity; advanced blend modes defer to Canvas JSON.</li>
<li>Clipping → overflow:hidden for rect/rrect; complex clips use clip-path when safe, otherwise Canvas JSON.</li>
<li>Color → sRGB CSS colors; assume sRGB target.</li>
</ul>
<p>Implementation:</p><ul>
<li>HtmlAdapter::emitDomCss(revision, options) → domString, cssString, assets[]</li>
<li>Options: { preferDom=true, maxDomNodes=10000, allowClipPath=true, preferGlyphSpans=true }</li>
<li>Asset pipeline: copy referenced images/fonts to output/v1/html/assets/*; generate @font-face.</li>
<li>Canvas JSON: encoder walking snapshot draw order; tiny JS runtime embedded or referenced from assets.</li>
</ul>
<p>Tests and metrics:</p><ul>
<li>Golden screenshot tests with headless Chromium and Firefox comparing DOM/CSS and Canvas JSON to software renderer goldens for rects/rrects/images/text.</li>
<li>Text: Latin kerning/ligatures, Arabic joining+bidi, Devanagari reordering, CJK; verify layout stability for glyph-span mode.</li>
<li>Size/perf: DOM node count, total output size, initial render time; validate tier switch thresholds.</li>
<li>Path and containment: verify output paths populated and app-relative constraints enforced.</li>
</ul>
<p>Milestones:</p><ul>
<li>M1 DOM/CSS MVP: rect/rrect/images/basic Latin text, transforms, z-index, rect clipping, assets/@font-face, goldens on two browsers.</li>
<li>M2 Shaped text and safe clip-path: full shaped scripts via glyph spans; fallback selection logic.</li>
<li>M3 Canvas JSON fallback: encoder + runtime; fidelity tests; thresholds.</li>
<li>M4 Optimizations: text run coalescing; optional font subsetting; doc polish.</li>
</ul>
<p>Cross-references:</p><ul>
<li>Update HTML/Web output section to mention tiers and selection logic.</li>
<li>Reflect adapter behavior in <a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md120"></a>
Decision: Lighting and shadows (resolved)</h1>
<p>Summary:</p><ul>
<li>Hybrid pipeline: software microtriangle rasterization for visibility with per-vertex irradiance computed by a GPU ray tracer. Triangles are tessellated to approximately one pixel in screen space per frame; lighting is computed in the GPU RT stage and stored into a vertex lighting buffer, then the software raster interpolates vertex lighting to pixels. Prefer hardware ray tracing when available; otherwise either disable RT lighting or use a reduced compute BVH fallback if configured.</li>
</ul>
<p>Model (v1):</p><ul>
<li>RenderSettings.MicrotriRT:<ul>
<li>enabled: bool</li>
<li>microtriEdgePx: float (target edge length in pixels; default ≈ 1.0)</li>
<li>maxMicrotrisPerFrame: uint (tessellation budget)</li>
<li>raysPerVertex: uint (spp for irradiance integration)</li>
<li>maxBounces: uint (≥ 1; commonly 1–3)</li>
<li>rrStartBounce: uint (≤ maxBounces)</li>
<li>useHardwareRT: enum { Auto, ForceOn, ForceOff }</li>
<li>environment: { hdrPath: string, intensity: float, rotation: float }</li>
<li>allowCaustics: bool</li>
<li>clampDirect?: float</li>
<li>clampIndirect?: float</li>
<li>progressiveAccumulation: bool</li>
<li>vertexAccumHalfLife: float (temporal accumulation weight, e.g., 0.1–0.5)</li>
<li>seed: uint64</li>
</ul>
</li>
<li>Materials/BSDF (per draw node or mesh subset):<ul>
<li>PBR: baseColor, metalness, roughness (GGX), ior, transmission, emissive, normalMap</li>
</ul>
</li>
<li>Geometry:<ul>
<li>UI geometry: primarily SDF-defined primitives (buttons, window chrome, etc.) are converted to triangle meshes via isosurface contouring during snapshot build. We use adaptive marching on implicit fields to produce well-conditioned triangles that target ≈ microtriEdgePx after subsequent screen-space tessellation. Each generated vertex receives a stable vertexId derived from (sourceSdfId, cellCoord, isoEdgeIndex).</li>
<li>Non-UI geometry: represented as tetrahedral meshes by default. Surface triangles for raster visibility are extracted from the tet boundary; the full tet mesh is used by the GPU RT integrator for robust interior traversal and media transitions (consistent with the tetrahedral acceleration section).</li>
<li>The snapshot builder emits the per-view microtriangle buffers from these sources with stable vertexIds enabling temporal accumulation and reuse.</li>
</ul>
</li>
</ul>
<p>Approach:</p><ul>
<li>Microtri tessellation (CPU):<ul>
<li>Adaptively tessellate visible primitives to ≈ microtriEdgePx in screen space; write per-vertex worldPos, normal, uv, materialId.</li>
<li>Generate stable vertexIds: hash(sourcePrimitiveId, gridU, gridV, lodSeed) to support temporal accumulation and buffer reuse.</li>
<li>Produce an index/vertex buffer for software raster and a GPU-visible vertex buffer for RT.</li>
</ul>
</li>
<li>Software raster (visibility and composition):<ul>
<li>Rasterize microtris in tiles; resolve visibility, clipping, stacking contexts, and blending as usual.</li>
<li>Shading reads per-vertex irradiance from the lighting buffer and interpolates to pixels; baseColor and alpha come from materials/textures. Optionally add a lightweight view-dependent specular term from roughness.</li>
</ul>
</li>
<li>GPU ray tracing (per-vertex irradiance):<ul>
<li>Build/reuse BLAS/TLAS over the full scene on hardware RT; if ForceOff, an optional compute BVH fallback may be used.</li>
<li>Dispatch a ray-gen kernel that, for each unique vertexId in the microtri mesh, traces rays to integrate incoming radiance (direct via NEE + BSDF sampling, indirect via path continuation). Write irradiance (rgb) into the vertex lighting buffer at vertexId.</li>
<li>MIS for area lights and environment; Fresnel-aware BSDF sampling; Russian roulette after rrStartBounce. Optionally output moments/variance for adaptive temporal filtering.</li>
</ul>
</li>
<li>Synchronization and data flow:<ul>
<li>Double-buffer the vertex lighting buffer: while raster reads buffer A, GPU RT writes buffer B; swap atomically at frame end. Latch RenderSettings and snapshot revision at frame start.</li>
</ul>
</li>
<li>Temporal accumulation and denoise:<ul>
<li>If progressiveAccumulation, accumulate per-vertex irradiance across frames using vertexId and motion-aware reprojection where available. Clamp variance to reduce ghosting.</li>
</ul>
</li>
<li>Budgets and fallbacks:<ul>
<li>Enforce maxMicrotrisPerFrame and raysPerVertex; adapt tessellation density and/or spp when over budget. If useHardwareRT=Auto and unavailable, either skip RT lighting (fallback to ambient/baseColor) or use the compute fallback if enabled.</li>
</ul>
</li>
</ul>
<p>Data and API changes:</p><ul>
<li>RenderSettings:<ul>
<li>Add MicrotriRT struct as above.</li>
</ul>
</li>
<li>Snapshot builder:<ul>
<li>Add microtriangle tessellator; emit per-view microtri vertex/index buffers with stable vertexIds.</li>
</ul>
</li>
<li>Renderer outputs:<ul>
<li>output/v1/common/: add { vertexLightingEpoch, microtriCount }</li>
<li>output/v1/buffers/: optional debug dumps of microtri meshes and lighting buffers (debug builds)</li>
</ul>
</li>
<li>Scene schema:<ul>
<li>Add declarative SDF node types for UI (rect/rrect, text SDF, path SDF, composition ops) with parameters; builder performs isosurface contouring to triangles.</li>
<li>Support tetrahedral mesh nodes for non-UI content with material regions; surface extraction is derived at build time.</li>
<li>Mesh nodes remain supported; PBR materials apply uniformly across SDF-derived, tet-derived, and explicit meshes.</li>
</ul>
</li>
</ul>
<p>Atomicity and threading:</p><ul>
<li>RT lighting is computed per frame with double-buffered publish; raster always consumes a complete, immutable lighting buffer for that frame.</li>
</ul>
<p>Culling and bounds:</p><ul>
<li>CPU frustum cull source primitives pre-tessellation; microtri meshes are view-local and not persisted between frames.</li>
</ul>
<p>Validation and safety:</p><ul>
<li>Validate rrStartBounce ≤ maxBounces; enforce budgets; ensure BSDF parameters are energy-conserving.</li>
</ul>
<p>Performance targets:</p><ul>
<li>1080p: ≈1px microtris with 1–2 rays/vertex on modern RT hardware within present budgets; progressive accumulation improves quality over time.</li>
</ul>
<p>Tests:</p><ul>
<li>Microtri density and budget control; fixed-seed determinism for per-vertex lighting; clean fallback when hardware RT is unavailable; concurrency loop=15 remains green.</li>
</ul>
<p>Docs and examples:</p><ul>
<li>Add “Hybrid Microtri + RT” to <a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a> with dataflow and buffer lifetimes; provide sample scenes showing area lights, glossy/refraction, and environment lighting.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md121"></a>
Decision: Snapshot Builder (resolved)</h1>
<p>Summary:</p><ul>
<li>Maintain the previous snapshot in memory and apply targeted patches for small changes; perform full rebuilds only on global invalidations or when fragmentation/cost crosses thresholds</li>
</ul>
<p>Approach:</p><ul>
<li>Patch-first: per-node dirty bits (`STRUCTURE`, `LAYOUT`, `TRANSFORM`, `VISUAL`, `TEXT`, `BATCH`) and epoch counters to skip up-to-date nodes</li>
<li>Copy-on-write: assemble new revisions by reusing unchanged SoA arrays/chunks; only modified subtrees allocate new chunks</li>
<li>Text shaping cache: key by `font+features+script+dir+text`; re-shape only dirty runs</li>
<li>Chunked draw lists per subtree with k-way merge; re-bucket only affected chunks</li>
</ul>
<p>Full rebuild triggers:</p><ul>
<li>Global params changed (DPI/root constraints/camera/theme/color space/font tables)</li>
<li>Structure churn: inserts+removes &gt; 15% or reparent touch &gt; 5% of nodes</li>
<li>Batching churn: moved draw ops &gt; 30% or stacking contexts change broadly</li>
<li>Fragmentation: tombstones &gt; 20% in nodes/draw chunks</li>
<li>Performance: 3 consecutive frames over budget, or <span class="tt">patch_ms ≥ 0.7 × last_full_ms</span></li>
<li>Consistency violation detected by validations</li>
</ul>
<p>Publish/GC:</p><ul>
<li>Atomic write to <span class="tt">builds/&lt;rev&gt;.staging</span> then rename; update <span class="tt">current_revision</span> atomically</li>
<li>Retain last 3 revisions or 2 minutes; defer GC while a renderer references an older revision</li>
</ul>
<p>Notes:</p><ul>
<li>Renderer behavior is unchanged; it consumes the latest revision agnostic to patch vs rebuild</li>
<li>If any core semantics change, reflect them in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> and update tests accordingly</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md122"></a>
Decision: Direct-to-Window targets (resolved)</h1>
<p>Summary:</p><ul>
<li>Add a Direct-to-Window target mode for single-view performance-critical cases to bypass the offscreen surface → present blit and reduce latency.</li>
</ul>
<p>Semantics:</p><ul>
<li>Target kind: introduce a new target kind windows for direct-to-window rendering.</li>
<li>Single consumer: one view binds to a windows target at a time; binding a second view is invalid.</li>
<li>Sizing and reconfigure: size derives from the window’s drawable/swapchain; window resizes trigger reconfigure and update desc/active.</li>
<li>Present policy: buffered presentation only (AlwaysLatestComplete or PreferLatestCompleteWithBudget). AlwaysFresh is allowed only if backend can wait without blocking the UI thread.</li>
<li>Adoption and threading: renderer latches current_revision per frame; present occurs on the platform’s UI/present thread.</li>
</ul>
<p>Descriptors:</p><ul>
<li>WindowBackbufferDesc:<ul>
<li>swapchain: { min_images:uint, present_mode: Fifo | Mailbox | Immediate }</li>
<li>pixel_format (enum), color_space (enum)</li>
</ul>
</li>
<li>desc/active mirrors chosen swapchain parameters (image count, size, format, color_space).</li>
</ul>
<p>GPU specifics:</p><ul>
<li>Metal: render directly into CAMetalDrawable.texture and present via presentDrawable on the UI thread.</li>
<li>Vulkan: own swapchain; render into acquired image; handle VK_SUBOPTIMAL_KHR and VK_ERROR_OUT_OF_DATE_KHR by recreating the swapchain.</li>
</ul>
<p>Status and errors:</p><ul>
<li>status/* includes device_lost, drawable_unavailable, suboptimal_swapchain, and message.</li>
<li>On invalid multi-bind, set an error status and write output/v1/common/lastError.</li>
</ul>
<p>Tests and metrics:</p><ul>
<li>Verify desc/active reflects window changes; device-lost/suboptimal recovery; skip present when drawable unavailable.</li>
<li>Latency microbenchmarks comparing windows targets vs offscreen+blit.</li>
</ul>
<p>Cross-reference:</p><ul>
<li>Update Target keys to include windows.</li>
<li>Document backend nuances under GPU backend architecture.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md123"></a>
Decision: Present Policy (resolved)</h1>
<p>Summary:</p><ul>
<li>Presenters use a backend-aware policy to choose between waiting for a fresh frame and showing the latest completed output. The HTML adapter ignores policy (always presents latest complete).</li>
<li>Modes:<ul>
<li>AlwaysFresh — wait up to a tight deadline for a new frame; otherwise skip present (don’t show stale).</li>
<li>PreferLatestCompleteWithBudget (default) — wait within a small staleness budget; else present last-complete.</li>
<li>AlwaysLatestComplete — never wait; present whatever is complete now.</li>
</ul>
</li>
<li>Software renderer supports an optional Progressive Present mode for low latency (shared framebuffer with tile seqlock and partial blits). GPU paths align waits to vsync and prefer reusing the last-complete texture over blocking the UI thread.</li>
<li>Configuration is per view: windows/&lt;win&gt;/views/&lt;view&gt;/present/{policy, params}; Builders may provide per-call overrides.</li>
<li>Metrics: output/v1/common includes presentedRevision, presentedAgeMs, presentedMode, stale, waitMs; GPU may add skippedPresent and drawableUnavailable.</li>
</ul>
<p>Cross-reference:</p><ul>
<li>Full semantics, parameters, and progressive mode details are specified in <a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a> under:<ul>
<li>“UI/Rendering — Present Policy (backend-aware)”</li>
<li>“Software Renderer — Progressive Present (non-buffered)”</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md124"></a>
Decision: Text shaping, bidi, and font fallback (resolved)</h1>
<p>Summary:</p><ul>
<li>Standardize on HarfBuzz + FreeType for Unicode shaping and font loading on Windows, macOS, iOS, Android, and Linux.</li>
<li>Use MSDF atlases for medium/large/zooming text and stylized effects; use per-size bitmap atlases (FreeType raster) for very small text requiring hinting/LCD subpixel AA (desktop).</li>
<li>Build glyphs on demand with a non-blocking glyph cache and dynamic atlas; re-render regions as missing glyphs land.</li>
</ul>
<p>Approach:</p><ul>
<li>Shaping:<ul>
<li>HarfBuzz shapes runs with script, direction (UAX#9 bidi), language, and OpenType features; outputs glyph ids, advances, offsets, clusters.</li>
<li>Cache shaped runs keyed by <span class="tt">{fontFace+features+script+direction+text}</span>; invalidate on style/font change.</li>
</ul>
</li>
<li>Atlases:<ul>
<li>MSDF generation from FreeType outlines (msdfgen or equivalent). Choose <span class="tt">pxRange</span> 8–12 (UI) or 12–16 (heavy zoom); padding ≥ ceil(pxRange)+2 texels.</li>
<li>Separate pages by <span class="tt">{fontFace, pxRange}</span>; pack with skyline/guillotine; generate mipmaps. Evict via LRU; persist pages on disk keyed by <span class="tt">{font hash, face index, style, pxRange, tool versions}</span>.</li>
<li>Small text threshold (~16–20 px): switch to bitmap atlases (optional LCD subpixel on desktop).</li>
</ul>
</li>
<li>Miss handling:<ul>
<li>During draw, render present glyphs; enqueue missing glyphs to a worker queue (outline → MSDF → pack → subresource upload). Mark affected runs/regions dirty and re-render next frame.</li>
<li>Optional temporary grayscale bitmap fallback while MSDF bakes for user-visible inputs.</li>
</ul>
</li>
<li>Fallback strategy:<ul>
<li>Accept CSS-like font family lists; resolve fallback per script. Ship a curated Noto set for coverage; optionally consult platform registries for system fallback.</li>
<li>Include variable font axis tuples in cache keys when used; support COLR/CPAL/emoji via bitmap path (not MSDF).</li>
</ul>
</li>
<li>Cross-platform and build:<ul>
<li>Dependencies: HarfBuzz (shaping), FreeType (outlines/raster), optional ICU (line breaking/script/lang hints).</li>
<li>CMake flags (suggested): <span class="tt">PATHSPACE_TEXT_HARFBUZZ</span>, <span class="tt">PATHSPACE_TEXT_FREETYPE</span>, <span class="tt">PATHSPACE_TEXT_ICU</span> (optional). On Apple, CoreText may be used for discovery only.</li>
</ul>
</li>
<li>Rendering:<ul>
<li>TextGlyphs commands carry per-glyph UVs, page id, plane bounds, <span class="tt">pxRange</span>, and placement; shader decodes MSDF (median RGB) with <span class="tt">fwidth</span> for crisp edges, supports outline/glow via threshold offsets.</li>
</ul>
</li>
</ul>
<p>Tests and metrics:</p><ul>
<li>Golden tests for Latin (kern/lig), Arabic (joining+bidi), Devanagari (reordering), CJK; include fallback spans and variable font axes.</li>
<li>Metrics: shapedRunCache hit/miss, atlas hit/miss, bake/upload latency, evictions, LCD downgrade counts.</li>
</ul>
<p>Cross-references:</p><ul>
<li>Update <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> to document <span class="tt">TextShaper</span>/atlas abstractions and builder style fields (<span class="tt">font_family</span>, <span class="tt">font_size_px</span>, <span class="tt">font_features</span>, <span class="tt">lang</span>, <span class="tt">direction</span>, <span class="tt">wrap_mode</span>).</li>
<li>Keep snapshot schema stable; <span class="tt">TextGlyphs</span> payload includes atlas and <span class="tt">pxRange</span> metadata.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md125"></a>
Decision: Entity Residency and Snapshot Storage Policy (resolved)</h1>
<p>Summary:</p><ul>
<li>Entities are renderer-facing, renderable projections of authoritative domain objects that live elsewhere (e.g., physics/simulation). The renderer does not own or serve data back to other systems.</li>
<li>Each resource (geometry/material/texture/etc.) referenced by an Entity has a configurable residency/storage policy expressed as standard PathSpace values. The backend (RAM, shared memory, filesystem, GPU) is selected internally per item based on policy and platform.</li>
<li>Snapshot publish/adopt semantics remain uniform: builders publish a complete subtree under <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;</span> and atomically update <span class="tt">scenes/&lt;sid&gt;/current_revision</span>; renderers latch <span class="tt">current_revision</span> per frame and read immutable values only.</li>
</ul>
<p>Per-item residency policy (values under authoring/resources):</p><ul>
<li>Keys (examples):<ul>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/allowed = ["gpu","ram","disk"]</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/preferred = ["gpu","ram"]</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/durability = "ephemeral|cacheable|durable"</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/max_bytes = &lt;uint64&gt;</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/cache_priority = &lt;uint32&gt;</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/src/resources/&lt;rid&gt;/policy/residency/eviction_group = "textures|geometry|materials|other"</span></li>
</ul>
</li>
<li>Semantics:<ul>
<li>allowed/preferred constrain and order backend selection; durability controls restart survivability (non-ephemeral items are reloadable after a renderer crash/restart).</li>
<li>max_bytes guides admission/eviction; cache_priority and eviction_group control pressure handling within watermarks.</li>
</ul>
</li>
</ul>
<p>Storage backends (opaque to callers; exposed as normal PathSpace values):</p><ul>
<li>RAM: process-local; fastest; not crash-safe; selected only when allowed and durability permits.</li>
<li>SHM (shared memory): cross-process crash-safe; avoids disk IO; size-limited; selected when durability requires and within thresholds.</li>
<li>Filesystem: staging + fsync + atomic exposure behind PathSpace; chosen for large or durable items and when SHM is unavailable.</li>
<li>GPU: device-local residency for draw-time; backed by RAM/SHM/FS per policy for reload; eviction respects watermarks.</li>
</ul>
<p>Authoring concurrency (proposed vs resolved):</p><ul>
<li>Producers write to <span class="tt">scenes/&lt;sid&gt;/src/objects/&lt;oid&gt;/proposed/&lt;source&gt;/&lt;component&gt;/*</span> (e.g., <span class="tt">physics</span>, <span class="tt">script</span>).</li>
<li>A coalescer resolves to <span class="tt">scenes/&lt;sid&gt;/src/objects/&lt;oid&gt;/resolved/&lt;component&gt;/*</span> using a per-component policy (ownership, priority, or merge). Resolved components carry epochs for MVCC.</li>
<li>The snapshot builder latches a consistent <span class="tt">resolved/*</span> view (by epochs) and emits <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/entities/*</span> and <span class="tt">.../resources/*</span>. Mid-build changes affect the next revision.</li>
</ul>
<p>Atomicity and adoption:</p><ul>
<li>Builders write under <span class="tt">builds/&lt;rev&gt;.staging/*</span> then atomically expose as <span class="tt">builds/&lt;rev&gt;</span> via the runtime’s atomic subtree swap/alias (or FS rename internally). Finally, they atomically set <span class="tt">current_revision = &lt;rev&gt;</span>.</li>
<li>Renderers latch <span class="tt">current_revision</span> at frame start; no mid-frame reads; outputs are written under <span class="tt">targets/&lt;tid&gt;/output/v1/*</span>.</li>
</ul>
<p>Crash-restart:</p><ul>
<li>Items with durability ≠ <span class="tt">ephemeral</span> are re-openable by a new renderer process using only standard PathSpace reads; the runtime maps the correct backend (SHM/FS) internally.</li>
</ul>
<p>Watermarks and GC:</p><ul>
<li>Residency honors the existing “Renderer cache watermarks (resolved)” for CPU/GPU caches.</li>
<li>Snapshot retention and safety continue to follow “Snapshot GC and Leases (resolved)”.</li>
</ul>
<p>Tests:</p><ul>
<li>Backend-agnostic publish/adopt remains atomic; no partial visibility of <span class="tt">.staging</span>.</li>
<li>Crash-restart rehydrates durable resources; ephemeral items are repopulated by producers.</li>
<li>Residency decisions respect allowed/preferred and watermarks; eviction degrades gracefully (e.g., proxy textures).</li>
</ul>
<p>Cross-reference:</p><ul>
<li>Update <a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a> to reflect Entity residency keys and the proposed/resolved authoring model. Keep existing path shapes and invariants intact.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md126"></a>
Decision: Snapshot GC and Leases (resolved)</h1>
<p>Summary:</p><ul>
<li>Automate cleanup of scene snapshot revisions while guaranteeing no renderer reads a deleted revision.</li>
<li>Use per-target short-ttl leases; GC respects leases plus K/T retention thresholds; publish/adopt remain atomic.</li>
</ul>
<p>Protocol:</p><ul>
<li>Publish:<ul>
<li>Builder writes to <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;.staging/*</span>, fsyncs, atomically renames to <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;</span>, then atomically updates <span class="tt">scenes/&lt;sid&gt;/current_revision</span> to <span class="tt">&lt;rev&gt;</span>.</li>
</ul>
</li>
<li>Adopt (per frame):<ul>
<li>Renderer latches <span class="tt">current_revision = R</span> once at frame start and reads exclusively from <span class="tt">scenes/&lt;sid&gt;/builds/&lt;R&gt;/...</span> for the entire frame.</li>
<li>Renderer creates or refreshes a lease under <span class="tt">scenes/&lt;sid&gt;/leases/&lt;rendererId&gt;/&lt;targetId&gt;</span> with <span class="tt">{ rev: R, expires_at_ms: now + ttl_ms, epoch: inc }</span>.</li>
<li>On shutdown it deletes its lease; on crash, the lease naturally expires (ttl).</li>
</ul>
</li>
</ul>
<p>Retention policy (defaults):</p><ul>
<li>Retain by count: keep last K revisions (default K = 3).</li>
<li>Retain by time: keep revisions newer than T minutes (default T = 2m).</li>
<li>Lease safety: never delete <span class="tt">current_revision</span> or any revision referenced by a non-expired lease.</li>
<li>Always retain at least one revision even if rules would allow more deletion.</li>
</ul>
<p>Lease keys and timing:</p><ul>
<li>Path: <span class="tt">scenes/&lt;sid&gt;/leases/&lt;rendererId&gt;/&lt;targetId&gt;</span></li>
<li>Value: <span class="tt">{ rev:uint64, expires_at_ms:uint64 (monotonic), epoch:uint64 }</span></li>
<li>Recommended defaults:<ul>
<li><span class="tt">lease_ttl_ms = 3000</span> (must exceed max frame/present latency)</li>
<li><span class="tt">min_refresh_ms = 250</span> (coalesce lease writes; also refresh when <span class="tt">rev</span> changes)</li>
</ul>
</li>
</ul>
<p>GC algorithm (idempotent, crash-safe):</p><ul>
<li>Enumerate <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;</span> (uint64 increasing).</li>
<li>Determine active leases where <span class="tt">expires_at_ms &gt; now_ms</span>; compute <span class="tt">minActiveLeaseRev</span> if any.</li>
<li>Compute cutoff by count/time; effective cutoff = min(countCutoff, timeCutoff, minActiveLeaseRev if present).</li>
<li>For each rev older than cutoff:<ul>
<li>Skip <span class="tt">current_revision</span>, any rev in active lease set, and any <span class="tt">*.staging</span>.</li>
<li>Atomically rename <span class="tt">builds/&lt;rev&gt;</span> → <span class="tt">builds/&lt;rev&gt;.todelete</span>, then recursively delete <span class="tt">*.todelete</span> (retry-safe).</li>
</ul>
</li>
<li>Never touch the currently publishing <span class="tt">.staging</span> or the latest live revision.</li>
</ul>
<p>Observability (optional but recommended):</p><ul>
<li><span class="tt">scenes/&lt;sid&gt;/gc/lastRunMs: double</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/gc/reclaimedCount: uint32</span>, <span class="tt">scenes/&lt;sid&gt;/gc/retainedCount: uint32</span></li>
<li><span class="tt">scenes/&lt;sid&gt;/gc/reason: string</span> (e.g., "count", "time", "lease")</li>
<li>Per-revision metadata (optional): <span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/.meta { created_at_ms:uint64, size_bytes:uint64 }</span></li>
</ul>
<p>Configuration (per scene):</p><ul>
<li><span class="tt">scenes/&lt;sid&gt;/settings/gc { keep_last:int=3, keep_ms:int=120000, lease_ttl_ms:int=3000, min_refresh_ms:int=250 }</span></li>
</ul>
<p>Invariants:</p><ul>
<li>Builders publish via <span class="tt">.staging</span> → live rename, then update <span class="tt">current_revision</span> atomically.</li>
<li>Renderers read only from the latched revision for a frame; adoption is lock-free post-latch.</li>
<li>GC never deletes <span class="tt">current_revision</span> or revisions protected by non-expired leases.</li>
</ul>
<p>Test considerations:</p><ul>
<li>Concurrency: rapid publish while multiple renderers render; assert no deleted-read.</li>
<li>Crash: set lease, crash renderer; ensure GC reclaims only after lease expiry.</li>
<li>Churn: high-frequency revisions; validate K/T retention and never deleting <span class="tt">current_revision</span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md127"></a>
Decision: IO logging and stdout/stderr mirrors (resolved)</h1>
<p>Summary:</p><ul>
<li>Each application writes errors and other levels to authoritative per-app log paths under <span class="tt">&lt;app&gt;/io/log/*</span>; read-only mirrors forward to per-app stdout/stderr and then to global system streams. All logs are bounded rings.</li>
</ul>
<p>Authoritative per-app logs</p><ul>
<li><span class="tt">&lt;app&gt;/io/log/error</span> — the only write target for error text (UTF-8, newline-delimited)</li>
<li><span class="tt">&lt;app&gt;/io/log/info</span>, <span class="tt">&lt;app&gt;/io/log/debug</span> (optional), etc.</li>
<li>Apps write only to <span class="tt">&lt;app&gt;/io/log/*</span>; mirrors are derived.</li>
</ul>
<p>Mirrors and aggregation</p><ul>
<li>Local mirrors (read-only to apps):<ul>
<li><span class="tt">&lt;app&gt;/io/stderr</span> — tails <span class="tt">&lt;app&gt;/io/log/error</span> and appends the same bytes</li>
<li><span class="tt">&lt;app&gt;/io/stdout</span> — tails <span class="tt">&lt;app&gt;/io/log/info</span> (and optionally debug) and appends the same bytes</li>
</ul>
</li>
<li>Global mirrors (system-owned):<ul>
<li><span class="tt">/system/io/stderr</span> — tails every <span class="tt">&lt;app&gt;/io/stderr</span>; prefixes provenance <span class="tt">[app=&lt;app-path&gt;]</span></li>
<li><span class="tt">/system/io/stdout</span> — tails every <span class="tt">&lt;app&gt;/io/stdout</span>; prefixes provenance</li>
</ul>
</li>
<li>Forwarders maintain durable offsets; if they lag beyond eviction, they fast-forward and increment a loss counter.</li>
</ul>
<p>Semantics</p><ul>
<li>Encoding: UTF-8 only; replace invalid sequences with U+FFFD.</li>
<li>Framing: newline-delimited lines; CRLF normalized to LF; partial lines buffered until LF.</li>
<li>Non-blocking: writers never block on mirrors; forwarding is best-effort.</li>
<li>Level routing: INFO/DEBUG → stdout; WARN/ERROR/FATAL → stderr.</li>
</ul>
<p>Bounded retention (caps)</p><ul>
<li>Every log place is a bounded ring with at least:<ul>
<li><span class="tt">max_messages</span>: hard cap on retained complete lines</li>
<li>Optional: <span class="tt">max_bytes</span> and <span class="tt">max_age_ms</span></li>
</ul>
</li>
<li>Eviction policy: drop oldest whole messages to satisfy caps; track <span class="tt">dropped_oldest_total</span>.</li>
<li>Status/metrics per path:<ul>
<li><span class="tt">status/current_messages</span>, <span class="tt">status/max_messages</span>, <span class="tt">status/committed_messages_total</span>, <span class="tt">status/dropped_oldest_total</span>, <span class="tt">status/lag_bytes</span> (mirrors), <span class="tt">status/lost_to_forwarder_total</span>, <span class="tt">status/last_eviction_ms</span></li>
</ul>
</li>
<li>Recommended defaults (tunable per deployment):<ul>
<li><span class="tt">&lt;app&gt;/io/log/error</span>: 10k; <span class="tt">&lt;app&gt;/io/log/info</span>: 20k; <span class="tt">&lt;app&gt;/io/stderr</span>: 20k; <span class="tt">/system/io/stderr</span>: 1M.</li>
</ul>
</li>
</ul>
<p>ACLs and safety</p><ul>
<li>Writes:<ul>
<li>App → <span class="tt">&lt;app&gt;/io/log/*</span> only</li>
<li>Local tee → <span class="tt">&lt;app&gt;/io/std{out,err}</span></li>
<li>System aggregator → <span class="tt">/system/io/std{out,err}</span></li>
</ul>
</li>
<li>Readers: app devs/tools read app-local logs; ops/admin tools read system logs.</li>
<li>Loop prevention: local tee reads only from <span class="tt">&lt;app&gt;/io/log/*</span>; aggregator reads only from <span class="tt">&lt;app&gt;/io/std{out,err}</span>.</li>
</ul>
<p>Interop with renderer observability</p><ul>
<li>When a renderer updates <span class="tt">output/v1/common/lastError</span> (or trace), emit a concise one-line to <span class="tt">&lt;app&gt;/io/log/error</span> (once per change) with a corr tag <span class="tt">(rendererId:targetId:frameIndex)</span> for correlation.</li>
<li>Keep structured, per-target metrics under <span class="tt">renderers/&lt;rid&gt;/targets/.../output/v1/*</span>; the <span class="tt">io/*</span> streams remain text-only.</li>
</ul>
<p>Failure behavior</p><ul>
<li>If a mirror or aggregator is down, authoritative logs continue; upon restart, forwarders resume from durable offsets or fast-forward if necessary (with loss accounting).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md128"></a>
Decision: Resource system (resolved)</h1>
<p>Summary:</p><ul>
<li>Canonical app asset namespace with deterministic references in snapshots.</li>
<li>Snapshot-local asset table keyed by content digest (sha256); renderer caches by digest across targets.</li>
<li>Async load/decode with fallback behavior; eviction via LRU with pins for in-use revisions.</li>
</ul>
<p>App asset layout (under the app root):</p><ul>
<li>Images: <span class="tt">&lt;app&gt;/assets/images/&lt;name&gt;/{data,meta.json}</span></li>
<li>Fonts: <span class="tt">&lt;app&gt;/assets/fonts/&lt;family&gt;/&lt;style&gt;/{file,meta.json}</span></li>
<li>Shaders: <span class="tt">&lt;app&gt;/assets/shaders/&lt;name&gt;/{msl|spirv,meta.json}</span></li>
</ul>
<p>meta.json (per asset):</p><ul>
<li>Common: <span class="tt">{ digest_sha256, byte_size, created_at, updated_at }</span></li>
<li>Images: <span class="tt">{ color_space: "sRGB|DisplayP3|Linear", premultiplied: bool, icc_embedded: bool, width, height, format }</span></li>
<li>Fonts: <span class="tt">{ family, style, weight, stretch, format: "ttf|otf|woff2", index? }</span></li>
<li>Shaders: <span class="tt">{ stage, language, compiler, defines[] }</span></li>
</ul>
<p>Snapshot integration (per revision):</p><ul>
<li><span class="tt">scenes/&lt;sid&gt;/builds/&lt;rev&gt;/assets/index.json</span> lists assets used by the snapshot:<ul>
<li><span class="tt">[{ kind: "image|font|shader", logical: "images/&lt;name&gt;" | "fonts/&lt;family&gt;/&lt;style&gt;" | "shaders/&lt;name&gt;", digest_sha256, local_id }]</span></li>
</ul>
</li>
<li>Drawable/material payloads reference <span class="tt">local_id</span> (not paths) for stability and compactness.</li>
<li>Snapshots do not embed raw asset bytes; renderers resolve <span class="tt">digest_sha256</span> via caches.</li>
</ul>
<p>Renderer cache behavior:</p><ul>
<li>Key: <span class="tt">digest_sha256</span> (content-addressed).</li>
<li>Async load/decode off-thread on first use; pin assets referenced by the latched revision until frame end.</li>
<li>Eviction: LRU with soft/hard watermarks; separate pools for CPU (software) and GPU.</li>
<li>Fallbacks on miss:<ul>
<li>Images: placeholder draw + single error message per target/revision in <span class="tt">output/v1/common/lastError</span>.</li>
<li>Fonts: configured fallback family/style; mark degraded text via debug flags.</li>
</ul>
</li>
</ul>
<p>Authoring references and helpers:</p><ul>
<li>Nodes:<ul>
<li>Image: <span class="tt">.src = "assets/images/&lt;name&gt;"</span></li>
<li>Text: <span class="tt">.font = { family, style, weight }</span> resolved to <span class="tt">assets/fonts/...</span></li>
</ul>
</li>
<li>Builders.hpp additions:<ul>
<li><span class="tt">upload_image(...) -&gt; "assets/images/&lt;name&gt;"</span></li>
<li><span class="tt">register_font(...) -&gt; "assets/fonts/&lt;family&gt;/&lt;style&gt;"</span></li>
</ul>
</li>
</ul>
<p>Change detection and incremental rebuilds:</p><ul>
<li>Writers update <span class="tt">{data,meta.json}</span> atomically and bump a small <span class="tt">assets/index</span> counter.</li>
<li>Snapshot builder watches <span class="tt">assets/*</span>; on change:<ul>
<li>Mark affected nodes <span class="tt">contentEpoch++</span>.</li>
<li>Invalidate text shaping cache entries keyed by <span class="tt">{font+features+script+dir+text}</span> when fonts change.</li>
<li>Rebuild only impacted draw payloads; publish a new revision.</li>
</ul>
</li>
</ul>
<p>Color pipeline integration:</p><ul>
<li>Respect <span class="tt">meta.color_space</span> and <span class="tt">premultiplied</span>.</li>
<li>Decode to linear working space or sample from sRGB textures with automatic decode.</li>
<li>Set <span class="tt">pipelineFlags</span> appropriately (<span class="tt">SrgbFramebuffer</span>, <span class="tt">UnpremultipliedSrc</span> conversion when required).</li>
</ul>
<p>Failure modes and observability:</p><ul>
<li>Missing asset path during build: emit placeholder entry and authoring error; renderer surfaces concise status in <span class="tt">output/v1/common/lastError</span>.</li>
<li>Decode failure: cache records digest→error; avoid repeated work until files change.</li>
</ul>
<p>Metrics (debug):</p><ul>
<li><span class="tt">assetsLoaded</span>, <span class="tt">assetsPending</span>, <span class="tt">assetBytesResident</span>, <span class="tt">assetEvictions</span>.</li>
</ul>
<p>Minimal tests:</p><ul>
<li>sRGB vs Linear PNG render goldens (color correctness).</li>
<li>Font registration + mixed-script shaping; verify cache invalidation after font swap.</li>
<li>Live image asset change triggers partial snapshot rebuild without tearing.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md129"></a>
Decision: Renderer cache watermarks (resolved)</h1>
<p>Summary:</p><ul>
<li>Bound renderer memory with soft/hard watermarks for CPU- and GPU-resident caches. Evict cold items predictably to avoid OOM and stalls, while pinning assets referenced by the latched revision for frame safety.</li>
</ul>
<p>Scope:</p><ul>
<li>CPU cache: decoded images, procedurally generated outputs, shaped text/MSDF atlas pages, prepared geometry blobs.</li>
<li>GPU cache: textures/atlas pages, vertex/index/uniform buffers, optional intermediates. Pipeline/descriptor caches are small and not watermark-managed in v1.</li>
</ul>
<p>Configuration (per renderer):</p><ul>
<li>Path: <span class="tt">renderers/&lt;rid&gt;/settings/cache</span><ul>
<li><span class="tt">cpu_soft_bytes: uint64</span></li>
<li><span class="tt">cpu_hard_bytes: uint64</span></li>
<li><span class="tt">gpu_soft_bytes: uint64</span></li>
<li><span class="tt">gpu_hard_bytes: uint64</span></li>
<li>Optional per-kind caps (v1 optional): <span class="tt">text_atlas_soft_bytes</span>, <span class="tt">image_soft_bytes</span>, etc.</li>
</ul>
</li>
</ul>
<p>Semantics:</p><ul>
<li>Soft watermark: when resident_bytes &gt; soft, begin background eviction (LRU or size-aware LRU) until below soft.</li>
<li>Hard watermark: if an allocation/upload would exceed hard, perform synchronous eviction; if still over, deny/skip the allocation and surface a concise error. Placeholders are allowed to render.</li>
<li>Pinning: assets referenced by the currently latched <span class="tt">revision</span> are pinned until frame end and cannot be evicted; optionally pin a small MRU window to reduce churn.</li>
<li>Eviction policy: maintain per-kind LRU lists to prevent large images from evicting text infrastructure first; prefer evicting largest-cold items. Never evict pinned or in-flight items.</li>
<li>Miss handling: CPU miss triggers async decode/generation; GPU miss uploads when CPU bytes become ready. Render placeholders until assets land.</li>
</ul>
<p>Defaults (starting points):</p><ul>
<li>Desktop dev: CPU soft 256 MiB, hard 512 MiB; GPU soft 256 MiB, hard 512 MiB.</li>
<li>Constrained/iGPU: CPU soft 128 MiB, hard 256 MiB; GPU soft 128 MiB, hard 256 MiB.</li>
<li>Implementations may scale GPU watermarks by VRAM when available (e.g., reserve 5–10% for UI caches).</li>
</ul>
<p>Observability:</p><ul>
<li>Expose under <span class="tt">renderers/&lt;rid&gt;/targets/&lt;tid&gt;/output/v1/debug/cache/*</span> (debug-only):<ul>
<li><span class="tt">assetBytesResidentCPU</span>, <span class="tt">assetBytesResidentGPU</span></li>
<li><span class="tt">assetEvictionsTotal</span>, <span class="tt">assetEvictionsByKind/*</span></li>
<li><span class="tt">assetsPending</span>, <span class="tt">assetsLoaded</span></li>
<li><span class="tt">lastEvictionMs</span>, <span class="tt">lastEvictionReason</span></li>
</ul>
</li>
<li>On hard watermark denial or repeated thrash, set <span class="tt">targets/&lt;tid&gt;/output/v1/common/lastError</span> once per change.</li>
</ul>
<p>Tests:</p><ul>
<li>Watermark eviction stress: exceed soft via many assets; assert background eviction reduces usage without stalling the frame loop.</li>
<li>Hard cap enforcement: attempt an allocation that would exceed hard; verify eviction runs, and if still over, allocation is denied and a placeholder renders with a single error line.</li>
<li>Pinning safety: mark assets as in-use by a revision; ensure no evictions until frame end.</li>
</ul>
<p>Cross-references:</p><ul>
<li>See “Decision: Resource system (resolved)” for asset digests and cache keys. This section formalizes eviction behavior and configuration.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md130"></a>
Schemas and typing (v1)</h1>
<p>This section specifies the C++ types bound to target keys and the versioning policy for renderer I/O.</p>
<p>C++ types per key:</p><ul>
<li><span class="tt">scene</span> — <span class="tt">std::string</span><ul>
<li>App-relative path to the scene root, e.g., <span class="tt">"scenes/&lt;sid&gt;"</span>. Must resolve within the same app root</li>
</ul>
</li>
<li><span class="tt">desc</span> — <span class="tt">SurfaceDesc | TextureDesc | WindowBackbufferDesc | HtmlTargetDesc</span> (per target kind)<ul>
<li><span class="tt">SurfaceDesc</span>:<ul>
<li><span class="tt">size_px { int w, int h }</span></li>
<li><span class="tt">pixel_format</span> (enum): <span class="tt">RGBA8Unorm | BGRA8Unorm | RGBA8Unorm_sRGB | BGRA8Unorm_sRGB | RGBA16F | RGBA32F</span><ul>
<li>Platform notes: on Apple/Metal, <span class="tt">BGRA8Unorm[_sRGB]</span> is the common swap/present format; the software renderer uses <span class="tt">RGBA8Unorm</span>.</li>
</ul>
</li>
<li><span class="tt">color_space</span> (enum): <span class="tt">sRGB | DisplayP3 | Linear</span><ul>
<li>Write-out obeys pipeline flags (<span class="tt">SrgbFramebuffer</span> vs <span class="tt">LinearFramebuffer</span>); sRGB textures are linearized on sample.</li>
</ul>
</li>
<li><span class="tt">premultiplied_alpha</span> (bool) — default true for UI; renderers expect premultiplied inputs. If false, sources are converted at draw time (see <span class="tt">UnpremultipliedSrc</span>).</li>
</ul>
</li>
<li><span class="tt">TextureDesc</span>:<ul>
<li><span class="tt">size_px { int w, int h }</span></li>
<li><span class="tt">pixel_format</span> (enum): <span class="tt">RGBA8Unorm | BGRA8Unorm | RGBA8Unorm_sRGB | BGRA8Unorm_sRGB | RGBA16F | RGBA32F</span></li>
<li><span class="tt">color_space</span> (enum): <span class="tt">sRGB | DisplayP3 | Linear</span></li>
<li><span class="tt">usage_flags</span> (bitmask)</li>
</ul>
</li>
<li><span class="tt">WindowBackbufferDesc</span>:<ul>
<li><span class="tt">present_mode</span> (enum: Fifo | Mailbox | Immediate)</li>
<li><span class="tt">min_images</span> (uint)</li>
<li><span class="tt">pixel_format</span> (enum): <span class="tt">BGRA8Unorm | BGRA8Unorm_sRGB | RGBA16F</span><ul>
<li>Platform notes: swapchains commonly expose <span class="tt">BGRA8Unorm</span>; availability of explicit sRGB variants is platform-dependent. When unavailable, use <span class="tt">color_space</span> plus pipeline flags for sRGB encoding.</li>
</ul>
</li>
<li><span class="tt">color_space</span> (enum): <span class="tt">sRGB | DisplayP3 | Linear</span></li>
</ul>
</li>
<li><span class="tt">HtmlTargetDesc</span>:<ul>
<li><span class="tt">size_px { int w, int h }</span></li>
<li><span class="tt">dpi_scale: float</span> (default 1.0)</li>
<li><span class="tt">prefer_dom: bool</span> (default true)</li>
<li><span class="tt">max_dom_nodes: uint32</span> (default 10000)</li>
<li><span class="tt">allow_clip_path: bool</span> (default true; safe subset only)</li>
<li><span class="tt">inline_assets: bool</span> (default false)</li>
<li><span class="tt">embed_css: bool</span> (default true)</li>
<li>Defaults: prefer DOM/CSS (Tier 1). When thresholds/fidelity require fallback, emit Canvas JSON to <span class="tt">output/v1/html/commands</span> and include CSS under <span class="tt">output/v1/html/css</span> when split.</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">desc/active</span> — mirror of the adopted descriptor (<span class="tt">SurfaceDesc | TextureDesc | WindowBackbufferDesc</span>) for introspection</li>
<li><span class="tt">settings</span> — single <span class="tt">RenderSettingsV1</span> value (atomic whole-object replace)<ul>
<li><span class="tt">RenderSettingsV1</span>:<ul>
<li><span class="tt">time { double time_ms, double delta_ms, uint64_t frame_index }</span></li>
<li><span class="tt">pacing { std::optional&lt;double&gt; user_cap_fps }</span> (effective = min(display, cap))</li>
<li><span class="tt">surface { {int w,int h} size_px, float dpi_scale, bool visibility }</span></li>
<li><span class="tt">std::array&lt;float,4&gt; clear_color</span></li>
<li><span class="tt">camera</span> (optional): <span class="tt">{ enum Projection { Orthographic, Perspective }, float zNear, float zFar }</span></li>
<li><span class="tt">debug { uint32_t flags }</span> (optional)</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">render</span> — execution that renders one frame for this target (no payload)</li>
<li><span class="tt">output/v1/common/*</span> — single-value registers with latest metadata:<ul>
<li><span class="tt">frameIndex: uint64_t</span> (monotonically increasing per target; practically non-wrapping; if wrap ever occurs, consumers must use unsigned modular comparisons)</li>
<li><span class="tt">revision: uint64_t</span> (monotonically increasing per scene; practically non-wrapping)</li>
<li><span class="tt">renderMs: double</span></li>
<li><span class="tt">lastError: std::string</span> (empty on success)</li>
</ul>
</li>
<li><span class="tt">output/v1/software/framebuffer</span> — <span class="tt">SoftwareFramebuffer</span>:<ul>
<li><span class="tt">std::vector&lt;uint8_t&gt; pixels</span></li>
<li><span class="tt">int width, int height, int stride</span></li>
<li><span class="tt">enum pixel_format</span>, <span class="tt">enum color_space</span>, <span class="tt">bool premultiplied_alpha</span></li>
</ul>
</li>
<li><span class="tt">output/v1/metal/texture</span> — <span class="tt">MetalTextureHandle</span> (opaque handle or registry id + size/format/color_space)</li>
<li><span class="tt">output/v1/vulkan/image</span> — <span class="tt">VulkanImageHandle</span> (opaque handle or registry id + size/format/color_space/layout)</li>
<li><span class="tt">output/v1/window/presentInfo</span> — <span class="tt">WindowPresentInfo</span> (no pixel payload; windows targets present directly)<ul>
<li><span class="tt">uint32_t image_count</span></li>
<li><span class="tt">enum present_mode</span></li>
<li><span class="tt">bool suboptimal</span></li>
</ul>
</li>
</ul>
<p>App-relative resolution helpers:</p><ul>
<li><span class="tt">is_app_relative(std::string_view)</span></li>
<li><span class="tt">resolve_app_relative(AppRoot, std::string_view)</span></li>
<li><span class="tt">ensure_within_app(AppRoot, std::string_view resolved)</span></li>
</ul>
<p>Versioning policy:</p><ul>
<li>Settings and descriptors: unversioned at the path level (pure C++ in-process; producers/consumers recompile together). Keep the <span class="tt">V1</span> suffix in C++ type names for source-level evolution</li>
<li>Outputs: versioned at the path level under <span class="tt">output/v1</span>. If an incompatible change is needed, add <span class="tt">output/v2</span> and keep <span class="tt">output/v1</span> during a deprecation window (update docs/tests accordingly)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md131"></a>
Target keys (final)</h1>
<p>Target base:</p><ul>
<li><span class="tt">&lt;app&gt;/renderers/&lt;rendererName&gt;/targets/&lt;kind&gt;/&lt;name&gt;</span></li>
<li><span class="tt">kind ∈ { surfaces, textures, windows, html }</span></li>
</ul>
<p>Keys under a target:</p><ul>
<li><span class="tt">scene</span> — app-relative path to the scene root to render (must resolve within the same app root)</li>
<li><span class="tt">desc</span> — descriptor for the target (<span class="tt">SurfaceDesc | TextureDesc | WindowBackbufferDesc | HtmlTargetDesc</span>)</li>
<li><span class="tt">desc/active</span> — mirror written by renderer after reconfigure</li>
<li><span class="tt">status/*</span> — e.g., <span class="tt">reconfiguring</span>, <span class="tt">device_lost</span>, <span class="tt">message</span></li>
<li><span class="tt">settings</span> — single <span class="tt">RenderSettings</span> value (atomic whole-object replace)</li>
<li><span class="tt">render</span> — execution to render one frame for this target</li>
<li><span class="tt">output/v1/...</span> — latest outputs for this target:<ul>
<li><span class="tt">common/</span> — timings and metadata (<span class="tt">frameIndex</span>, <span class="tt">revision</span>, <span class="tt">renderMs</span>, <span class="tt">lastError</span>)</li>
<li><span class="tt">software/framebuffer</span> — pixel buffer + metadata (width, height, stride, format, colorSpace, premultiplied)</li>
<li><span class="tt">metal/texture</span> or <span class="tt">vulkan/image</span> — opaque GPU handles and metadata</li>
<li><span class="tt">window/presentInfo</span> — present metadata (image_count, present_mode, suboptimal)</li>
<li><span class="tt">html/dom</span>, <span class="tt">html/commands</span>, <span class="tt">html/assets/*</span> — optional web outputs</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md132"></a>
View keys (final)</h1>
<p>View base:</p><ul>
<li>&lt;app&gt;/windows/&lt;win&gt;/views/&lt;view&gt;</li>
</ul>
<p>Keys under a view:</p><ul>
<li>surface — app-relative path to renderers/&lt;rid&gt;/targets/surfaces/&lt;name&gt;</li>
<li>windowTarget — app-relative path to renderers/&lt;rid&gt;/targets/windows/&lt;name&gt;</li>
<li>present/policy — AlwaysFresh | PreferLatestCompleteWithBudget | AlwaysLatestComplete</li>
<li>present/params — backend-aware parameters such as staleness_budget_ms, frame_timeout_ms</li>
<li>status/* — latest present metadata (e.g., chosenMode, waitMs); optional</li>
</ul>
<p>Semantics:</p><ul>
<li>Exactly one of surface or windowTarget must be set at a time; switching is atomic and should notify the presenter.</li>
<li>Presenters read binding and policy once per present; no mid-present re-reads.</li>
<li>Threading: windowTarget presents must occur on the platform UI/present thread; surface blits occur on the UI thread after render completes.</li>
<li>HTML adapters ignore present policy and always present latest-complete.</li>
</ul>
<p>Cross-references:</p><ul>
<li>See “Decision: Present Policy (resolved)” for policy semantics.</li>
<li>See “Target keys (final)” for target key details.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md133"></a>
RenderSettings v1 (final)</h1>
<ul>
<li><span class="tt">time: { time_ms: double, delta_ms: double, frame_index: uint64 }</span> // frame_index is monotonically increasing per target; delta_ms reflects real elapsed time even when pacing skips frames</li>
<li><span class="tt">pacing: { user_cap_fps: optional&lt;double&gt; }</span> // effective rate = min(display refresh, user cap)</li>
<li><span class="tt">surface: { size_px:{w:int,h:int}, dpi_scale: float, visibility: bool }</span></li>
<li><span class="tt">clear_color: [float,4]</span></li>
<li><span class="tt">camera: { projection: Orthographic | Perspective, zNear:float, zFar:float }</span> (optional)</li>
<li><span class="tt">debug: { flags: uint32 }</span> (optional)</li>
</ul>
<p>Invariants:</p><ul>
<li>Writers replace the entire <span class="tt">RenderSettings</span> at <span class="tt">settings</span> in a single atomic write (single-path whole-object)</li>
<li>Renderer latches the <span class="tt">settings</span> value once at frame start and uses it for the duration of the frame; mid-frame writes do not affect the in-flight frame (adoption occurs next frame)</li>
<li>Multi-producer policy (final): there is no server-side merge/queue in v1; producers must aggregate/coalesce on the client side and perform one atomic replace (last-writer-wins at the single path)</li>
<li><span class="tt">scene</span> paths are app-relative and must resolve to within the same application root</li>
<li><span class="tt">output/v1</span> contains only the latest render result for the target</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md134"></a>
Glossary</h1>
<ul>
<li>App root: <span class="tt">/system/applications/&lt;app&gt;</span> or <span class="tt">/users/&lt;user&gt;/system/applications/&lt;app&gt;</span></li>
<li>App-relative path: a path string without leading slash, resolved against the app root</li>
<li>Renderer target: a per-consumer subtree under <span class="tt">renderers/&lt;id&gt;/targets/&lt;kind&gt;/&lt;name&gt;</span></li>
<li>Snapshot: immutable render-ready representation of a scene at a point in time (<span class="tt">revision</span>)</li>
<li>Revision: monotonically increasing version used for atomic publish/adoption</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md135"></a>
Cross-references</h1>
<ul>
<li>Update <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> when changes affect core behavior (paths, NodeData, WaitMap, TaskPool, serialization). Keep examples and path references stable; if files move, update references in the same change.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md136"></a>
TODO — Clarifications and Follow-ups</h1>
<p>These items clarify edge cases or finalize small inconsistencies. Resolve and reflect updates in <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span>, tests, and any affected examples. (Items already reflected in the main text have been removed from this list.)</p>
<ul>
<li>HTML outputs: unify keys and document Canvas JSON<ul>
<li>Standardize the outputs to include:<ul>
<li><span class="tt">output/v1/html/dom</span> (HTML document string)</li>
<li><span class="tt">output/v1/html/css</span> (CSS string when split)</li>
<li><span class="tt">output/v1/html/assets/*</span> (referenced assets)</li>
<li><span class="tt">output/v1/html/commands</span> (Canvas JSON fallback stream; compact command list)</li>
</ul>
</li>
<li>Ensure “Target keys (final)” lists both <span class="tt">html/css</span> and <span class="tt">html/commands</span>.</li>
<li>In the HTML/Web section, name “Canvas JSON” explicitly and state when it is selected (node count thresholds, clip/blend fidelity limits).</li>
</ul>
</li>
<li>Progressive present: color encoding and seqlock memory model<ul>
<li>Color format:<ul>
<li>Specify the shared framebuffer pixel format and alpha convention, e.g., <span class="tt">RGBA8Unorm_sRGB</span> with premultiplied alpha. Renderer encodes linear→sRGB per tile on store; presenter blits bytes without further conversion.</li>
<li>Alternatively, define a linear float buffer and a final encode step during blit; if chosen, document the encode exactly and why.</li>
</ul>
</li>
<li>Seqlock memory ordering:<ul>
<li>Use atomics for <span class="tt">seq/pass/epoch</span>: writer increments to odd (begin), writes pixels, issues <span class="tt">release</span> fence, increments to even (end). Reader uses <span class="tt">acquire</span> loads; if <span class="tt">seq</span> changed during copy, discard the tile copy.</li>
<li>Document that <span class="tt">pass</span> transitions (OpaqueDone → AlphaDone) are published with <span class="tt">memory_order_release</span> after the corresponding tile pixels are visible.</li>
</ul>
</li>
</ul>
</li>
<li>Clip stack metadata for hit testing<ul>
<li>Persist clip stack membership per drawable to avoid re-walking the command stream:<ul>
<li>Add a per-revision clip node array (rect/path nodes) and store, per drawable, a <span class="tt">clipHeadIndex</span> into a singly-linked list of active clips.</li>
<li>Clip nodes reference either rect parameters or a range in <span class="tt">cmd-buffer.bin</span> for path geometry.</li>
</ul>
</li>
<li>Hit testing reconstructs the stack by following <span class="tt">clipHeadIndex</span> links and applies per-node tests.</li>
</ul>
</li>
<li>DrawableId mapping from authoring nodes<ul>
<li>Specify how authoring node ids map to stable <span class="tt">DrawableId</span>s across revisions:<ul>
<li>Recommend: <span class="tt">DrawableId = hash(sceneId, authoringNodeId, drawableIndexWithinNode)</span> with a generation counter on reuse.</li>
<li>Persist a mapping summary in <span class="tt">builds/&lt;rev&gt;/bucket/meta.json</span> for diagnostics and hit test routing.</li>
</ul>
</li>
</ul>
</li>
<li>sRGB attachments and linear blending<ul>
<li>Clarify that blending and shading remain in linear space even when using sRGB attachments:<ul>
<li>On APIs with sRGB formats, sampling decodes to linear and framebuffer writes encode to sRGB; do not double-encode.</li>
<li>Add a note to tests to verify no double-encoding occurs when toggling <span class="tt">SrgbFramebuffer</span>.</li>
</ul>
</li>
</ul>
</li>
<li>SurfaceDesc schema vs examples<ul>
<li>Align <span class="tt">SurfaceDesc</span> fields with examples:<ul>
<li>Examples used <span class="tt">sdesc.size = {w,h,scale}</span>; schema specifies <span class="tt">size_px {w,h}</span> and <span class="tt">dpi_scale</span> separately. Update examples or schema to be consistent and call it out here.</li>
</ul>
</li>
</ul>
</li>
<li>RenderSettings v1 vs MicrotriRT decision<ul>
<li>Decide whether <span class="tt">MicrotriRT</span> lives inside <span class="tt">RenderSettingsV1</span> or as an optional extension type under settings:<ul>
<li>If included in v1, update “RenderSettings v1 (final)” and Builders helpers.</li>
<li>If separate, document the path and versioning under <span class="tt">settings</span> (e.g., feature flags or nested struct with default-disabled semantics). </li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
