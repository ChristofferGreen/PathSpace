<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: PathSpace — Scene Graph and Renderer Plan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_a_i___plan___scene_graph___renderer.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">PathSpace — Scene Graph and Renderer Plan </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md80"></a></p>
<p>Status: Draft (planning) Scope: UI surfaces, renderers, presenters, multiple-scenes support, atomic updates Audience: Engineers building UI/rendering layers and contributors adding platform backends</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md81"></a>
Goals</h1>
<ul>
<li>Application-scoped resources: windows, scenes, renderers, and surfaces all live under a single application root so that deleting the root tears everything down.</li>
<li>Multi-scene renderers: a single renderer can render multiple scenes concurrently; consumers (surfaces/presenters) select which scene via per-target configuration.</li>
<li>Window-agnostic surfaces: surfaces are offscreen render targets (software or GPU) that can be presented by multiple windows within the same application.</li>
<li>Typed wiring: avoid brittle string concatenation via small C++ builder/helpers; prefer app-relative references and validate containment within the app root.</li>
<li>Atomicity and concurrency: adopt “prepare off-thread, publish atomically, render from immutable snapshots” for both target parameters and scene data.</li>
<li>Cross-platform path: start with software on macOS, then add Metal; keep Vulkan as a future option.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md82"></a>
Application roots and ownership</h1>
<p>Applications are mounted under:</p>
<ul>
<li>System-owned: <span class="tt">/system/applications/&lt;app&gt;</span></li>
<li>User-owned: <span class="tt">/users/&lt;user&gt;/system/applications/&lt;app&gt;</span></li>
</ul>
<p>Everything an application needs is a subtree below the app root. No cross-app sharing of surfaces or renderers. References between components are app-relative (no leading slash) and must resolve within the app root.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md83"></a>
App-internal layout (standardized)</h1>
<ul>
<li><span class="tt">scenes/&lt;scene-id&gt;/</span> — authoring tree (<span class="tt">src/...</span>), immutable builds (<span class="tt">builds/&lt;revision&gt;/...</span>), and <span class="tt">current_revision</span>.</li>
<li><span class="tt">renderers/&lt;renderer-id&gt;/</span> — renderer with per-target subtrees (multi-scene capable).</li>
<li><span class="tt">surfaces/&lt;surface-id&gt;/</span> — offscreen render targets; coordinate with a renderer target.</li>
<li><span class="tt">windows/&lt;window-id&gt;/</span> — platform window shell and views (presenters).</li>
</ul>
<p>Example (abridged):</p>
<div class="fragment"><div class="line">/system/applications/notepad/</div>
<div class="line">  scenes/</div>
<div class="line">    main/</div>
<div class="line">      src/...</div>
<div class="line">      builds/&lt;revision&gt;/...</div>
<div class="line">      current_revision</div>
<div class="line">    settings/</div>
<div class="line">      src/...</div>
<div class="line">      builds/&lt;revision&gt;/...</div>
<div class="line">      current_revision</div>
<div class="line">  renderers/</div>
<div class="line">    2d/</div>
<div class="line">      caps</div>
<div class="line">      targets/</div>
<div class="line">        surfaces/editor/</div>
<div class="line">          scene = &quot;scenes/main&quot;                # app-relative</div>
<div class="line">          desc                                 # target descriptor (SurfaceDesc/TextureDesc/HtmlTargetDesc)</div>
<div class="line">          desc/active                          # mirror written by renderer after reconfigure (optional)</div>
<div class="line">          settings/</div>
<div class="line">            inbox                              # queue of whole RenderSettings objects (write-only by producers)</div>
<div class="line">            active                             # single-value mirror written by renderer after adoption (optional)</div>
<div class="line">          render                               # Execution: render one frame for this target</div>
<div class="line">          output/</div>
<div class="line">            v1/</div>
<div class="line">              software/framebuffer             # pixels + stride</div>
<div class="line">              common/                          # timings, indices, etc.</div>
<div class="line">                frameIndex</div>
<div class="line">                revision</div>
<div class="line">                renderMs</div>
<div class="line">                lastError</div>
<div class="line">  surfaces/</div>
<div class="line">    editor/</div>
<div class="line">      renderer = &quot;renderers/2d&quot;                # app-relative reference</div>
<div class="line">      scene    = &quot;scenes/main&quot;</div>
<div class="line">      render   # Execution: coordinates with renderer target</div>
<div class="line">  windows/</div>
<div class="line">    MainWindow/</div>
<div class="line">      title = &quot;Notepad — Main&quot;</div>
<div class="line">      window  # (optional provider; platform shell)</div>
<div class="line">      views/</div>
<div class="line">        editor/</div>
<div class="line">          surface = &quot;surfaces/editor&quot;          # app-relative</div>
<div class="line">          present  # Execution: blit/draw surface into the window</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md84"></a>
Entities and responsibilities</h1>
<ul>
<li>Window (shell)<ul>
<li>Platform-native window; emits state/events (resize, focus, close).</li>
<li>Lives under <span class="tt">windows/&lt;id&gt;/window</span> as a provider. Unaware of rendering.</li>
</ul>
</li>
<li>Presenter/View (window view)<ul>
<li>Lives under <span class="tt">windows/&lt;id&gt;/views/&lt;view-id&gt;/...</span>.</li>
<li>Reads its <span class="tt">surface</span> (app-relative), optionally triggers one frame on the surface, and presents the result:<ul>
<li>Software: blit bytes to the native window.</li>
<li>Metal/Vulkan: draw textured quad sampling the offscreen texture/image into the window’s drawable/swapchain.</li>
</ul>
</li>
</ul>
</li>
<li>Surface (offscreen render target)<ul>
<li>Lives under <span class="tt">surfaces/&lt;id&gt;/...</span>.</li>
<li>Holds <span class="tt">renderer</span> and <span class="tt">scene</span> (both app-relative strings). Can be shown in any number of windows within the same app.</li>
<li><span class="tt">render</span> execution coordinates a target-scoped render with its renderer, then exposes output (framebuffer or GPU handles).</li>
</ul>
</li>
<li>Renderer (multi-scene)<ul>
<li>Lives under <span class="tt">renderers/&lt;id&gt;/...</span>.</li>
<li>Stateless w.r.t. windows; serves work per target:<ul>
<li><span class="tt">targets/&lt;target-id&gt;/scene</span> — app-relative scene path to render.</li>
<li><span class="tt">targets/&lt;target-id&gt;/settings/inbox</span> — queue of whole RenderSettings objects (atomic via insert/take).</li>
<li><span class="tt">targets/&lt;target-id&gt;/settings/active</span> — single-value mirror written by renderer after adoption (optional, for introspection).</li>
<li><span class="tt">targets/&lt;target-id&gt;/render</span> — execution that renders one frame for this target.</li>
<li><span class="tt">targets/&lt;target-id&gt;/output/v1/...</span> — per-target outputs and stats (software/GPU/HTML).</li>
</ul>
</li>
<li>Target-id convention: use consumer’s app-local path, e.g., <span class="tt">surfaces/&lt;surface-name&gt;</span> or <span class="tt">textures/&lt;texture-name&gt;</span>.</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md85"></a>
Atomicity and concurrency</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md86"></a>
Render settings atomicity (per renderer target)</h2>
<ul>
<li>Settings update queue (atomic via PathSpace queues):<ul>
<li>Writers insert whole <span class="tt">RenderSettings</span> values into <span class="tt">settings/inbox</span>.</li>
<li>Renderer drains <span class="tt">settings/inbox</span> with take() and adopts only the last (last-write-wins).</li>
<li>Renderer, at a safe boundary:<ul>
<li>May mirror the adopted struct to <span class="tt">settings/active</span> as a single-value replace for introspection.</li>
</ul>
</li>
<li>Renderers read their adopted in-memory settings; <span class="tt">settings/active</span> is optional mirror only.</li>
</ul>
</li>
</ul>
<p>Benefits: single-path commit; readers never see half-updated params.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md87"></a>
Scene graph concurrency (authoring vs rendering)</h2>
<ul>
<li>Authoring tree is mutable: <span class="tt">scenes/&lt;sid&gt;/src/...</span>.</li>
<li>Builds (snapshots) are immutable, versioned by revision:<ul>
<li><span class="tt">scenes/&lt;sid&gt;/builds/&lt;revision&gt;/...</span> — pre-baked display list (world transforms, z-order, draw commands).</li>
<li><span class="tt">scenes/&lt;sid&gt;/current_revision</span> — pointer to latest published build (single-value register).</li>
</ul>
</li>
<li>Build pipeline: 1) Edits to <span class="tt">src</span> mark <span class="tt">dirty</span> and trigger a debounced layout/build. 2) A builder execution computes a display-list snapshot off-thread. 3) Build written under <span class="tt">builds/&lt;new_revision&gt;/...</span>. 4) Publish via atomic replace of <span class="tt">scenes/&lt;sid&gt;/current_revision</span> to <span class="tt">&lt;new_revision&gt;</span>. 5) Optionally GC old snapshots once not in use.</li>
</ul>
<p>Benefits: renderers read a consistent build (<span class="tt">current_revision</span> latched per frame) with no global locks.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
Locking strategy</h2>
<ul>
<li>No global locks for scene edits; builders work from <span class="tt">src</span> to a new immutable snapshot.</li>
<li>Renderer param adoption uses a short local mutex; render loop reads from adopted, immutable state.</li>
<li>Presenters marshal final present to the correct thread/runloop (e.g., macOS/Metal).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
Frame orchestration</h1>
<p>Renderer render (per target):</p>
<p>1) Adopt settings from <span class="tt">settings/inbox</span> (drain queue; last-write-wins; optionally mirror to <span class="tt">settings/active</span>). 2) Resolve <span class="tt">targets/&lt;tid&gt;/scene</span> against app root; validate it stays within the same app subtree. 3) Read <span class="tt">scenes/&lt;sid&gt;/current_revision</span>; latch for this render. 4) Traverse <span class="tt">scenes/&lt;sid&gt;/builds/&lt;revision&gt;/...</span>, render:</p><ul>
<li>Software: produce a framebuffer (pixels + stride).</li>
<li>GPU: render into an offscreen texture/image. 5) Write <span class="tt">targets/&lt;tid&gt;/output/v1/...</span> and stamp <span class="tt">frameIndex</span> + <span class="tt">revision</span>.</li>
</ul>
<p>Presenter (per window view):</p>
<p>1) Read <span class="tt">views/&lt;vid&gt;/surface</span>; resolve to <span class="tt">surfaces/&lt;sid&gt;</span>. 2) Optionally call <span class="tt">surfaces/&lt;sid&gt;/render</span> (which:</p><ul>
<li>Writes render settings to <span class="tt">renderers/&lt;rid&gt;/targets/surfaces/&lt;sid&gt;/settings/inbox</span>,</li>
<li>(No commit needed; updates are whole objects in a queue),</li>
<li>Triggers <span class="tt">renderers/&lt;rid&gt;/targets/surfaces/&lt;sid&gt;/render</span>). 3) Present:</li>
<li>Software: read framebuffer and blit to the window.</li>
<li>GPU: draw textured quad sampling the offscreen texture/image to the window drawable/swapchain.</li>
</ul>
<p>Staleness policy: presenters can present last-complete outputs if a fresh frame is in-flight (configurable freshness threshold). Pacing:</p><ul>
<li>Default: follow the display device’s refresh/vsync for the window/surface (variable refresh compatible).</li>
<li>HTML: use requestAnimationFrame.</li>
<li>Headless/offscreen: on-demand; if continuous, timer-driven execution.</li>
<li>Optional user cap: effective rate = min(display refresh, user cap).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
Hierarchical coordinates and layout</h1>
<ul>
<li>Authoring nodes in <span class="tt">scenes/&lt;sid&gt;/src/...</span> store local transforms, layout hints, and style.</li>
<li>Snapshot builder computes:<ul>
<li>World transforms and bounds.</li>
<li>Z-order and batching.</li>
<li>Text glyph runs and image resolves.</li>
<li>Optional clip/stencil info.</li>
</ul>
</li>
<li>Snapshots store pre-baked draw commands for fast traversal, and the snapshot builder materializes the DrawableBucket’s staging arrays (flat, sorted/bucketed) that correspond to the published revision.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
DrawableBucket (no widget-tree traversal at render time)</h2>
<ul>
<li>Maintain a flat registry per scene for render-time iteration. In snapshot-driven mode, the builder populates these arrays from <span class="tt">scenes/&lt;sid&gt;/src</span> into <span class="tt">builds/&lt;revision&gt;</span>; authoring-time updates populate staging, and publishing writes a new <span class="tt">builds/&lt;revision&gt;</span> and updates <span class="tt">current_revision</span>.</li>
<li>The renderer iterates a contiguous array (or a few arrays by layer) for visibility/culling/sorting and issuing draw commands.</li>
<li>API outline (conceptual; builder/widget-facing, not used by the renderer during a frame):<ul>
<li>register(widgetId) -&gt; handle</li>
<li>update(handle, {worldTransform, boundsLocal, material, layer, z, visibility, contentEpoch, transformEpoch, drawRef})</li>
<li>deregister(handle)</li>
<li>markDirty(handle, flags)</li>
</ul>
</li>
<li>Entry data (per drawable):<ul>
<li>Identifiers: <span class="tt">widgetId</span>, stable <span class="tt">handle</span></li>
<li>Transforms: local and world matrices; <span class="tt">transformEpoch</span></li>
<li>Bounds: local and world <span class="tt">BoundingSphere</span> and <span class="tt">BoundingBox</span> (AABB or optional OBB)</li>
<li>Draw metadata: layer, z, pipeline flags (opaque/alpha), material/shader id</li>
<li>Draw commands: cached command list pointer/handle + <span class="tt">contentEpoch</span> (or a prepare callback)</li>
<li>Visibility flag</li>
</ul>
</li>
<li>Double-buffering:<ul>
<li>Keep <span class="tt">staging</span> and <span class="tt">active</span> arrays per scene. The snapshot builder/authoring side updates <span class="tt">staging</span>; when publishing a new snapshot (by updating <span class="tt">current_revision</span>), it atomically swaps <span class="tt">staging</span> to <span class="tt">active</span> for that scene.</li>
<li>The renderer latches <span class="tt">current_revision</span> at the start of a frame and reads only from the matching <span class="tt">active</span> arrays for the duration of that frame (no renderer-owned swaps).</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
Transforms and hierarchy without per-frame traversal</h2>
<ul>
<li>Keep hierarchy for authoring/layout only; propagate transforms on change, not per frame:<ul>
<li><span class="tt">world = parentWorld * local</span></li>
<li>Update world bounds; bump <span class="tt">transformEpoch</span></li>
<li>Push updated entry to DrawableBucket <span class="tt">staging</span> buffer; enqueue children updates if needed</li>
</ul>
</li>
<li>Result: render-time is O(n_visible) with no parent walks.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
Bounding volumes and culling</h2>
<ul>
<li>Store both local/world <span class="tt">BoundingSphere</span> and <span class="tt">BoundingBox</span>:<ul>
<li>Sphere for cheap broad-phase (3D; circle in 2D); <span class="tt">r_world = r_local * maxScale(world)</span></li>
<li>AABB for tighter viewport clipping (2D) or optional OBB if rotation accuracy is needed</li>
</ul>
</li>
<li>Per view/camera:<ul>
<li>Frustum test against sphere first; optional AABB vs viewport test for 2D</li>
<li>Maintain buckets by layer/material to improve cache locality and reduce state changes</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
Draw command generation and caching</h2>
<ul>
<li>Widgets expose either:<ul>
<li>A stable <span class="tt">DrawCommands</span> object + <span class="tt">contentEpoch</span>, or</li>
<li>A “prepare” function to (re)build commands into a command allocator off-thread when <span class="tt">contentEpoch</span> changes</li>
</ul>
</li>
<li>Renderer requests commands only when <span class="tt">contentEpoch</span> differs from last seen (retained rendering). Software UI may still redraw every frame; evolve to dirty-rects later. Preparation of command buffers should occur off-thread where possible to avoid blocking the render loop.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
Sorting and batching</h2>
<ul>
<li>Partition visible drawables:<ul>
<li>Opaque pass: sort by material/pipeline then by z (or depth); write-friendly ordering for depth early-out</li>
<li>Alpha pass: back-to-front by z within layer</li>
</ul>
</li>
<li>Batch small UI ops (rects, rounded rects, images, glyph quads) into SoA buffers for software rasterization</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
Minimal types (sketch)</h2>
<div class="fragment"><div class="line">struct Transform { float m[16]; }; // 3D; 2D via orthographic with z=0</div>
<div class="line"> </div>
<div class="line">struct BoundingSphere { float cx, cy, cz, r; };</div>
<div class="line">struct BoundingBox { float min[3], max[3]; };</div>
<div class="line"> </div>
<div class="line">enum class BoundsKind { Sphere, Box };</div>
<div class="line">struct Bounds {</div>
<div class="line">  BoundsKind kind;</div>
<div class="line">  BoundingSphere sphereLocal, sphereWorld;</div>
<div class="line">  BoundingBox    boxLocal,    boxWorld;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct DrawCommand {</div>
<div class="line">  uint32_t type;           // Rect, RoundedRect, Image, TextGlyphs, Mesh, Path, ...</div>
<div class="line">  uint32_t materialId;</div>
<div class="line">  uint32_t pipelineFlags;  // opaque/alpha, blend, etc.</div>
<div class="line">  uint32_t vertexOffset, vertexCount; // or payload handle</div>
<div class="line">  // software-specific payload as needed</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct DrawableEntry {</div>
<div class="line">  uint64_t  id;</div>
<div class="line">  Transform world;</div>
<div class="line">  Bounds    bounds;</div>
<div class="line">  uint32_t  layer;</div>
<div class="line">  float     z;</div>
<div class="line">  uint32_t  pipelineFlags;</div>
<div class="line">  uint32_t  materialId;</div>
<div class="line">  uint64_t  transformEpoch;</div>
<div class="line">  uint64_t  contentEpoch;</div>
<div class="line">  const DrawCommand* cmds;</div>
<div class="line">  uint32_t  cmdCount;</div>
<div class="line">  bool      visible;</div>
<div class="line">};</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
Renderer loop outline</h2>
<div class="fragment"><div class="line">void renderTarget(const Camera&amp; cam,</div>
<div class="line">                  const DrawableEntry* entries, size_t count,</div>
<div class="line">                  Surface&amp; surface)</div>
<div class="line">{</div>
<div class="line">  // 1) Frustum cull (sphere), optional AABB vs viewport for 2D</div>
<div class="line">  // 2) Partition opaque/alpha</div>
<div class="line">  // 3) Sort opaque by pipeline/material then z; sort alpha back-to-front</div>
<div class="line">  // 4) Opaque pass: depth-friendly or painter’s order for 2D</div>
<div class="line">  // 5) Alpha pass: blend back-to-front</div>
<div class="line">  // 6) Execute DrawCommands into software raster (or GPU encoder)</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
Notifications and scheduling</h1>
<ul>
<li>Edits set a scene <span class="tt">dirty</span> flag/counter and notify a layout worker (debounced).</li>
<li>Renderers may watch target scene subtrees to mark targets dirty.</li>
<li>Modes:<ul>
<li>Explicit: surfaces/presenters trigger frames.</li>
<li>On-notify: renderer schedules frames for dirty targets.</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
Safety and validation</h1>
<ul>
<li>App-relative resolution: if a path lacks a leading slash, resolve against the app root.</li>
<li>Same-app validation: after resolution, verify the target path still lies within the app root; reject otherwise.</li>
<li>Platform handle hygiene:<ul>
<li>Use opaque typed wrappers for CAMetalLayer*, VkImage, etc.</li>
<li>Clearly document ownership and thread affinity (present must occur on the correct thread).</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
Performance notes</h1>
<ul>
<li>Software path introduces an extra copy (renderer → presenter blit).<ul>
<li>Mitigate with double-buffering and mapped memory; reuse buffers on resize when possible.</li>
</ul>
</li>
<li>GPU path uses an offscreen pass plus a present pass.<ul>
<li>Optionally allow a “presentable surface” mode (direct-to-window) when multi-window reuse isn’t needed.</li>
</ul>
</li>
<li>Debounce layout and frame triggers to avoid overdraw on bursty updates.</li>
<li>Memory: constrain number of retained snapshots and share resources across snapshots where safe.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
Builder/helpers (typed wiring)</h1>
<p>Introduce small C++ helpers to avoid brittle path-string glue:</p>
<ul>
<li>Helpers return canonical absolute paths (strings) instead of handles (no separate “handles” layer).</li>
<li>Names are simple identifiers under the app root (e.g., "main", "2d", "editor", "MainWindow").</li>
<li>All functions accept names or app-relative/absolute paths where noted; helpers resolve to absolute and validate containment within the same app root.</li>
</ul>
<p>Helper responsibilities:</p>
<ul>
<li>Resolve app-relative paths and validate containment.</li>
<li>Manage target-id convention (<span class="tt">surfaces/&lt;name&gt;</span>).</li>
<li>Use PathSpace atomic primitives:<ul>
<li>Single-value replace for small configs (e.g., surface desc).</li>
<li>Params update queue for per-target renderer params (renderer drains via take() and adopts last).</li>
<li>Snapshot revision flip (single write) for scene publish (builder concern).</li>
</ul>
</li>
<li>Provide readable errors with context (target-id, frame index, snapshot revision).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
Helper API (schema-as-code; returns paths)</h2>
<div class="fragment"><div class="line"> /dev/null/include/pathspace/ui/Builders.hpp#L1-220</div>
<div class="line">#pragma once</div>
<div class="line">#include &lt;pathspace/PathSpace.hpp&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;string_view&gt;</div>
<div class="line">#include &lt;optional&gt;</div>
<div class="line"> </div>
<div class="line">namespace SP::ui {</div>
<div class="line"> </div>
<div class="line">// App root is a canonical absolute path under which the app lives.</div>
<div class="line">using AppRoot = std::string;</div>
<div class="line"> </div>
<div class="line">// Creation parameter structs (passed to create_* helpers)</div>
<div class="line"> </div>
<div class="line">struct SceneParams {</div>
<div class="line">  std::string name;           // scene folder name under &quot;&lt;app&gt;/scenes/&quot;</div>
<div class="line">  std::string description;    // optional human-readable description</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct RendererParams {</div>
<div class="line">  std::string name;           // renderer folder name under &quot;&lt;app&gt;/renderers/&quot;</div>
<div class="line">  RendererKind kind;          // Software2D, Metal2D, Vulkan2D</div>
<div class="line">  std::string description;    // optional</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct SurfaceParams {</div>
<div class="line">  std::string name;           // surface folder name under &quot;&lt;app&gt;/surfaces/&quot;</div>
<div class="line">  SurfaceDesc desc;           // backend, size, format, colorSpace, etc.</div>
<div class="line">  std::string renderer;       // name or path to renderer (&quot;2d&quot;, &quot;renderers/2d&quot;, or absolute)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct WindowParams {</div>
<div class="line">  std::string name;           // window folder name under &quot;&lt;app&gt;/windows/&quot;</div>
<div class="line">  std::string title;          // window title</div>
<div class="line">  int         width  = 0;     // initial logical width</div>
<div class="line">  int         height = 0;     // initial logical height</div>
<div class="line">  float       scale  = 1.0f;  // initial UI scale/DPI</div>
<div class="line">  std::string background;     // optional background color name or hex</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Resolve a name or app-relative path against appRoot; return an absolute path.</div>
<div class="line">// Behavior:</div>
<div class="line">// - If &#39;maybeRel&#39; has no leading &#39;/&#39;, interpret it relative to appRoot.</div>
<div class="line">//   Example: appRoot=&quot;/system/applications/notepad&quot;, maybeRel=&quot;scenes/main&quot;</div>
<div class="line">//            =&gt; &quot;/system/applications/notepad/scenes/main&quot;</div>
<div class="line">// - If &#39;maybeRel&#39; starts with &#39;/&#39;, it must begin with appRoot (same-app containment).</div>
<div class="line">//   Example: maybeRel=&quot;/system/applications/notepad/scenes/main&quot; =&gt; OK (returned as-is)</div>
<div class="line">//            maybeRel=&quot;/system/applications/other/scenes/main&quot;   =&gt; Error (cross-app)</div>
<div class="line">// - Names are allowed (no slashes) only when a helper has already chosen a base subpath.</div>
<div class="line">//   Example: a helper may build &quot;surfaces/&quot; + name, then call this with &quot;surfaces/editor&quot;.</div>
<div class="line">// Errors:</div>
<div class="line">// - Return an error if the resolved absolute path does not lie within appRoot.</div>
<div class="line">Expected&lt;std::string&gt; resolve_app_relative(AppRoot const&amp; appRoot, std::string_view maybeRel);</div>
<div class="line"> </div>
<div class="line">// Derive the renderer target base path for a target (unique per surface/texture within the app).</div>
<div class="line">// Returns &quot;&lt;app&gt;/renderers/&lt;rendererName&gt;/targets/surfaces/&lt;surfaceName&gt;&quot; (or &quot;targets/textures/&lt;textureName&gt;&quot;)</div>
<div class="line">std::string derive_target_base(AppRoot const&amp; appRoot,</div>
<div class="line">                               std::string const&amp; rendererPathAbs,</div>
<div class="line">                               std::string const&amp; targetPathAbs /* surface or texture path */);</div>
<div class="line"> </div>
<div class="line">// ----- Creation (create-or-bind; idempotent) -----</div>
<div class="line">// Creates (or binds to existing) scene subtree at &quot;&lt;app&gt;/scenes/&lt;SceneParams.name&gt;&quot;.</div>
<div class="line">// Returns the absolute path to the scene root. Does not build snapshots.</div>
<div class="line">Expected&lt;std::string&gt; create_scene(PathSpace&amp;, AppRoot const&amp; appRoot, SceneParams const&amp; scene);</div>
<div class="line"> </div>
<div class="line">// Creates renderer at &quot;&lt;app&gt;/renderers/&lt;RendererParams.name&gt;&quot;, seeds minimal caps if needed.</div>
<div class="line">// Returns the absolute renderer path. Kind selects initial capability flags.</div>
<div class="line">Expected&lt;std::string&gt; create_renderer(PathSpace&amp;, AppRoot const&amp; appRoot, RendererParams const&amp; renderer);</div>
<div class="line"> </div>
<div class="line">// Creates surface at &quot;&lt;app&gt;/surfaces/&lt;SurfaceParams.name&gt;&quot;, writes desc as a single-value config,</div>
<div class="line">// links to the renderer (stored app-relative), and records targetPath for convenience.</div>
<div class="line">// SurfaceParams.renderer may be a name (&quot;2d&quot;), app-relative (&quot;renderers/2d&quot;), or absolute.</div>
<div class="line">// Returns the absolute surface path.</div>
<div class="line">Expected&lt;std::string&gt; create_surface(PathSpace&amp;, AppRoot const&amp; appRoot, SurfaceParams const&amp; surface);</div>
<div class="line"> </div>
<div class="line">// Creates window at &quot;&lt;app&gt;/windows/&lt;WindowParams.name&gt;&quot; and sets title/initial size/scale.</div>
<div class="line">// The native provider can be mounted later. Returns the absolute window path.</div>
<div class="line">Expected&lt;std::string&gt; create_window(PathSpace&amp;, AppRoot const&amp; appRoot, WindowParams const&amp; window);</div>
<div class="line"> </div>
<div class="line">// ----- Wiring -----</div>
<div class="line">// Attaches a surface to a window view by writing an app-relative reference at</div>
<div class="line">// &quot;&lt;app&gt;/windows/&lt;windowName&gt;/views/&lt;viewName&gt;/surface&quot;. The window and surface</div>
<div class="line">// can be referenced by simple names or paths; the helper resolves/validates containment.</div>
<div class="line">Expected&lt;void&gt; attach_surface_to_view(PathSpace&amp;, AppRoot const&amp; appRoot,</div>
<div class="line">                                      std::string windowPathOrName, std::string_view viewName,</div>
<div class="line">                                      std::string surfacePathOrName);</div>
<div class="line"> </div>
<div class="line">// Sets which scene the surface asks the renderer to render by writing an app-relative path</div>
<div class="line">// at &quot;&lt;app&gt;/surfaces/&lt;surfaceName&gt;/scene&quot;. Accepts name or path; resolves within appRoot.</div>
<div class="line">Expected&lt;void&gt; set_surface_scene(PathSpace&amp;, AppRoot const&amp; appRoot,</div>
<div class="line">                                 std::string surfacePathOrName, std::string scenePathOrName);</div>
<div class="line"> </div>
<div class="line">// ----- Params and frame trigger -----</div>
<div class="line">// Updates per-target render settings.</div>
<div class="line">// Mode Queue (default): inserts a full RenderSettings object into &quot;&lt;targetBase&gt;/settings/inbox&quot; as a queue element.</div>
<div class="line">                        The renderer take()s and adopts the last one atomically.</div>
<div class="line">// Mode ReplaceActive (debug/introspection only): writes the full struct to &quot;&lt;targetBase&gt;/settings/active&quot; as a single-value replace; renderer may mirror adopted settings here but does not adopt from this value.</div>
<div class="line">enum class ParamUpdateMode { Queue, ReplaceActive };</div>
<div class="line">Expected&lt;void&gt; update_target_settings(PathSpace&amp;, AppRoot const&amp; appRoot,</div>
<div class="line">                                      std::string targetPathOrSpec /* e.g., targets/surfaces/&lt;name&gt; */,</div>
<div class="line">                                      RenderSettings const&amp; settings,</div>
<div class="line">                                      ParamUpdateMode mode = ParamUpdateMode::Queue);</div>
<div class="line"> </div>
<div class="line">// Triggers a single frame for the renderer target by executing &quot;&lt;targetBase&gt;/render&quot;.</div>
<div class="line">// If &#39;overrides&#39; is provided, applies RenderSettings first (using the chosen mode).</div>
<div class="line">// Returns a FutureAny for completion tracking.</div>
<div class="line">Expected&lt;FutureAny&gt; render_target_once(PathSpace&amp;, AppRoot const&amp; appRoot,</div>
<div class="line">                                       std::string targetPathOrSpec,</div>
<div class="line">                                       std::optional&lt;RenderSettings&gt; overrides = std::nullopt);</div>
<div class="line"> </div>
<div class="line">// ----- Present -----</div>
<div class="line">// Presents the view &quot;&lt;app&gt;/windows/&lt;windowName&gt;/views/&lt;viewName&gt;&quot; into the window.</div>
<div class="line">// Ensures the referenced surface exists and is same-app; may trigger a render if freshness policy demands.</div>
<div class="line">// For software, blits the latest framebuffer; for GPU, encodes a quad to the window&#39;s drawable/swapchain.</div>
<div class="line">Expected&lt;void&gt; present_view(PathSpace&amp;, AppRoot const&amp; appRoot,</div>
<div class="line">                            std::string windowPathOrName, std::string_view viewName);</div>
<div class="line"> </div>
<div class="line">// ----- Introspection (optional) -----</div>
<div class="line">// Reads capability summary from &quot;&lt;app&gt;/renderers/&lt;rendererName&gt;/caps&quot; (shape TBD; v1 caps suggested).</div>
<div class="line">Expected&lt;RendererCaps&gt; get_renderer_caps(PathSpace const&amp;, AppRoot const&amp;, std::string rendererPathOrName);</div>
<div class="line">// Reads surface description from &quot;&lt;app&gt;/surfaces/&lt;surfaceName&gt;/desc&quot;.</div>
<div class="line">Expected&lt;SurfaceDesc&gt;  get_surface_desc(PathSpace const&amp;, AppRoot const&amp;, std::string surfacePathOrName);</div>
<div class="line"> </div>
<div class="line">} // namespace SP::ui</div>
</div><!-- fragment --><ul>
<li><span class="tt">include/pathspace/ui/Builders.hpp</span></li>
<li><span class="tt">src/pathspace/ui/</span><ul>
<li>scene/<ul>
<li>SceneSnapshotBuilder.{hpp,cpp}</li>
</ul>
</li>
<li>renderer/<ul>
<li>PathRenderer2D.{hpp,cpp}</li>
<li>DrawableBucket.{hpp,cpp}</li>
</ul>
</li>
<li>surface/<ul>
<li>PathSurface.hpp</li>
<li>PathSurfaceSoftware.{hpp,cpp}</li>
<li>PathSurfaceMetal.{hpp,mm} # ObjC++ (Apple)</li>
<li>SurfaceTypes.hpp</li>
</ul>
</li>
<li>window/<ul>
<li>PathWindow.{hpp,mm} # platform window shell</li>
<li>PathWindowView.{hpp,cpp|mm} # presenter</li>
</ul>
</li>
<li>platform/<ul>
<li>macos/…</li>
<li>win32/…</li>
<li>x11/wayland/…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CMake options (single library, feature-gated):</p><ul>
<li><span class="tt">PATHSPACE_ENABLE_UI</span> (ON)</li>
<li><span class="tt">PATHSPACE_UI_SOFTWARE</span> (ON)</li>
<li><span class="tt">PATHSPACE_UI_METAL</span> (ON on Apple)</li>
<li><span class="tt">PATHSPACE_UI_VULKAN</span> (OFF for now)</li>
</ul>
<p>Example CMake integration:</p>
<div class="fragment"><div class="line"> /dev/null/CMakeLists.txt#L1-80</div>
<div class="line">option(PATHSPACE_ENABLE_UI &quot;Build UI (surfaces/renderers/windows)&quot; ON)</div>
<div class="line">option(PATHSPACE_UI_SOFTWARE &quot;Enable software surface&quot; ON)</div>
<div class="line">option(PATHSPACE_UI_METAL &quot;Enable Metal surface/presenter (Apple)&quot; ON)</div>
<div class="line"> </div>
<div class="line">if(PATHSPACE_ENABLE_UI)</div>
<div class="line">  target_sources(PathSpace PRIVATE</div>
<div class="line">    include/pathspace/ui/Builders.hpp</div>
<div class="line">    src/pathspace/ui/renderer/PathRenderer2D.cpp</div>
<div class="line">    src/pathspace/ui/renderer/PathRenderer2D.hpp</div>
<div class="line">    src/pathspace/ui/renderer/DrawableBucket.cpp</div>
<div class="line">    src/pathspace/ui/renderer/DrawableBucket.hpp</div>
<div class="line">    src/pathspace/ui/scene/SceneSnapshotBuilder.cpp</div>
<div class="line">    src/pathspace/ui/scene/SceneSnapshotBuilder.hpp</div>
<div class="line">    src/pathspace/ui/surface/SurfaceTypes.hpp</div>
<div class="line">  )</div>
<div class="line">  if(PATHSPACE_UI_SOFTWARE)</div>
<div class="line">    target_sources(PathSpace PRIVATE</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceSoftware.cpp</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceSoftware.hpp</div>
<div class="line">    )</div>
<div class="line">  endif()</div>
<div class="line">  if(APPLE AND PATHSPACE_UI_METAL)</div>
<div class="line">    enable_language(OBJCXX)</div>
<div class="line">    target_sources(PathSpace PRIVATE</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceMetal.mm</div>
<div class="line">      src/pathspace/ui/surface/PathSurfaceMetal.hpp</div>
<div class="line">      src/pathspace/ui/window/PathWindowView.mm</div>
<div class="line">      src/pathspace/ui/window/PathWindowView.hpp</div>
<div class="line">    )</div>
<div class="line">    target_link_libraries(PathSpace PRIVATE &quot;-framework Cocoa&quot; &quot;-framework Metal&quot; &quot;-framework QuartzCore&quot;)</div>
<div class="line">    if(CMAKE_OBJCXX_COMPILER_ID MATCHES &quot;Clang&quot;)</div>
<div class="line">      set_source_files_properties(</div>
<div class="line">        src/pathspace/ui/surface/PathSurfaceMetal.mm</div>
<div class="line">        src/pathspace/ui/window/PathWindowView.mm</div>
<div class="line">        PROPERTIES COMPILE_FLAGS &quot;-fobjc-arc&quot;</div>
<div class="line">      )</div>
<div class="line">    endif()</div>
<div class="line">  endif()</div>
<div class="line">endif()</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Examples (creation with parameter structs)</h1>
<div class="fragment"><div class="line"> /dev/null/examples/ui_builders_params.cpp#L1-200</div>
<div class="line">#include &lt;pathspace/PathSpace.hpp&gt;</div>
<div class="line">#include &lt;pathspace/ui/Builders.hpp&gt;</div>
<div class="line">using namespace SP;</div>
<div class="line">using namespace SP::ui;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  PathSpace space;</div>
<div class="line">  AppRoot app = &quot;/system/applications/notepad&quot;;</div>
<div class="line"> </div>
<div class="line">  // 1) Create a scene</div>
<div class="line">  SceneParams scene{ .name = &quot;main&quot;, .description = &quot;Main UI scene&quot; };</div>
<div class="line">  auto scenePath = create_scene(space, app, scene).value();</div>
<div class="line"> </div>
<div class="line">  // 2) Create a renderer</div>
<div class="line">  RendererParams rparams{ .name = &quot;2d&quot;, .kind = RendererKind::Software2D, .description = &quot;Software 2D renderer&quot; };</div>
<div class="line">  auto rendererPath = create_renderer(space, app, rparams).value();</div>
<div class="line"> </div>
<div class="line">  // 3) Create a surface linked to the renderer (renderer can be name, app-rel, or abs)</div>
<div class="line">  SurfaceDesc sdesc;</div>
<div class="line">  sdesc.size = {1280, 720, 2.0f};</div>
<div class="line">  // sdesc.pixelFormat, sdesc.colorSpace, sdesc.premultipliedAlpha can be set as needed</div>
<div class="line"> </div>
<div class="line">  SurfaceParams sparams{ .name = &quot;editor&quot;, .desc = sdesc, .renderer = &quot;2d&quot; };</div>
<div class="line">  auto surfacePath = create_surface(space, app, sparams).value();</div>
<div class="line"> </div>
<div class="line">  // 4) Create a window</div>
<div class="line">  WindowParams wparams{ .name = &quot;MainWindow&quot;, .title = &quot;Notepad — Main&quot;, .width = 1280, .height = 720, .scale = 2.0f };</div>
<div class="line">  auto windowPath = create_window(space, app, wparams).value();</div>
<div class="line"> </div>
<div class="line">  // 5) Wire: attach surface to window view and pick a scene for the surface</div>
<div class="line">  attach_surface_to_view(space, app, &quot;MainWindow&quot;, &quot;editor&quot;, &quot;editor&quot;).value(); // names allowed</div>
<div class="line">  set_surface_scene(space, app, surfacePath, &quot;scenes/main&quot;).value();</div>
<div class="line"> </div>
<div class="line">  // 6) Update settings (queued) and render once</div>
<div class="line">  RenderSettings rs; rs.surface.size_px = {1280, 720}; rs.surface.dpi_scale = 2.0f;</div>
<div class="line">  update_target_settings(space, app, &quot;renderers/2d/targets/surfaces/editor&quot;, rs).value();</div>
<div class="line">  auto fut = render_target_once(space, app, &quot;renderers/2d/targets/surfaces/editor&quot;).value();</div>
<div class="line"> </div>
<div class="line">  // 7) Present the view</div>
<div class="line">  present_view(space, app, windowPath, &quot;editor&quot;).value();</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
Source layout and build integration</h1>
<ul>
<li>Source tree:<ul>
<li><span class="tt">include/pathspace/ui/Builders.hpp</span></li>
<li><span class="tt">src/pathspace/ui/</span><ul>
<li>scene/<ul>
<li>SceneSnapshotBuilder.{hpp,cpp}</li>
</ul>
</li>
<li>renderer/<ul>
<li>PathRenderer2D.{hpp,cpp}</li>
<li>DrawableBucket.{hpp,cpp}</li>
</ul>
</li>
<li>surface/<ul>
<li>PathSurface.hpp</li>
<li>PathSurfaceSoftware.{hpp,cpp}</li>
<li>PathSurfaceMetal.{hpp,mm}</li>
<li>SurfaceTypes.hpp</li>
</ul>
</li>
<li>window/<ul>
<li>PathWindow.{hpp,mm}</li>
<li>PathWindowView.{hpp,cpp|mm}</li>
</ul>
</li>
<li>platform/<ul>
<li>macos/…</li>
<li>win32/…</li>
<li>x11/wayland/…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CMake options and example are listed above. </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
HTML/Web output (optional adapter)</h1>
<ul>
<li>Motivation: enable preview/export of UI scenes to browsers without changing the core pipeline.</li>
<li>Approach: add an HTML output adapter that walks the same sorted drawables or scene snapshot and emits:<ul>
<li>DOM/CSS (quick path, not pixel-perfect), or</li>
<li>Canvas 2D JSON command stream + tiny JS runtime (closer to software renderer),</li>
<li>Optional WebGL later for performance and 3D effects.</li>
</ul>
</li>
<li>Paths (under a renderer target base):<ul>
<li><span class="tt">&lt;targetBase&gt;/output/v1/html/dom</span> — full HTML document as a string (may inline CSS/JS)</li>
<li><span class="tt">&lt;targetBase&gt;/output/v1/html/css</span> — CSS string, if split</li>
<li><span class="tt">&lt;targetBase&gt;/output/v1/html/commands</span> — JSON string of canvas commands</li>
<li><span class="tt">&lt;targetBase&gt;/output/v1/html/assets/&lt;name&gt;</span> — optional assets (base64 or URLs)</li>
</ul>
</li>
<li>Mapping hints:<ul>
<li>Rects/rounded-rects → div with border-radius or canvas roundRect</li>
<li>Images → img or canvas drawImage</li>
<li>Text → DOM text or canvas fillText (or pre-shaped glyph quads later)</li>
<li>Transforms → CSS matrix()/matrix3d() or canvas transform()</li>
<li>Shadows → CSS box-shadow or canvas shadow* properties</li>
<li>Z-order → z-index stacking contexts</li>
<li>Clipping → overflow:hidden (DOM) or canvas clip()</li>
</ul>
</li>
<li>Example (DOM/CSS): <div class="fragment"><div class="line"> /dev/null/target_outputs_html_dom_example.html#L1-80</div>
<div class="line">&lt;!doctype html&gt;</div>
<div class="line">&lt;html&gt;</div>
<div class="line">&lt;head&gt;</div>
<div class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</div>
<div class="line">&lt;title&gt;PathSpace UI — target preview&lt;/title&gt;</div>
<div class="line">&lt;style&gt;</div>
<div class="line">  .root { position: relative; width: 640px; height: 360px; background: #202020; }</div>
<div class="line">  .rect { position: absolute; left: 40px; top: 30px; width: 200px; height: 120px;</div>
<div class="line">          background: #4a90e2; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.25); }</div>
<div class="line">  .text { position: absolute; left: 56px; top: 50px; color: white; font: 16px/20px system-ui, sans-serif; }</div>
<div class="line">&lt;/style&gt;</div>
<div class="line">&lt;/head&gt;</div>
<div class="line">&lt;body&gt;</div>
<div class="line">&lt;div class=&quot;root&quot;&gt;</div>
<div class="line">  &lt;div class=&quot;rect&quot;&gt;&lt;/div&gt;</div>
<div class="line">  &lt;div class=&quot;text&quot;&gt;Hello, PathSpace!&lt;/div&gt;</div>
<div class="line">&lt;/div&gt;</div>
<div class="line">&lt;/body&gt;</div>
<div class="line">&lt;/html&gt;</div>
</div><!-- fragment --></li>
<li>Example (Canvas JSON commands): <div class="fragment"><div class="line"> /dev/null/target_outputs_html_commands.json#L1-60</div>
<div class="line">{</div>
<div class="line">  &quot;surface&quot;: { &quot;size_px&quot;: {&quot;w&quot;: 640, &quot;h&quot;: 360}, &quot;dpi_scale&quot;: 2.0 },</div>
<div class="line">  &quot;commands&quot;: [</div>
<div class="line">    { &quot;op&quot;: &quot;clear&quot;, &quot;color&quot;: [0.125, 0.125, 0.125, 1.0] },</div>
<div class="line">    { &quot;op&quot;: &quot;save&quot; },</div>
<div class="line">    { &quot;op&quot;: &quot;transform&quot;, &quot;m&quot;: [1,0,0,1,0,0] },</div>
<div class="line">    { &quot;op&quot;: &quot;shadow&quot;, &quot;color&quot;: [0,0,0,0.25], &quot;blur&quot;: 20, &quot;offsetX&quot;: 0, &quot;offsetY&quot;: 8 },</div>
<div class="line">    { &quot;op&quot;: &quot;fillRoundRect&quot;, &quot;x&quot;: 40, &quot;y&quot;: 30, &quot;w&quot;: 200, &quot;h&quot;: 120, &quot;r&quot;: 12, &quot;color&quot;: [0.29, 0.56, 0.89, 1] },</div>
<div class="line">    { &quot;op&quot;: &quot;shadow&quot;, &quot;color&quot;: [0,0,0,0], &quot;blur&quot;: 0, &quot;offsetX&quot;: 0, &quot;offsetY&quot;: 0 },</div>
<div class="line">    { &quot;op&quot;: &quot;fillText&quot;, &quot;x&quot;: 56, &quot;y&quot;: 70, &quot;text&quot;: &quot;Hello, PathSpace!&quot;, &quot;font&quot;: &quot;16px system-ui&quot;, &quot;color&quot;: [1,1,1,1] },</div>
<div class="line">    { &quot;op&quot;: &quot;restore&quot; }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>PathKeys additions:<ul>
<li><span class="tt">target_outputs_html_dom(targetBase)</span></li>
<li><span class="tt">target_outputs_html_css(targetBase)</span></li>
<li><span class="tt">target_outputs_html_commands(targetBase)</span></li>
</ul>
</li>
<li>Notes:<ul>
<li>DOM/CSS is fastest to implement but not pixel-perfect; Canvas JSON offers better parity with the software renderer.</li>
<li>Text fidelity improves if we pre-shape glyphs in the snapshot and emit positioned quads.</li>
<li>This adapter is optional and does not affect software/GPU outputs.</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
MVP plan</h1>
<p>1) Scaffolding and helpers</p><ul>
<li>Add <span class="tt">src/pathspace/ui/</span> with stubs for <span class="tt">PathRenderer2D</span>, <span class="tt">PathSurfaceSoftware</span>, and <span class="tt">PathWindowView</span> (presenter).</li>
<li>Add <span class="tt">ui/Builders.hpp</span> helpers (header-only) with comments explaining atomicity and path resolution behavior.</li>
</ul>
<p>2) Software-only pipeline (macOS-friendly)</p><ul>
<li>Implement <span class="tt">PathSurfaceSoftware</span> with pixel buffer + double-buffer.</li>
<li>Implement <span class="tt">PathRenderer2D</span> with target params, commit protocol, and simple rect/text rendering into the buffer.</li>
<li>Implement <span class="tt">PathWindowView</span> that blits buffers into a simple window (pair with existing Cocoa event pump).</li>
</ul>
<p>3) Scene snapshots (minimal)</p><ul>
<li>Define <span class="tt">scenes/&lt;sid&gt;/src/...</span>, <span class="tt">builds/&lt;revision&gt;/...</span>, <span class="tt">current_revision</span>.</li>
<li>Implement a minimal snapshot builder execution (stacking/absolute layout).</li>
<li>Integrate renderer to read snapshots by <span class="tt">current_revision</span>.</li>
</ul>
<p>4) Notifications and scheduling</p><ul>
<li>Debounced layout when <span class="tt">src</span> changes.</li>
<li>Optional renderer auto-schedule on notify; otherwise explicit trigger via surface/frame.</li>
</ul>
<p>5) Tests and docs</p><ul>
<li>Golden tests for snapshots and target param atomicity.</li>
<li>Concurrency tests (hammer edits while rendering).</li>
<li>Document this plan and update <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> if any core semantics change.</li>
</ul>
<p>6) Metal backend (next)</p><ul>
<li><span class="tt">PathSurfaceMetal</span> producing an offscreen <span class="tt">MTLTexture</span>.</li>
<li>Presenter draws textured quad into <span class="tt">CAMetalLayer</span> drawable on the UI thread.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
Open questions</h1>
<ul>
<li>Present policy: per-app defaults for staleness vs. always-fresh frames?</li>
<li>Snapshot GC triggers and retention policy (K snapshots vs. revision-based).</li>
<li>Text shaping and bidi strategy; font fallback.</li>
<li>Color management (sRGB, HDR) across software/GPU paths.</li>
<li>Direct-to-window bypass for single-view performance-critical cases (optional surface mode).</li>
<li>HTML adapter fidelity targets (DOM/CSS vs Canvas JSON vs WebGL) and text shaping strategy for web output.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
Gaps and Decisions (unresolved areas)</h1>
<p>Next to decide: 1) Path/schema specs and typing</p><ul>
<li>Finalize schemas for renderer target params (settings/inbox and settings/active), surface descriptions (pixel format, stride, premultiplied alpha, color space), and outputs (software framebuffer; GPU handle wrappers).</li>
<li>Introduce versioned keys (e.g., params/v1, outputs/v1).</li>
<li>Define app-relative resolution helper API and enforce same-app containment checks.</li>
</ul>
<p>2) Scene authoring model</p><ul>
<li>Node properties: transform representation (TRS vs matrix), style/visibility, interaction flags.</li>
<li>Hierarchy semantics: property inheritance, z-order, clipping behavior.</li>
<li>Initial layout systems: absolute/stack; plan flex/grid later. Measurement contracts for text and images.</li>
<li>Authoring API: thread model and batching for updates into scenes/&lt;sid&gt;/src.</li>
</ul>
<p>3) Snapshot builder spec</p><ul>
<li>Triggering/debounce policy and max rebuild frequency.</li>
<li>Work partitioning across passes (measure, layout, batching) and threading.</li>
<li>Transform propagation from hierarchy; text shaping pipeline and caching.</li>
<li>Snapshot/resource GC policy and sharing across revisions.</li>
</ul>
<p>4) DrawableBucket details</p><ul>
<li>Handle API (stable handles, generation counters), free lists.</li>
<li>Memory layout (SoA vs AoS), per-layer arrays, indices for fast material/layer iteration.</li>
<li>Thread safety: who updates staging, who publishes, child dirty propagation, and publish protocol.</li>
</ul>
<p>Additional areas to flesh out: 5) Culling and spatial acceleration</p><ul>
<li>Sphere vs AABB/OBB choices; optional quadtree/BVH later; rebuild vs incremental thresholds.</li>
</ul>
<p>6) Rendering pipeline specifics</p><ul>
<li>Software rasterization details (AA, clipping, blending, color pipeline) and text composition order.</li>
<li>GPU plans (command encoding patterns, pipeline caching) for Metal/Vulkan.</li>
</ul>
<p>7) Lighting and shadows</p><ul>
<li>Software UI lighting model (directional light, Lambert/Blinn-Phong) and elevation-based shadow heuristics.</li>
<li>Opt-in normals/3D attributes for “2.5D” widgets.</li>
</ul>
<p>8) Coordinate systems and cameras</p><ul>
<li>Units/DPI/scale conventions; orthographic defaults for UI; z-ordering semantics across 2D/3D.</li>
</ul>
<p>9) Time, animation, and frame scheduling</p><ul>
<li>Global clock, animation system, frame pacing/vsync, staleness thresholds, who triggers frames.</li>
</ul>
<p>10) Input, hit testing, and focus</p><ul>
<li>Mapping OS input to scene coords, hit-testing via DrawableBucket bounds, event routing (capture/bubble), IME/text.</li>
</ul>
<p>11) Presenters and window integration</p><ul>
<li>Vsync/present timing, occlusion throttling, dirty-region tracking for software blits.</li>
</ul>
<p>12) GPU backend architecture</p><ul>
<li>Device/queue ownership, thread affinity, synchronization, offscreen texture/image formats and color spaces.</li>
</ul>
<p>13) Resource system (images, fonts, shaders)</p><ul>
<li>Async loading/decoding, caches, eviction, asset path conventions, font fallback/shaping library.</li>
</ul>
<p>14) Error handling, observability, and profiling</p><ul>
<li>Error propagation style, structured logging/tracing per target/scene/frame, metrics and debug overlays.</li>
</ul>
<p>15) Testing strategy</p><ul>
<li>Deterministic snapshot tests, golden image tests (tolerances), concurrency/teardown races, feature-flagged GPU tests.</li>
</ul>
<p>16) Safety and isolation</p><ul>
<li>Enforce same-app validation consistently; opaque GPU handles with clear lifetimes; defensive teardown ordering.</li>
</ul>
<p>17) APIs/builders and lifecycles</p><ul>
<li>Finalize builder signatures/return types, error semantics; guarantees when app root is deleted; thread-safety of helpers.</li>
</ul>
<p>18) Documentation and diagrams</p><ul>
<li>Add “UI/Rendering” to <a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">AI_ARCHITECTURE.md</a> when APIs solidify; include Mermaid diagrams for data flow and schemas.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
Target keys (final)</h1>
<ul>
<li>Target base:<ul>
<li><span class="tt">&lt;app&gt;/renderers/&lt;rendererName&gt;/targets/&lt;kind&gt;/&lt;name&gt;</span></li>
<li>kind ∈ { <span class="tt">surfaces</span>, <span class="tt">textures</span>, <span class="tt">html</span> }</li>
</ul>
</li>
<li>Keys under a target:<ul>
<li><span class="tt">scene</span> — app-relative path to the scene root to render (must resolve within the same app root)</li>
<li><span class="tt">desc</span> — descriptor for the target (SurfaceDesc/TextureDesc/HtmlTargetDesc)</li>
<li><span class="tt">desc/active</span> — mirror written by renderer after reconfigure</li>
<li><span class="tt">status/*</span> — e.g., <span class="tt">reconfiguring</span>, <span class="tt">device_lost</span>, <span class="tt">message</span></li>
<li><span class="tt">settings/inbox</span> — queue of whole <span class="tt">RenderSettings</span> objects (writers insert; renderer takes and adopts last)</li>
<li><span class="tt">settings/active</span> — single-value mirror written by renderer after adoption (optional, for introspection)</li>
<li><span class="tt">render</span> — execution to render one frame for this target</li>
<li><span class="tt">output/v1/...</span> — latest outputs for this target:<ul>
<li><span class="tt">common/</span> — timings and metadata (<span class="tt">frameIndex</span>, <span class="tt">revision</span>, <span class="tt">renderMs</span>, <span class="tt">lastError</span>)</li>
<li><span class="tt">software/framebuffer</span> — pixel buffer + metadata (width, height, stride, format, colorSpace, premultiplied)</li>
<li><span class="tt">metal/texture</span> or <span class="tt">vulkan/image</span> — opaque GPU handles and metadata</li>
<li><span class="tt">html/dom</span>, <span class="tt">html/commands</span>, <span class="tt">html/assets/*</span> — optional web outputs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
RenderSettings v1 (final)</h1>
<ul>
<li>time: <span class="tt">{ time_ms: double, delta_ms: double, frame_index: uint64 }</span></li>
<li>pacing: <span class="tt">{ user_cap_fps: optional&lt;double&gt; }</span> # effective rate = min(display refresh, user cap)</li>
<li>surface: <span class="tt">{ size_px:{w:int,h:int}, dpi_scale: float, visibility: bool }</span></li>
<li>clear_color: <span class="tt">[float,4]</span></li>
<li>camera: <span class="tt">{ projection: Orthographic | Perspective, zNear:float, zFar:float }</span> (optional)</li>
<li>debug: <span class="tt">{ flags: uint32 }</span> (optional)</li>
</ul>
<p>Invariants:</p><ul>
<li>Writers always insert whole <span class="tt">RenderSettings</span> to <span class="tt">settings/inbox</span> (no partial field writes).</li>
<li>Renderer drains <span class="tt">settings/inbox</span> via take(), adopts only the last (last-write-wins), and may mirror to <span class="tt">settings/active</span>.</li>
<li><span class="tt">scene</span> paths are app-relative and must resolve to within the same application root.</li>
<li><span class="tt">output/v1</span> contains only the latest render result for the target.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
Glossary</h1>
<ul>
<li>App root: <span class="tt">/system/applications/&lt;app&gt;</span> or <span class="tt">/users/&lt;user&gt;/system/applications/&lt;app&gt;</span>.</li>
<li>App-relative path: a path string without leading slash, resolved against the app root.</li>
<li>Renderer target: a per-consumer subtree under <span class="tt">renderers/&lt;id&gt;/targets/&lt;kind&gt;/&lt;name&gt;</span>.</li>
<li>Snapshot: immutable render-ready representation of a scene at a point in time (<span class="tt">revision</span>).</li>
<li>Revision: monotonically increasing version used for atomic publish/adoption.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
Cross-references</h1>
<ul>
<li>See <span class="tt"><a class="el" href="_a_i___a_r_c_h_i_t_e_c_t_u_r_e_8md.html">docs/AI_ARCHITECTURE.md</a></span> for core PathSpace concepts (paths, NodeData, TaskPool, serialization). If any core behavior changes as part of implementing this plan (e.g., new blocking semantics, notification routing), update that document accordingly. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
