<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: Handoff Notice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_plan___surface___ray___cache.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Handoff Notice </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md298"></a></p>
<blockquote class="doxtable">
<p><b>Handoff note (October 19, 2025):</b> Ray cache work is deferred until the new assistant cycle prioritizes GPU rendering. Treat this plan as archival unless reactivated via <span class="tt"><a class="el" href="_a_i___onboarding___next_8md.html">docs/AI_Onboarding_Next.md</a></span>. </p>
</blockquote>
<h1 class="doxsection"><a class="anchor" id="autotoc_md299"></a>
Surface Ray Cache Plan (Draft)</h1>
<blockquote class="doxtable">
<p><b>Context update (October 15, 2025):</b> Ray cache milestones are evaluated within the assistant context launched for this cycle; align earlier terminology with the updated standards. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>Status:</b> Working draft. Describes the ray-query + sample cache approach that replaces the earlier “microtriangle” tessellation idea. We will defer implementation until the baseline “set pixel color” renderer path is stable. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md300"></a>
Why This Direction</h2>
<ul>
<li>Tessellating every drawable into microtriangles is expensive, adds serialization overhead, and duplicates geometric data we already have (SDFs, explicit meshes, tetrahedral surfaces).</li>
<li>Ray intersections against the authoritative surface representation can directly produce the shading samples we need per pixel. A spatial/temporal cache lets us reuse those samples across frames until content changes.</li>
<li>When we run out of frame budget, we can gracefully fall back to the nearest cached sample—even if it’s far away—so the image progressively converges rather than stalling or popping.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md301"></a>
Objectives</h2>
<ol type="1">
<li>Provide a deterministic ray-query interface over the scene’s surface representation (SDF, mesh, tet surfaces).</li>
<li>Maintain a progressive pixel cache keyed by screen-space (and optionally history reprojection) to reuse samples when geometry/material epochs are unchanged.</li>
<li>Allow early exits when budgets are hit: pull the closest cached sample (even if distant) so each frame can complete within time constraints, improving quality over time.</li>
<li>Keep diagnostics hooked to <span class="tt">RenderSettings::microtri_rt</span> (renamed? TBD) so pacing knobs (budget, rays per pixel, seeds) still apply.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md302"></a>
High-Level Pipeline</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md303"></a>
1. Baseline Renderer (Phase Zero)</h3>
<ul>
<li>Finish the simple “set pixel color” path that paints pixels directly from the drawable SoA (no ray queries). This is the correctness harness for input wiring, present policy, and diagnostics.</li>
<li>Once stable: introduce the ray cache as an opt-in path guarded behind renderer flags.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md304"></a>
Renderable Acceleration Input Contract</h3>
<p>Every renderable mounted under the renderer target must supply geometry for the ray pipeline via a lightweight API. Suggested C++ shape (names illustrative):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AccelInput {</div>
<div class="line">  <span class="keyword">enum class</span> GeometryType { TriangleMesh, TetraMesh };</div>
<div class="line"> </div>
<div class="line">  GeometryType type;</div>
<div class="line">  uint32_t     surface_handle;    <span class="comment">// stable id for cache tagging</span></div>
<div class="line">  EpochStamp   geometry_epoch;</div>
<div class="line">  EpochStamp   material_epoch;</div>
<div class="line">  Bound3f      bounds;            <span class="comment">// world-space AABB</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>TriangleMesh {</div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;float3&gt;&gt; positions;</div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;float3&gt;&gt; normals;      <span class="comment">// optional</span></div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;uint32_t&gt;&gt; indices;    <span class="comment">// triangles (3 per)</span></div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;uint32_t&gt;&gt; materialIds;<span class="comment">// optional per-face</span></div>
<div class="line">  } tri;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>TetraMesh {</div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;float3&gt;&gt; positions;</div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;uint32_t&gt;&gt; indices;    <span class="comment">// 4 per tetra</span></div>
<div class="line">    std::shared_ptr&lt;const std::vector&lt;uint32_t&gt;&gt; materialIds;</div>
<div class="line">  } tet;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Renderable {</div>
<div class="line">  Expected&lt;AccelInput&gt; get_acceleration_input(RendererContext&amp; ctx);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Implementation notes:</p><ul>
<li>Renderables may internally author via SDF/procedural means but must convert to triangles or tetrahedra before returning.</li>
<li>Geometry pointers are reference-counted so renderer caches can reuse existing buffers across frames.</li>
<li><span class="tt">geometry_epoch</span> / <span class="tt">material_epoch</span> bump whenever underlying data changes; the renderer uses them to rebuild acceleration structures and invalidate cached pixels.</li>
<li>The renderer builds two acceleration paths: triangles feed the GPU TLAS/BLAS, tetra meshes feed the CPU tet-walk. Renderables can populate whichever structures they support.</li>
<li>If geometry isn’t ready (e.g., asset streaming), return an error; renderer skips it that frame and logs the event.</li>
</ul>
<p>Renderer responsibilities:</p><ol type="1">
<li>Call <span class="tt">get_acceleration_input</span> at frame start (or whenever epochs change).</li>
<li>Compare epochs to cached entries; rebuild CPU/GPU acceleration structures as needed.</li>
<li>Tag cached samples with <span class="tt">surface_handle</span> for later invalidations.</li>
<li>Keep per-pixel loops entirely in renderer-managed memory—PathSpace is touched only during the fetch phase.</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md305"></a>
2. Surface Intersection Layer</h3>
<ul>
<li>Expose a scene-level API: <span class="tt">IntersectRay(ray, options)</span> → <span class="tt">{hit?, position_world, normal_world, material_handle, epoch_stamp}</span>.</li>
<li>Implementors may reuse existing SDF evaluators or tetrahedral acceleration structures.</li>
<li>Ensure returned <span class="tt">epoch_stamp</span> lets the cache detect when a sample is stale because geometry/material changed.</li>
<li><b>Canonical representation (lazy):</b> normalize all renderable surfaces to <b>tetrahedral volumes</b> on first request. The first time a widget (e.g., a button) is asked to render, it is prompted for a tetra mesh representing its current SDF/geometry. The mesh is cached alongside the surface. When the widget animates (e.g., click ripple), it can supply updated meshes each frame for the animation window and optionally keep a small cache of the representations it cycles through. This keeps the intersection kernel uniform without forcing up-front conversion for unused surfaces.</li>
<li><b>Initial sources of tetrahedra:</b><ul>
<li>UI widgets: start with a small hand-authored library of tetra meshes (rect panels, rounded pills, spheres, cylinders).</li>
<li>SDF primitives: implement SDF→tetra conversion by surveying existing literature (isosurface meshing / dual contouring variants) and picking a conservative scheme for the first set of primitives (boxes, spheres, capsules, etc.).</li>
<li>Future work (e.g., planetary surfaces): seed with a single large tetrahedron and progressively subdivide based on camera location. That refinement system sits on top of the same tetrahedral representation but will be developed later once the core ray cache is in place.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md306"></a>
3. Pixel Sample Cache</h3>
<p>Per pixel (or per screen-space tile) store:</p><ul>
<li><span class="tt">color</span> / <span class="tt">lighting</span> result</li>
<li><span class="tt">position_world</span>, <span class="tt">normal_world</span></li>
<li><span class="tt">material_handle</span></li>
<li><span class="tt">timestamp</span> or <span class="tt">epoch_stamp</span></li>
<li>Optional confidence/variance measures</li>
</ul>
<p>Lookup strategy:</p><ul>
<li>Try the exact pixel key first.</li>
<li>If missing or stale, search nearby pixels (screen-space tile lists) for a valid sample within tolerance; fall back to world-space proximity queries when needed.</li>
<li>Fallback: when frame budget is exhausted, return the nearest cached sample even if it’s far; mark the pixel as “needs refinement”.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md307"></a>
Shared Lookup Data Structures</h3>
<p>To keep CPU and hardware RT paths aligned, store cache metadata in GPU-friendly buffers that the CPU also maps:</p><ul>
<li><b>Sample atlas:</b> contiguous array of <span class="tt">SampleEntry { float2 pixel_coord; float3 world_pos; float3 normal; float3 color; uint32 surface_handle; uint32 epochs; }</span> kept in a Struct-of-Arrays layout. CPU code views it as vectors; GPU shaders access via SSBO/StorageBuffer.</li>
<li><b>Screen-space tile grid:</b> 2D grid (e.g., 16×16 pixel tiles). Each tile stores <span class="tt">(start_offset, count)</span> into the sample atlas via a second buffer. CPU uses it for quick neighborhood search; GPU compute shaders do the same for bounce jobs or reprojection.</li>
<li><b>World-space hash (optional):</b> for large parallax, maintain a hashed voxel table keyed by quantized world position to locate nearest cached sample. Implemented with the same flat buffers so GPU kernels can reuse it.</li>
</ul>
<p>Updates are double-buffered: while the renderer populates buffer A, GPU bounce jobs consume buffer B; swap at frame end. This keeps data structures identical across CPU and GPU implementations and avoids bespoke caches for each path.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md308"></a>
Cache Invalidation</h3>
<ul>
<li>Every surface contributor (SDF node, mesh, tet surface, material layer) must expose an epoch counter or change token.</li>
<li>When a surface updates geometry or material parameters, it publishes an invalidation record (e.g., via PathSpace notify) keyed by its surface handle. The cache subscribes and invalidates all entries tagged with that handle.</li>
<li>If a surface’s deformation affects only a region, optional bounding volumes can narrow the invalidation scope; otherwise we invalidate conservatively.</li>
<li>Materials with large parameter deltas can invalidate their samples, while minor tweaks (e.g., temporal noise) may update the epoch without full eviction if the renderer chooses.</li>
<li><b>Transport proposal:</b> surfaces write <span class="tt">SurfaceInvalidation</span> structs to <span class="tt">renderers/&lt;rid&gt;/cache/invalidate</span> (a PathSpace queue). Each record carries <span class="tt">{ surface_handle, geometry_epoch, material_epoch, optional_bounds, reason }</span>. The cache daemon drains this queue, bumps its internal epoch table, and tags affected pixels for eviction. Surfaces also expose a <span class="tt">surface_handle</span> value under their scene node so the cache can tag new samples with the correct handle.</li>
<li><b>Partial updates:</b> when <span class="tt">optional_bounds</span> is present, the cache only evicts samples whose cached <span class="tt">position_world</span> lies inside the bounding volume; otherwise, the entire surface is invalidated. Surfaces without precise bounds can omit the field and accept coarser invalidation.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md309"></a>
4. Progressive Refinement Loop</h3>
<p>Per frame:</p><ol type="1">
<li>Determine budget (max rays) from renderer settings.</li>
<li>Visit pixels in a progressive sequence to produce natural updates:<ul>
<li>Start with a deterministic blue-noise or Morton-order pattern so every frame touches a sparse stipple across the screen.</li>
<li>On subsequent frames, rotate/offset the pattern so coverage fills in uniformly.</li>
<li>Within each tile, optionally prioritize high-error / high-variance samples first.</li>
</ul>
</li>
<li>For each selected pixel:<ul>
<li>If cached sample is valid and meets quality bar → reuse (no ray).</li>
<li>Else if budget remains → shoot ray, shade, cache result.</li>
<li>Else → reuse nearest cached sample (even far away) so the frame still completes.</li>
</ul>
</li>
<li>Write pixel to framebuffer. Mark stats for diagnostics (e.g., reused vs. resampled counts).</li>
</ol>
<p>Over time, frames converge as budgets allow more rays; stale cache entries are evicted whenever source epochs change. The blue-noise stipple ordering keeps visual noise pleasant and ensures the image refines evenly instead of sweeping from one corner.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md310"></a>
Hybrid CPU/GPU Strategy</h3>
<ul>
<li><b>Ray generation (primary hits):</b> run in software on the CPU to minimize latency and keep per-pixel cache logic close to the presenter. CPU-side ray marching traverses the tetrahedral TLAS/BLAS directly, producing the initial surface sample for each pixel.</li>
<li><b>Lighting bounces:</b> once a primary hit is cached, offload secondary rays / global illumination to hardware RT when available (Metal/Vulkan RT). The cached sample stores the request; a GPU worker integrates lighting asynchronously and updates the cache entry. Systems without hardware RT fall back to the CPU path.</li>
<li>Budgets differentiate between CPU primary rays (<span class="tt">budget.primary_rays_per_frame</span>) and GPU bounce workloads (<span class="tt">budget.rt_bounces_per_frame</span>), letting us keep UI interaction responsive while progressively refining lighting.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md311"></a>
CPU↔GPU Coordination</h3>
<ol type="1">
<li><b>Startup detection:</b> at application init, probe Vulkan/Metal capabilities and deployment policy once; store <span class="tt">gpu_rt_available</span> / <span class="tt">gpu_rt_allowed</span> flags in the renderer context. No per-frame probing is required.</li>
<li><b>Frame start:</b> renderer latches <span class="tt">RenderSettings::ray_cache</span>, clears per-frame queues, and reads the cached flags. If hardware RT is both available and allowed, mark the frame GPU-enabled; otherwise stay CPU-only.</li>
<li><b>CPU pass:</b> ray cache walks tiles, issues primary rays, writes/updates <span class="tt">SampleEntry</span> records in buffer A. For samples needing bounce lighting, it pushes lightweight requests <span class="tt">{sample_index, surface_handle, material_id}</span> into an RT dispatch queue (SSBO).</li>
<li><b>GPU dispatch (if RT permitted):</b> after the CPU pass completes (or mid-frame via async compute), GPU consumes the queue, traces secondary rays, writes lighting contributions into buffer B.</li>
<li><b>Merge:</b> CPU checks completion flags on buffer B (or uses fences). Completed entries merge back into buffer A before present; in-progress entries keep prior lighting so the main thread never stalls.</li>
<li><b>Fallback / policy:</b> when hardware RT isn’t supported/allowed, the CPU drains the queue itself, following identical control flow.</li>
<li><b>Timeout handling:</b> if the GPU misses the frame budget, the presenter uses existing lighting values; pending requests roll over to the next frame.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md312"></a>
Post Processing / Tone Mapping</h2>
<ul>
<li>After the ray cache (and any overlay pixels) produce the HDR buffer, run a configurable tone-mapping pipeline (default ACES/filmic) before handing pixels to the presenter.</li>
<li>Keep the tone-mapper pluggable so UI renderers can choose simpler gamma curves if desired.</li>
<li>The overlay buffer from the direct pixel path is treated as display-space and composited <em>after</em> tone mapping so overlays remain untouched.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md313"></a>
Direct Pixel Overlay Path</h2>
<p>Some renderables/tools may bypass the ray cache entirely and write pixels directly. Provide a dedicated PathSpace overlay queue per renderer:</p><ul>
<li><span class="tt">renderers/&lt;rid&gt;/overlay/pixels/in</span> — queue of <span class="tt">{ x:int, y:int, rgba:float4 }</span> updates. On each frame the presenter drains this queue, writes into an overlay buffer, then blits it over the main framebuffer before present.</li>
<li><span class="tt">renderers/&lt;rid&gt;/overlay/pixels/delete</span> — queue of <span class="tt">{ x:int, y:int }</span> removals (or bounding boxes). Presenter clears those entries from the overlay buffer.</li>
</ul>
<p>Overlay buffer notes:</p><ul>
<li>Fixed size matching the target surface (cleared each frame unless persisted by producer).</li>
<li>Producers are responsible for resubmitting persistent pixels every frame; otherwise they drift out.</li>
<li>Cap queue length / per-frame consumption to protect responsiveness.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md314"></a>
Shader Authoring Roadmap</h3>
<ol type="1">
<li><b>Phase 0 – Direct C API.</b> Implement shaders as simple C functions compiled into the renderer (<span class="tt">ShadeSurface(hit, params)</span>). This is sufficient for the initial software-only path.</li>
<li><b>Phase 1 – Portable Shader Language (PSL).</b> Introduce a GLSL-like DSL. Parse once and emit both GLSL (compiled to SPIR-V for GPU) and C++/LLVM IR (for CPU). Share reflection metadata so bindings stay in sync.</li>
<li><b>Phase 2 – Runtime authoring.</b> Allow hot-loading PSL shaders at runtime, compiling them to both targets so user-authored materials work in software-only deployments as well.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md315"></a>
Shading IR Specification (Draft)</h2>
<p>Goal: define one portable representation so both CPU and GPU evaluate identical BRDF/BTDF logic. Materials compile into this IR once; the CPU interpreter and GPU codegen share bytecode.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md316"></a>
Core Concepts</h3>
<ul>
<li><b>Module:</b> immutable blob containing:<ul>
<li>metadata (<span class="tt">version</span>, <span class="tt">material_name</span>, <span class="tt">hash</span>)</li>
<li>tables of constants, textures/samplers, string ids</li>
<li>entry functions (<span class="tt">surface</span>, <span class="tt">volume</span>, optional <span class="tt">emissive</span>)</li>
</ul>
</li>
<li><b>Function:</b> sequence of SSA instructions forming a DAG; terminated by <span class="tt">Return color3</span> (surface) or <span class="tt">Return volume_sample</span>.</li>
<li><b>Value types:</b> <span class="tt">float</span>, <span class="tt">float2/3/4</span>, <span class="tt">int</span>, <span class="tt">bool</span>, <span class="tt">material_param</span> (indexed uniform), <span class="tt">texture2D</span>, <span class="tt">textureCube</span>.</li>
<li><b>Instruction set (initial):</b><ul>
<li>arithmetic: <span class="tt">add</span>, <span class="tt">sub</span>, <span class="tt">mul</span>, <span class="tt">mad</span>, <span class="tt">div</span>, <span class="tt">sqrt</span>, <span class="tt">rsqrt</span></li>
<li>vector ops: <span class="tt">dot</span>, <span class="tt">cross</span>, <span class="tt">normalize</span>, <span class="tt">reflect</span>, <span class="tt">refract</span></li>
<li>BRDF helpers: <span class="tt">ggx_D</span>, <span class="tt">ggx_G</span>, <span class="tt">ggx_F</span>, Disney diffuse</li>
<li>utility: <span class="tt">clamp</span>, <span class="tt">saturate</span>, <span class="tt">mix</span>, <span class="tt">step</span></li>
<li>texture/sample: <span class="tt">sample_texture2D(coord, sampler)</span> (explicit LOD optional)</li>
<li>control: <span class="tt">select(pred, a, b)</span> (no general branching in v1)</li>
</ul>
</li>
<li><b>Uniform parameters:</b> stored in a packed UBO structure; IR references them via indices so both CPU and GPU share layout.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md317"></a>
Execution Modes</h3>
<ul>
<li><b>CPU interpreter:</b> walks SSA instructions; implemented as a simple register VM. Optional LLVM JIT later.</li>
<li><b>GPU codegen:</b> translate SSA to SPIR-V / MSL / HLSL. Limited control flow keeps generated shaders branch-friendly.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md318"></a>
Material Authoring Flow</h3>
<ol type="1">
<li>Author writes material in high-level form (node graph / JSON) specifying baseColor, metallic, roughness, transmission, normal maps, emissive.</li>
<li>Offline compiler lowers to IR module (normalizes params, allocates textures/samplers, bakes constants).</li>
<li>Runtime loads the module, uploads textures/uniforms, and attaches a <span class="tt">MaterialHandle</span> referencing the module + uniform block.</li>
<li>CPU shading: interpreter executes <span class="tt">surface(hitContext, uniforms)</span> to produce BRDF/BTDF outputs.</li>
<li>GPU shading: RT bounce kernels execute generated shader with the same context/uniforms.</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md319"></a>
Extension Hooks</h3>
<ul>
<li>Register custom instruction libraries (clear coat, sheen) as long as both CPU/GPU backends implement them.</li>
<li>Module <span class="tt">version</span> ensures backward compatibility; renderer rejects newer versions if unsupported.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md320"></a>
Validation</h3>
<ul>
<li>Unit tests execute every instruction via CPU interpreter and GPU shader, comparing outputs within epsilon.</li>
<li>Golden scene (wood + glass button) rendered via CPU-only and GPU-accelerated paths to confirm parity.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md321"></a>
Data &amp; Diagnostics</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md322"></a>
PathSpace output schema</h3>
<p>Record per-frame stats under the renderer target so tooling can query them consistently:</p><ul>
<li><span class="tt">output/v1/common/ray_cache/budget</span> — <span class="tt">{ primary_rays_used:uint32, refinement_pixels_processed:uint32, rt_bounces_used:uint32 }</span></li>
<li><span class="tt">output/v1/common/ray_cache/cache</span> — <span class="tt">{ pixels_reused:uint32, pixels_resampled:uint32, search_radius_px:float }</span></li>
<li><span class="tt">output/v1/common/ray_cache/queue</span> — <span class="tt">{ pending:int32, gpu_enabled:bool, last_dispatch_ms:float }</span></li>
<li><span class="tt">output/v1/common/ray_cache/status</span> — <span class="tt">{ fallback_reason:string, last_error:string }</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md323"></a>
Optional debug attachments</h3>
<ul>
<li><span class="tt">output/v1/debug/ray_cache/distance</span> — screen-space texture storing normalized distance to nearest cached sample.</li>
<li><span class="tt">output/v1/debug/ray_cache/variance</span> — variance/quality map to visualize progressive refinement.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md324"></a>
Logging</h3>
<ul>
<li>Emit structured lines to <span class="tt">&lt;app&gt;/io/log/info</span> with tag <span class="tt">ray_cache</span> whenever mode switches (GPU RT enable/disable, cache reset). Include budget usage and any fallback reason for quick triage.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md325"></a>
Settings Mapping</h2>
<p>Rename <span class="tt">RenderSettings::microtri_rt</span> to <span class="tt">RenderSettings::ray_cache</span> (short alias <span class="tt">RC</span>). The renderer owns these knobs: builders/tests seed defaults, but runtime code supplies budgets. Proposed layout:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RayCacheSettings {</div>
<div class="line">  <span class="keyword">struct </span>Budget {</div>
<div class="line">    uint32_t primary_rays_per_frame = 0;      <span class="comment">// CPU ray generation budget</span></div>
<div class="line">    uint32_t refinement_pixels_per_frame = 0; <span class="comment">// pixels eligible for fresh shading</span></div>
<div class="line">    uint32_t rt_bounces_per_frame = 0;        <span class="comment">// GPU lighting jobs allowed per frame</span></div>
<div class="line">  } budget;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Path {</div>
<div class="line">    uint32_t max_bounces = 1;</div>
<div class="line">    uint32_t rr_start_bounce = 1;</div>
<div class="line">  } path;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Cache {</div>
<div class="line">    <span class="keywordtype">float</span> search_radius_px = 1.5f;        <span class="comment">// screen-space radius when reusing cached samples</span></div>
<div class="line">    <span class="keywordtype">bool</span>  invalidate_on_epoch_change = <span class="keyword">true</span>;</div>
<div class="line">  } cache;</div>
<div class="line"> </div>
<div class="line">  uint64_t seed = 0;                       <span class="comment">// deterministic sample ordering</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Flow:</p><ul>
<li>Renderer latches <span class="tt">RenderSettings::ray_cache</span> once per frame (same rule as other settings).</li>
<li>UI helpers expose convenience setters (<span class="tt">Surface::ConfigureRayCache</span>, etc.) but do not mutate at render time.</li>
<li>Snapshot builder ignores these values—they are runtime-only knobs.</li>
<li>Diagnostics mirror the effective settings under <span class="tt">output/v1/common/ray_cache/*</span> for visibility.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md326"></a>
Open Questions</h2>
<ul>
<li><b>Cache search metric:</b> pure screen-space distance vs. world-space proximity (or hybrid).</li>
<li><b>Variance tracking:</b> do we need per-sample variance to decide priority?</li>
<li><b>History reprojection:</b> incorporate velocity buffers to reproject previous frame samples?</li>
<li><b>Memory budget:</b> how large can the cache grow; eviction policy?</li>
<li><b>Diagnostics UI:</b> best way to visualize how many pixels were re-shaded vs. reused.</li>
</ul>
<hr  />
<p><em>Next steps:</em> finalize the ray intersection API, rename the renderer settings to reflect this approach, and prototype the cache loop on top of the simple pixel renderer. Update this document as decisions solidify. Logged 2025‑10‑15.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md328"></a>
Future Work: PrimeScript</h2>
<p>Longer-term we may adopt <b>PrimeScript</b>, a unified language that can emit C++, GLSL, and VM bytecode for both gameplay scripting and shading. See <span class="tt"><a class="el" href="_plan___prime_script_8md.html">docs/Plan_PrimeScript.md</a></span> for early thoughts. This sits beyond the current roadmap (C API → PSL) but remains a target for consolidating authoring workflows. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
