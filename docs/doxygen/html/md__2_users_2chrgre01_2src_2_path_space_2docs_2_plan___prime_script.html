<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathSpace: Handoff Notice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathSpace
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2chrgre01_2src_2_path_space_2docs_2_plan___prime_script.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Handoff Notice </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md172"></a></p>
<blockquote class="doxtable">
<p><b>Handoff note (October 19, 2025):</b> PrimeScript remains exploratory. Treat this document as a living research memo until the language graduates onto the active roadmap. </p>
</blockquote>
<h1 class="doxsection"><a class="anchor" id="autotoc_md173"></a>
PrimeScript Plan (Concept)</h1>
<p>PrimeScript is built around a simple philosophy: program meaning emerges from two primitives—**definitions** (potential) and <b>executions</b> (actual). Rather than bolting on dozens of bespoke constructs, we give both forms the same syntactic envelope and let compile-time transforms massage the surface into a canonical core. From that small nucleus we can target C++, GLSL, or the PrimeScript VM, wire into PathSpace, and even feed future visual editors, all without sacrificing deterministic semantics.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md174"></a>
Goals</h2>
<ul>
<li>Single authoring language spanning gameplay/domain scripting, UI logic, automation, and rendering shaders.</li>
<li>Emit high-performance C++ for engine integration, GLSL/SPIR-V for GPU shading, and bytecode for an embedded VM without diverging semantics.</li>
<li>Share a consistent standard library (math, texture IO, resource bindings, PathSpace helpers) across backends while preserving determinism for replay/testing.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md175"></a>
Proposed Architecture</h2>
<ul>
<li><b>Front-end parser:</b> C/TypeScript-inspired surface syntax with explicit types, deterministic control flow, and borrow-checked resource usage.</li>
<li><b>Transform pipeline:</b> ordered <span class="tt">[transform]</span> functions rewrite the forthcoming AST (or raw tokens) before semantic analysis. The default chain desugars infix operators, control-flow, assignment, etc.; projects can override via <span class="tt">--transform-list</span> flags.</li>
<li><b>Intermediate representation:</b> strongly-typed SSA-style IR shared by every backend (C++, GLSL, VM, future LLVM). Normalisation happens once; backends never see syntactic sugar.</li>
<li><b>Backends:</b><ul>
<li><b>C++ emitter</b> – generates host code or LLVM IR for native binaries/JITs.</li>
<li><b>GLSL/SPIR-V emitter</b> – produces shader code; a Metal translation remains future work.</li>
<li><b>VM bytecode</b> – compact instruction set executed by the embedded interpreter/JIT.</li>
</ul>
</li>
<li><b>Tooling:</b> CLI compiler <span class="tt">primescriptc</span> plus build/test helpers. The definition/execution split maps cleanly to future node-based editors; full IDE/LSP integration is deferred until the compiler stabilises.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md176"></a>
Language Design Highlights</h2>
<ul>
<li><b>Uniform envelope:</b> every construct uses <span class="tt">[transform-list] identifier&lt;template-list&gt;(parameter-list) {body-list}</span>. Lists recursively reuse whitespace-separated tokens.<ul>
<li><span class="tt">[...]</span> enumerates metafunction transforms applied in order (see “Built-in transforms”).</li>
<li><span class="tt">&lt;...&gt;</span> supplies compile-time types/templates—primarily for transforms or when inference must be overridden.</li>
<li><span class="tt">(...)</span> lists runtime parameters and captures.</li>
<li><span class="tt">{...}</span> holds either a definition body or, in the execution case, an argument list for higher-order constructs.</li>
</ul>
</li>
<li><b>Definitions vs executions:</b> definitions include a body (<span class="tt">{…}</span>) and optional transforms; executions are call-style (<span class="tt">execute_task&lt;…&gt;(args)</span>) with no body. The compiler decides whether to emit callable artifacts or schedule work based on that presence.</li>
<li><b>Return annotation:</b> definitions declare return types via transforms (e.g., <span class="tt">[return&lt;float&gt;] blend&lt;…&gt;(…) { … }</span>). Executions return values explicitly (<span class="tt">return(value)</span>); the desugared form is always canonical.</li>
<li><b>Effects:</b> functions are pure by default. Authors opt into side effects with attributes such as <span class="tt">[effects(global_write, io_stdout)]</span>. Standard library routines permit stdout/stderr logging; backends reject unsupported effects (e.g., GPU code requesting filesystem access).</li>
<li><b>Namespaces &amp; includes:</b> identifiers follow <span class="tt">namespace::symbol</span>. <span class="tt">include&lt;"/std/io", version="1.2.0"&gt;</span> searches the include path for a zipped archive or plain directory whose layout mirrors <span class="tt">/version/first_namespace/second_namespace/...</span>. Versions live in the leading segment (e.g., <span class="tt">1.2/std/io/*.prime</span> or <span class="tt">1/std/io/*.prime</span>). If the version attribute provides one or two numbers (<span class="tt">1</span> or <span class="tt">1.2</span>), the newest matching archive is selected; three-part versions (<span class="tt">1.2.0</span>) require an exact match. Each <span class="tt">.prime</span> source file is inline-expanded exactly once and registered under <span class="tt">std::io::</span>; duplicate includes are ignored. Folders prefixed with <span class="tt">_</span> remain private.</li>
<li><b>Transform-driven control flow:</b> control structures desugar into prefix calls (<span class="tt">if(cond, then_block{…}, else_block{…})</span>). Infix operators (<span class="tt">a + b</span>) become canonical calls (<span class="tt">plus(a, b)</span>), ensuring IR/backends see a small, predictable surface.</li>
<li><b>Mutability:</b> bindings are immutable by default. Mutability is opt-in via attributes (<span class="tt">[mutable] let x = …</span>, <span class="tt">[mutable] datum{…}</span>). Transforms enforce that only mutable bindings can serve as <span class="tt">assign</span> or pointer-write targets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md177"></a>
Struct &amp; type categories (draft)</h3>
<ul>
<li><b>Struct definition priority:</b> before we can classify data lanes or label POD types, lock down how PrimeScript structs are declared, laid out, and mapped onto backend storage. This includes member ordering, padding, default mutability, and transform hooks for layout attributes (<span class="tt">[packed]</span>, <span class="tt">[align]</span>).</li>
<li><b>Proposed syntax (exploratory):</b> treat struct declarations as a transform envelope with no runtime parameters, e.g. <span class="tt">[struct pod no_padding] Color { first_member&lt;Integer&gt; second_member&lt;string&gt; }</span>. Each member becomes a transform-style execution; additional tags like <span class="tt">mutable</span>, <span class="tt">default(value)</span> or <span class="tt">handle&lt;PathNode&gt;</span> can decorate the member invocation.</li>
<li><b>Baseline layout rule (suggested):</b> members default to source-order packing with no implicit padding. A struct tagged <span class="tt">[pod]</span> may still introduce backend-mandated padding, but only when the layout metadata records the exact reason (e.g., SIMD granularity). <span class="tt">[no_padding]</span> is an explicit contract—no extra bytes may be inserted; if a backend cannot honour it, compilation fails. <span class="tt">[platform_independent_padding]</span> locks the final byte layout so every backend emits identical padding bytes, ensuring bit-for-bit portability.</li>
<li><b>Alignment transforms:</b> member declarations accept layout helpers such as <span class="tt">[align_bytes(8)] color&lt;Float&gt;</span> or <span class="tt">[align_kbytes(1)] buffer_handle&lt;Handle&gt;</span>, giving backends explicit padding guarantees without bespoke syntax.</li>
<li><b>Stack value executions:</b> every local binding is introduced through an execution that materialises a value for the current frame’s stack, e.g. <span class="tt">[Integer] exposure(42)</span> or <span class="tt">[Color] tint(default_color())</span>. A default expression is mandatory so the stack slot is fully initialised before use.</li>
<li><b>Type transforms size the frame:</b> metafunctions such as <span class="tt">Integer</span> rewrite the AST with sizing metadata so the compiler can reserve the correct stack width before lowering to IR. Custom types are expected to expose the same metadata hooks.</li>
<li><b>Platform constraints:</b> each backend may enforce minimum alignment/padding for certain types (SIMD lanes, GPU storage buffers); the struct metadata must record both the requested layout and the runtime-imposed adjustments so high-speed code stays portable.</li>
<li><b>IR layout manifest:</b> struct transforms embed a <span class="tt">layout</span> table directly into the IR type descriptor (field name → offset, size, padding flag). Backends consume that single source of truth; layout validation tools read it via <span class="tt">primescriptc --emit-ir</span>. If <span class="tt">[no_padding]</span> or <span class="tt">[platform_independent_padding]</span> cannot be honoured, codegen aborts during IR validation.<ul>
<li><b>Proposed schema:</b> extend the IR type descriptor with <span class="tt">layout.total_size_bytes</span>, <span class="tt">layout.alignment_bytes</span>, and an ordered <span class="tt">layout.fields</span> array. Each field record carries <span class="tt">{ name, offset_bytes, size_bytes, padding_kind }</span>, where <span class="tt">padding_kind</span> is one of <span class="tt">none</span>, <span class="tt">explicit</span> (requested by user transforms), or <span class="tt">backend</span> (platform-imposed with diagnostic details). Struct-level tags (<span class="tt">pod</span>, <span class="tt">no_padding</span>, <span class="tt">platform_independent_padding</span>) translate into validation clauses against these metadata entries.</li>
</ul>
</li>
<li><b>Plain-old data (POD):</b> trivially copyable scalars/structs with no hidden lifetimes; default pass-by-reference is safe and <span class="tt">[copy]</span> generates value snapshots.</li>
<li><b>Handles:</b> opaque identifiers that reference managed resources (PathSpace nodes, textures, etc.). Lifetimes tie to the owning subsystem rather than value semantics; borrow rules must spell out readable vs mutable access.</li>
<li><b>GPU-resident values:</b> data that only exists in device memory (buffers, textures). Requires explicit staging/copy transforms before CPU inspection.</li>
<li><b>Documentation TODO:</b> formalise how each category maps onto IR storage classes and backend-specific codegen before promoting PrimeScript beyond research.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md178"></a>
Built-in transforms (draft)</h3>
<ul>
<li><b>Purpose:</b> built-in transforms are metafunctions that stamp semantic flags on the AST; later passes (borrow checker, backend filters) consume those flags. They do not emit code directly.</li>
<li><b>Evaluation mode:</b> when the compiler sees <span class="tt">[transform ...]</span>, it routes through the metafunction's declared signature—pure token rewrites operate on the raw stream, while semantic transforms receive the AST node and in-place metadata writers.</li>
<li><b><span class="tt">copy</span>:</b> force copy-on-entry for a parameter or binding, even when references are the default. Often paired with <span class="tt">mutable</span>.</li>
<li><b><span class="tt">mutable</span>:</b> mark the local binding as writable; without it the binding behaves like a <span class="tt">const</span> reference.</li>
<li><b><span class="tt">restrict&lt;T&gt;</span>:</b> constrain the accepted type to <span class="tt">T</span> (or satisfy concept-like predicates once defined). Applied alongside <span class="tt">copy</span>/<span class="tt">mutable</span> when needed.</li>
<li><b><span class="tt">return&lt;T&gt;</span>:</b> optional contract that pins the inferred return type. Recommended for public APIs or when disambiguation is required.</li>
<li><b><span class="tt">effects(...)</span>:</b> declare side-effect capabilities; absence implies purity. Backends reject unsupported capabilities.</li>
<li><b><span class="tt">align_bytes(n)</span>, <span class="tt">align_kbytes(n)</span>:</b> encode alignment requirements for struct members and buffers. <span class="tt">align_kbytes</span> applies <span class="tt">n * 1024</span> bytes before emitting the metadata.</li>
<li><b>Scheduling helpers:</b> <span class="tt">stack("id")</span>, <span class="tt">runner("hint")</span>, <span class="tt">capabilities(...)</span> reuse the same transform plumbing to annotate execution metadata.</li>
<li><b>Documentation TODO:</b> ship a full catalog of built-in transforms once the borrow checker and effect model solidify; this list captures the current baseline only.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md179"></a>
Core library surface (draft)</h3>
<ul>
<li><b><span class="tt">assign(target, value)</span>:</b> canonical mutation primitive; only valid when <span class="tt">target</span> carries the <span class="tt">mutable</span> flag.</li>
<li><b><span class="tt">plus</span>, <span class="tt">minus</span>, <span class="tt">multiply</span>, <span class="tt">divide</span>:</b> arithmetic wrappers used after operator desugaring.</li>
<li><b><span class="tt">clamp(value, min, max)</span>:</b> numeric helper used heavily in rendering scripts.</li>
<li><b><span class="tt">execute_if&lt;Bool&gt;(cond, then_block{…}, else_block{…})</span>:</b> canonical conditional form after control-flow desugaring.</li>
<li><b><span class="tt">notify(path, payload)</span>, <span class="tt">insert</span>, <span class="tt">take</span>:</b> PathSpace integration hooks for signaling and data movement.</li>
<li><b><span class="tt">return(value)</span>:</b> explicit return primitive; implicit <span class="tt">return(void)</span> fires at end-of-body when omitted.</li>
<li><b>Documentation TODO:</b> expand this surface into a versioned standard library reference before PrimeScript moves onto an active milestone.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md180"></a>
Runtime Stack Model (draft)</h2>
<ul>
<li><b>Frames:</b> each execution pushes a frame recording the instruction pointer, constants, locals, captures, and effect mask. Frames are immutable from the caller’s perspective; <span class="tt">assign</span> creates new bindings.</li>
<li><b>Deterministic evaluation:</b> arguments evaluate left-to-right; <span class="tt">return(value)</span> unwinds automatically. Implicit <span class="tt">return(void)</span> fires if the body reaches the end.</li>
<li><b>Transform boundaries:</b> rewrites annotate frame entry/exit so the VM, C++, and GLSL backends share a consistent calling convention.</li>
<li><b>Resource handles:</b> PathSpace references/handles live inside frames as opaque values; lifetimes follow lexical scope.</li>
<li><b>Tail execution (planned):</b> future optimisation collapses tail executions to reuse frames (VM optional, GPU required).</li>
<li><b>Effect annotations:</b> purity by default; explicit <span class="tt">[effects(...)]</span> opt-ins. Standard library defaults to stdout/stderr effects.</li>
<li><b>Future: stack arenas (optional):</b> exploring named stack arenas (launch executions on specific stacks, clone/snapshot stacks, resume in parallel). Deferred until after v1; flagged as an advanced runtime capability needing copy semantics + effect-safety rules.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md181"></a>
Execution Metadata (draft)</h3>
<ul>
<li><b>Placement:</b> executions may annotate a target stack arena (<span class="tt">[stack("physics")] execute_task&lt;…&gt;(…)</span>). Absent an annotation, they run on the default stack.</li>
<li><b>Scheduler affinity:</b> optional hint for the runtime thread/fiber executing the frame (<span class="tt">[runner("render-thread")]</span>). Backends can ignore hints they cannot satisfy.</li>
<li><b>Capabilities:</b> effect masks double as capability descriptors (IO, global write, GPU access, etc.). Additional attributes can narrow capabilities (<span class="tt">[capabilities(io_stdout, pathspace_insert)]</span>).</li>
<li><b>Instrumentation:</b> executions carry metadata (source file/line, stack id, runner hint) for diagnostics and tracing.</li>
<li><b>Open design items:</b> finalise attribute syntax, scheduling semantics, and enforcement rules for stack/runner hints across VM, C++, and GLSL backends.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md182"></a>
Type &amp; Class Semantics (draft)</h2>
<ul>
<li><b>Structural classes:</b> <span class="tt">[return&lt;void&gt;] class&lt;Name&gt;(members{…})</span> desugars into namespace <span class="tt">Name::</span> plus constructors/metadata. Instances are produced via constructor executions.</li>
<li><b>Composition over inheritance:</b> “extends” rewrites replicate members and install delegation logic; no hidden virtual dispatch unless a transform adds it.</li>
<li><b>Generics:</b> classes accept template parameters (<span class="tt">class&lt;Vector&lt;T&gt;&gt;(…)</span>) and specialise through the transform pipeline.</li>
<li><b>Interop:</b> generated code treats classes as structs plus free functions (<span class="tt">Name::method(instance, …)</span>); VM closures follow the same convention.</li>
<li><b>Open design items:</b> decide field visibility syntax, static/constant member handling, and constructor semantics once package and effect designs settle.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md183"></a>
Lambdas &amp; Higher-Order Functions (draft)</h2>
<ul>
<li><b>Syntax mirrors definitions:</b> lambdas omit the identifier (<span class="tt">[capture] &lt;T&gt;(params){ body }</span>). Captures rewrite into explicit parameters/structs.</li>
<li><b>Capture semantics:</b> support <span class="tt">[]</span>, <span class="tt">[=]</span>, <span class="tt">[&amp;]</span>, and explicit notations (<span class="tt">[value x, ref y]</span>). Captures compile to generated structs with <span class="tt">invoke</span> methods.</li>
<li><b>First-class values:</b> closures are storable, passable, and returnable. Backends emit them as struct + function pointer (C++), inline function objects (GLSL, where legal), or closure objects (VM).</li>
<li><b>Inlining transforms:</b> standard transforms may inline pure lambdas; async/task-oriented lambdas stay as closures.</li>
<li><b>PathSpace interop:</b> captured handles respect frame lifetimes; transforms force reference-count or move semantics as required.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md184"></a>
Literals &amp; Data Blocks (draft)</h2>
<ul>
<li><b>Numeric literals:</b> decimal, float, hexadecimal with optional width suffixes (<span class="tt">42u32</span>, <span class="tt">1.0f64</span>).</li>
<li><b>Strings:</b> quoted with escapes (<span class="tt">"…"</span>) or raw (<span class="tt">R"( … )"</span>).</li>
<li><b>Boolean &amp; null:</b> keywords <span class="tt">true</span>, <span class="tt">false</span>, <span class="tt">null</span> map to backend equivalents.</li>
<li><b>Datum blocks:</b> <span class="tt">datum&lt;Type&gt;{ field = value }</span> desugar into constructor executions; type omitted implies structural inference (<span class="tt">datum{ x = 1, y = 2 }</span>).</li>
<li><b>Collections:</b> <span class="tt">array&lt;Type&gt;{ … }</span>, <span class="tt">map&lt;Key,Value&gt;{ … }</span> (or bracket sugar) rewrite to standard builder functions.</li>
<li><b>Conversions:</b> no implicit coercions. Use explicit executions (<span class="tt">convert&lt;float&gt;(value)</span>) or custom transforms.</li>
<li><b>Mutability:</b> values immutable by default; <span class="tt">[mutable]</span> attribute required to opt-in.</li>
<li><b>Open design:</b> finalise literal suffix catalogue, raw string semantics across backends, and whether datum blocks allow nested includes/compile-time evaluation.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md185"></a>
Pointers &amp; References (draft)</h2>
<ul>
<li><b>Explicit types:</b> <span class="tt">Pointer&lt;T&gt;</span>, <span class="tt">Reference&lt;T&gt;</span> mirror C++ semantics; no implicit conversions.</li>
<li><b>Operator transforms:</b> dereference (<span class="tt">*ptr</span>), address-of (<span class="tt">&amp;value</span>), pointer arithmetic desugar to canonical calls (<span class="tt">deref(ptr)</span>, <span class="tt">address_of(value)</span>, <span class="tt">pointer_add(ptr, offset)</span>).</li>
<li><b>Ownership:</b> references are non-owning, frame-bound views. Pointers can be tagged <span class="tt">raw</span>, <span class="tt">unique</span>, <span class="tt">shared</span> via transform-generated wrappers around PathSpace-aware allocators.</li>
<li><b>Raw memory:</b> <span class="tt">memory::load/store</span> primitives expose byte-level access; opt-in to highlight unsafe operations.</li>
<li><b>Layout control:</b> attributes like <span class="tt">[packed]</span> guarantee interop-friendly layouts for C++/GLSL.</li>
<li><b>Open design:</b> pointer qualifier syntax, aliasing rules (restrict/readonly), and GPU backend constraints remain TBD.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md186"></a>
VM Design (draft)</h2>
<ul>
<li><b>Instruction set:</b> ~50 stack-based ops covering control flow, stack manipulation, memory/pointer access, optional coroutine primitives. No implicit conversions; opcodes mirror the canonical language surface.</li>
<li><b>Frames &amp; stack:</b> per-call frame with IP, constants, locals, capture refs, effect mask; tail calls reuse frames. Data stack stores tagged <span class="tt">Value</span> union (primitives, structs, closures, buffers).</li>
<li><b>Bytecode chunks:</b> compiler emits a chunk (bytecode + const pool) per definition. Executions reference chunks by index; constant pools hold literals, handles, metadata.</li>
<li><b>Native interop:</b> <span class="tt">CALL_NATIVE</span> bridges to host/PathSpace helpers via a function table. Effect masks gate what natives can do.</li>
<li><b>Closures:</b> compile to closure structs (chunk pointer + capture data). Captured handles obey lifetime/ownership rules.</li>
<li><b>Optimisation:</b> reference counting for heap values; optional chunk caching; future LLVM-backed JIT can feed on the same bytecode when needed.</li>
<li><b>Deployment target:</b> the VM serves as the sandboxed runtime for user-supplied scripts (e.g., on iOS) where native code generation is unavailable. Effect masks and capabilities enforce per-platform restrictions.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md187"></a>
Examples (sketch)</h2>
<div class="fragment"><div class="line">// Pull std::io at version 1.2.0</div>
<div class="line">include&lt;&quot;/std/io&quot;, version=&quot;1.2.0&quot;&gt;</div>
<div class="line"> </div>
<div class="line">[return&lt;int&gt; default_operators] add&lt;int&gt;(a, b) { return(plus(a, b)); }</div>
<div class="line"> </div>
<div class="line">[default_operators] execute_add&lt;int&gt;(x, y)</div>
<div class="line"> </div>
<div class="line">clamp_exposure(img) {</div>
<div class="line">  execute_if&lt;bool&gt;(</div>
<div class="line">    greater_than(img.exposure, 1.0f),</div>
<div class="line">    then_block{ notify(&quot;/warn/exposure&quot;, img.exposure); },</div>
<div class="line">    else_block{ }</div>
<div class="line">  );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">tweak_color([copy mutable restrict&lt;Image&gt;] img) {</div>
<div class="line">  assign(img.exposure, clamp(img.exposure, 0.0f, 1.0f));</div>
<div class="line">  assign(img.gamma, plus(img.gamma, 0.1f));</div>
<div class="line">  apply_grade(img);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[return&lt;float&gt; default_operators control_flow desugar_assignment]</div>
<div class="line">float blend(float a, float b) {</div>
<div class="line">  float result = (a + b) * 0.5f;</div>
<div class="line">  if (result &gt; 1.0f) {</div>
<div class="line">    result = 1.0f;</div>
<div class="line">  }</div>
<div class="line">  return result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Canonical, post-transform form</div>
<div class="line">[return&lt;float&gt;] blend&lt;float&gt;(a, b) {</div>
<div class="line">  assign(result, multiply(plus(a, b), 0.5f));</div>
<div class="line">  execute_if&lt;bool&gt;(</div>
<div class="line">    greater_than(result, 1.0f),</div>
<div class="line">    then_block{ assign(result, 1.0f); },</div>
<div class="line">    else_block{ }</div>
<div class="line">  );</div>
<div class="line">  return(result);</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md188"></a>
Integration Points</h2>
<ul>
<li><b>Build system:</b> extend CMake/tooling to run <span class="tt">primescriptc</span>, track dependency graphs, and support incremental builds.</li>
<li><b>PathSpace Scene Graph:</b> helper APIs map PrimeScript modules to scenes/renderers and manage path-based resource bindings.</li>
<li><b>Testing:</b> unit/looped regression suites verify backend parity (C++, VM, GLSL).</li>
<li><b>Diagnostics:</b> metrics/logs land under <span class="tt">diagnostics/primeScript/*</span>. Effect annotations drive error messaging.</li>
<li><b>PathSpace runtime wiring:</b> generated code uses PathSpace helper APIs (<span class="tt">insert</span>, <span class="tt">take</span>, <span class="tt">notify</span>). Transforms wrap high-level IO primitives so emitted C++/VM code interacts through typed handles; GLSL outputs map onto renderer inputs. Lifetimes/ownership align with PathSpace nodes.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md189"></a>
Dependencies &amp; Related Work</h2>
<ul>
<li>Stable IR definition &amp; serialization (std::serialization once available).</li>
<li>Scene graph/rendering plans (<span class="tt"><a class="el" href="_plan___scene_graph___renderer_8md.html">docs/Plan_SceneGraph_Renderer.md</a></span>).</li>
<li>PathIO/device plans for IO abstractions (<span class="tt"><a class="el" href="_a_i___p_a_t_h_s_8md.html">docs/AI_Paths.md</a></span>).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md190"></a>
Risks &amp; Research Tasks</h2>
<ul>
<li><b>Memory model</b> – value/reference semantics, handle lifetimes, POD vs GPU staging rules.</li>
<li><b>Resource bindings</b> – unify descriptors across CPU/GPU backends.</li>
<li><b>Debugging</b> – source maps, stack inspection across VM/GPU.</li>
<li><b>Performance</b> – ensure parity with handwritten code; benchmark harnesses.</li>
<li><b>Adoption</b> – migration strategy from existing shaders/scripts.</li>
<li><b>Diagnostics</b> – map compile/runtime errors back to PrimeScript source across backends.</li>
<li><b>Concurrency</b> – finalise coroutine/await integrations with PathSpace scheduling.</li>
<li><b>Security</b> – sandbox policy for transforms/archives.</li>
<li><b>Tooling</b> – IDE/LSP roadmap, incremental compilation caches, metadata outputs.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md191"></a>
Validation Strategy</h2>
<ul>
<li>Golden tests comparing outputs from C++, VM, GLSL for shared modules.</li>
<li>Performance benchmarks recorded under <span class="tt">benchmarks/</span>.</li>
<li>Static analysis/lint integrated into CI to catch undefined constructs before codegen.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md192"></a>
Next Steps (Exploratory)</h2>
<ol type="1">
<li>Draft detailed syntax/semantics spec and circulate for review.</li>
<li>Prototype parser + IR builder (Phase 0).</li>
<li>Evaluate reuse of existing shader toolchains (glslang, SPIRV-Cross) vs bespoke emitters.</li>
<li>Design import/package system (module syntax, search paths, visibility rules, transform distribution).</li>
<li>Define library/versioning strategy so include resolution enforces compatibility.</li>
<li>Flesh out stack/class specifications (calling convention, class sugar transforms, dispatch strategy) across backends.</li>
<li>Lock down literal/datum syntax across backends and add conformance tests.</li>
<li>Decide machine-code strategy (C++ emission, direct LLVM IR, third-party JIT) and prototype.</li>
<li>Define diagnostics/tooling plan (source maps, error reporting pipeline, incremental tooling, future PathSpace-native editor).</li>
<li>Document staffing/time requirements before promoting PrimeScript onto the active PathSpace roadmap.</li>
</ol>
<hr  />
<p><em>Logged as a research idea on 2025-10-15. Not scheduled for current milestones but tracked for future convergence of scripting and shading.</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
