Mermaid rendering: Enabled
PlantUML rendering: Enabled
SVG in markdown rendering: Enabled
Data presentation: prefer tables (auto-columns)

You are an expert C++ developer tasked with analysing and improving a piece of C++ code.

Conduct an in-depth analysis of the code. Consider the following aspects:

Code structure and organisation
Naming conventions and readability
Efficiency and performance
Potential bugs or errors
Adherence to C++ best practices and C++ community guidelines
Use of appropriate data structures and algorithms
Error handling and edge cases
Modularity and reusability
Comments and documentation
Write your analysis inside <analysis> tags. Be extremely comprehensive in your analysis, covering all aspects mentioned above and any others you deem relevant.

Using chain of thought prompting, explain how to fix issues. Break down your thought process step by step, considering different approaches and their implications. Write your explanation inside <fix_explanation> tags.
Reason out the problem carefully and in step by step manner. You may use the space <thinking></thinking> as your scratchpad and will not be considered by the reader.
Based on your analysis and the fixes you've proposed, come up with a search term that might be useful to find additional information or solutions. Write your search term inside <search_term> tags.

Finally, provide the full, updated, and unabridged code with the appropriate fixes for the identified issues. Remember:

Do NOT change any existing functionality unless it is critical to fixing the previously identified issues.
Only make changes that directly address the identified issues or significantly improve the code based on your analysis.
Ensure that all original functionality remains intact.
You can take multiple messages to complete this task if necessary. Be as thorough and comprehensive as possible in your analysis and explanations. Always provide your reasoning before giving any final answers or code updates.
<project_structure>
.
├── CMakeLists.txt
├── docs
│   └── design.md
├── README.md
├── src
│   └── pathspace
│       ├── CMakeLists.txt
│       ├── core
│       │   ├── BlockOptions.hpp
│       │   ├── ElementType.hpp
│       │   ├── Error.hpp
│       │   ├── ExecutionOptions.hpp
│       │   ├── InOptions.hpp
│       │   ├── InsertReturn.hpp
│       │   ├── NodeData.hpp
│       │   └── OutOptions.hpp
│       ├── path
│       │   ├── ConcreteName.cpp
│       │   ├── ConcreteName.hpp
│       │   ├── ConcretePath.cpp
│       │   ├── ConcretePath.hpp
│       │   ├── ConcretePathIterator.cpp
│       │   ├── ConcretePathIterator.hpp
│       │   ├── ConstructiblePath.hpp
│       │   ├── GlobName.cpp
│       │   ├── GlobName.hpp
│       │   ├── GlobPath.cpp
│       │   ├── GlobPath.hpp
│       │   ├── GlobPathIterator.cpp
│       │   ├── GlobPathIterator.hpp
│       │   ├── Path.cpp
│       │   └── Path.hpp
│       ├── PathSpace.cpp
│       ├── PathSpace.hpp
│       ├── PathSpaceLeaf.cpp
│       ├── PathSpaceLeaf.hpp
│       ├── taskpool
│       │   ├── Task.cpp
│       │   ├── Task.hpp
│       │   ├── TaskPool.cpp
│       │   └── TaskPool.hpp
│       ├── type
│       │   ├── DataCategory.hpp
│       │   ├── helpers
│       │   │   ├── return_type.hpp
│       │   │   ├── serialization_alpaca.hpp
│       │   │   └── serialization_glaze.hpp
│       │   ├── InputData.hpp
│       │   ├── InputMetadata.hpp
│       │   ├── InputMetadataT.hpp
│       │   └── NodeDataHashMap.hpp
│       └── utils
│           ├── TaggedLogger.cpp
│           ├── TaggedLogger.hpp
│           └── WaitMap.hpp
└── tests
    ├── CMakeLists.txt
    ├── test_main.cpp
    └── unit
        ├── path
        │   ├── test_ConcreteName.cpp
        │   ├── test_ConcretePath.cpp
        │   ├── test_ConcretePathIterator.cpp
        │   ├── test_ConstructiblePath.cpp
        │   └── test_GlobPath.cpp
        ├── taskpool
        │   └── test_TaskPool.cpp
        ├── test_PathSpace_extract.cpp
        ├── test_PathSpace_insert.cpp
        ├── test_PathSpace_multithreading.cpp
        ├── test_PathSpace_read.cpp
        └── type
            ├── test_InputData.cpp
            └── test_InputMetadata.cpp

15 directories, 60 files
</project_structure>
<!-- === ./CMakeLists.txt === -->
<CMakeLists.txt>
cmake_minimum_required(VERSION 3.15)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE INTERNAL "")

# Define the project name and the language used
project(PathSpaceTests LANGUAGES CXX)

# Define the C++ standard to use
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Add options for sanitizers
option(ENABLE_THREAD_SANITIZER "Enable Thread Sanitizer" OFF)
option(ENABLE_ADDRESS_SANITIZER "Enable Address Sanitizer" OFF)
option(ENABLE_UNDEFINED_SANITIZER "Enable Undefined Behavior Sanitizer" OFF)

# Check if Clang is used, set it to use libc++
if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  #add_compile_options(-D__cpp_concepts=202002L)
  #add_compile_options(-Wno-builtin-macro-redefined)
  add_compile_options(-stdlib=libc++)
  #add_link_options(-stdlib=libc++)
  #add_link_options(-lc++abi)
  #set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=lld")
endif()

# Apply sanitizer flags if enabled
if(ENABLE_THREAD_SANITIZER)
  add_compile_options(-fsanitize=thread)
  add_link_options(-fsanitize=thread)
elseif(ENABLE_ADDRESS_SANITIZER)
  add_compile_options(-fsanitize=address)
  add_link_options(-fsanitize=address)
elseif(ENABLE_UNDEFINED_SANITIZER)
  add_compile_options(-fsanitize=undefined)
  add_link_options(-fsanitize=undefined)
endif()

enable_testing()
add_subdirectory(src/pathspace)
add_subdirectory(tests)

if(CMAKE_EXPORT_COMPILE_COMMANDS)
  add_custom_target(
    copy-compile-commands ALL
    ${CMAKE_COMMAND} -E copy_if_different
    ${CMAKE_BINARY_DIR}/compile_commands.json
    ${CMAKE_SOURCE_DIR}/compile_commands.json
    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json
  )
endif()</CMakeLists.txt>

<!-- === ./README.md === -->
<README.md>
# PathSpace

PathSpace is a new coordination language that draws inspiration from other coordination languages such as Linda, as well as concepts from reactive programming and data-oriented design. It provides a tuplespace-like system for managing typed hierarchical streams of data and computations.

## Introduction

PathSpace is designed to be a foundational component for larger systems, such as:
- Game engines
- Visualization engines
- Web-based book readers
- Any application requiring a tree-like structure for storing typed distributed data in a thread-safe manner

It's intended to be a multi-platform library supporting at least Windows, Linux, Android, macOS, and iOS.

## Key Features

- **Hierarchical Structure**: Similar to a file system, with PathSpaces as folders and Data as files
- **Typed Data Storage**: Supports various data types, including user-defined serializable classes and lambda functions
- **Polymorphism**: Allows user-supplied child classes to behave differently in different parts of the tree
- **Thread-Safe Operations**: All PathSpace operations are designed to be thread-safe
- **Glob Expressions**: Supports glob-style path matching for flexible data access
- **JSON Serialization**: Built-in support for JSON serialization and deserialization
- **Capability-based Access Control**: Fine-grained control over data access and operations

## Core Operations

1. **Insert**: Add data or a PathSpace to one or more paths
2. **Read**: Retrieve a copy of the value at a specified path
3. **Extract**: Similar to read, but removes the data from the PathSpace

## Advanced Features

- **Blocking Operations**: Wait for data to become available
- **Execution Management**: Support for lambda functions and delayed execution
- **Data Compression**: Automatic data compression and decompression
- **Out-of-core Storage**: Ability to store data on disk instead of RAM
- **Reactive Programming Support**: Enables creation of reactive data flows
- **Distributed Data Management**: Replication of spaces across multiple computers (planned)

## Use Cases

PathSpace can be used to implement various systems, including:
- Scene graphs for 3D renderers
- Vulkan renderers with easy mesh and shader management
- Just-in-time geometry generation systems
- Operating system-like environments with user and file system management
- Database front-ends</README.md>

<!-- === ./docs/design.md === -->
<design.md>
# PathSpace
![PathSpace](images/PathSpace.jpeg)

## Introduction
PathSpace is a coordination language that enables insertion and extractions from paths in a thread safe datastructure. The data structure supports views of the paths similar to Plan 9. The data attached to the paths are more like a JSON datastructure than files though. The data supported is standard C++ data types and data structures from the standard library, user created structs/classes as well as function pointers, std::function or function objects for storing executions that generate values to be inserted at a path.

## Internal Data
PathSpace can be seen as a map between a path and a vector of data. Inserting more data to the path will append it to the end. Reading data from the path will return a copy of the front data. Extracting data from a path will pop and return the front data of the vector for the path.

## Syntax Example
```
PathSpace space;
space.insert("/collection/numbers", 5);
space.insert("/collection/numbers", 3.5f);
assert(space.extract<int>("/collection/numbers").value() == 5);
assert(space.read<float>("/collection/numbers").value() == 3.5);

space.insert("/collection/executions", [](){return 7;});
assert(space.extractBlock<int>("/collection/numbers").value() == 7);
```

## Polymorphism
The internal spaces inside a path are implemented witha  PathSpaceLeaf class, it's possible to inherit from that class and insert that child class in order to change the
behaviour of parts of the path structure of a PathSpace instance. This can be used to have different behaviour for different sub spaces within a PathSpace. By default PathSpace
will create a PathSpaceLeaf of the same type as the parent when creating new ones (which happens during insert of data).

## Path Globbing
Paths given to insert can be a glob expression, if the expression matches the names of subspaces then the data will be inserted to all the matching subspaces.
````
PathSpace space;
space.insert("/collection/numbers", 5);
space.insert("/collection/numbers_more", 4);
space.insert("/collection/other_things", 3);
space.insert("/collection/numbers*", 2);
assert(space.extract<int>("/collection/other_things").value() == 2);
assert(!space.extract<int>("/collection/other_things").has_value());
assert(space.extract<int>("/collection/numbers_more").value() == 4);
assert(space.extract<int>("/collection/numbers_more").value() == 2);
```

## Blocking
It's possible to send a blocking object to insert/read/extract instructing it to wait a certain amount of time for data to arrive if it is currently empty or non-existent.


## Operations
The operations in the base language are insert/read/extract, they are implemented as member functions of the PathSpace class.
* **Insert**: 
	* Insert data or a PathSpaceLeaf to one or more paths. If the path does not exist it will be created.
	* The given path can be a concrete path in which case at most one object will be inserted or a glob expression path which could potentially insert multiple values.
	* Supports batch operations by inserting an initialiser list
	* Takes an optional InOptions which has the following properties:
		* Optional Execution object that describes how to execute the data (if the data is a lambda or function):
			* Execute immediately or when the user requests the data via read/extract.
			* If the data should be cached and updated every n milliseconds.
				* How many times the function should be executed.
			* If the value to be stored is executed in a lazy fashion or right away.
		* Optional Block object specifying what to do if the value does not (yet) exist, enables waiting forever or a set amount of time.
	* The data inserted can be:
		* Executions with signature T() or T(ConcretePath const &path, PathSpace &space) :
			* Lambda
			* Function pointer
			* std::function
			* Preregistered executions for serialisation/deserialisation over the network.
		* Data
			* Fundamental types
			* Standard library containers if serialisable
			* User created structures/classes as long as they are serialisable
	* Returns an InsertReturn structure with the following information:
		* How many items/Tasks were inserted.
		* What errors occurred during insertion.
	* Syntax:
		* InsertReturn PathSpace::insert<T>(GlobPath const &path, T const &value, optional<InOptions> const &options={})
* **Read**:
	* Returns a copy of the front value at the supplied path or Error if it could not be found, if for example the path did not exist or the front value had the wrong type.
	* Takes an optional ReadOptions which has the following properties:
		* Optional Block object specifying what to do if the data does not exist or paths to the data do not exist:
			* Wait forever if data/space does not exist
			* Wait a specified amount of milliseconds if data/space does not exist
			* Return an error
	* Takes a ConcretePath, does not support GlobPaths. Perhaps will implement a readMultiple later that returns a vector<T>
	* Syntax:
		* std::expected<T, Error> PathSpace::read<T>(ConcretePath const &path, optional<ReadOptions> const &options={})
* **Extract**: 
	* Same as read but pops the front data instead of just returning a copy.
	* Syntax:
		* std::expected<T, Error> PathSpace::extract<T>(ConcretePath, Block, optional<OutOptions> const &options={})

## Data Storage
A normal PathSpace will store data by serialising it to a std::vector<std::byte>. That vector can contain data of different types and a separate vector storing std::type_id pointers
together with how many objects or that type are in a row will be used to determine what parts of the data vector has what type. std::function objects will be stored in their own vector
as well since they can not be serialised. Insert will append serialised data to this vector. Extract will not necessarily erase from the front of the vector since this would be too costly,
a pointer to the front element will instead be stored and its position changed forward when a extract is issued. At first the serialisation will be done via the alpaca library but when a
compiler supporting the C++26 serialisation functionality it will be rewritten to use that instead.

## Unit Testing
Unit testing will be done by using the C++ doctest library. A test driven development method will be used.

## Logging
A log of every action can be produced. This is mostly for aiding in debugging.

## Exception Handling
PathSpaces will not throw exceptions, all errors will be handled via the return type of the operations.

## Licensing
PathSpace will be under an open source license, likely GPL-3.

## Trellis
Lazy executions can be chained together via blocking operations waiting for new data, when one execution updates a value another listener to that value can execute.
This creates a trellis like structure as described in the book mirror worlds book where values are fed from bottom processes and filtered up into higher order processes.

## Actor Based Programming
An actor system could be implemented with PathSpace by having executions within the PathSpace as actors communicating via messages sent to mailboxes at predefined paths, the mailboxes
could simply be std::string objects stored at those paths.

## Bottlenecks
Linda like tuple spaces have traditionally been seen as slow. To some degree this is due to the pattern matching required to extract data from a tuple. 
### Path Caching
In PathSpace the slowest part will be traversing the path hierarchy. Potentially this could be sped up if we provide a cache of the most recent lookups of paths for insert/read/extract.
Could be done as a hashmap from a ConcretePath to a PathSpace*. Would need to clear the cache on extract, or other PathSpace removals.

### Reactive programming
The extendability of a PathSpace can be used to create a reactive data flow, for example by creating a child PathSpace that takes n other PathSpace paths as input and combines their
values by extractbing from them or a PathSpace that performs a transformation on any data from n other paths. Each tuple can be seen as a data stream as long as they are alive, when
they run out of items the stream dies. One example could be a lambda within the space that waits for the left mouse button to be pressed via space.read<int>(“/system/mouse/button_down”,
ReadOptions{.block=true}).

## Example Use Cases
* Scene Graph - Objects to be displayed by a 3d renderer. Mainly takes care of seamlessly interacting with the renderer to upload and display objects in the graph. Could also support data oriented design by having composable objects that store their properties in a list instead of objects in a list.
* Vulcan Render - A renderer that integrates with the GPU via Vulcan. Makes it easy to upload and use meshes and shaders.
* ISO Surface Generator - Just in time generation of geometry to display, taking LOD into account. It can have an internal path like …/generate/x_y_y that can be read to start the generation.
* Operating System - The capabilities functionality can be used to implement a user system and file system similar to Unix. When the initial PathSpace has been filled a process for the root user with full capability can be started by launching a lambda that executes a script. This is similar to how on login a bash session is started with a default script. This process can in turn launch other processes similar to systemd or cron.
* Database front end - Interpreter to a proper database library adding or changing data within it. For example mariadb or postgressql.
* GraphQL server to interact with html/javascript

## Not Yet Implemented Features

### Temporary Data Path
Will not write out any data for state saving and if a user logs out all their created data will be deleted. Will usually be at /tmp, with user dirs as /tmp/username.

### Scripting
There will be support for manipulating a PathSpace through lua. Issuing an operator can then be done without having to reference a space object, like so: insert(“/a”, 5).
But separate space objects could be created as variables in the script and could be used by the normal space_name.insert(… usage.

### Command line
Using a live script interpreter a command line can be written.

### Compression
Compresses the input data seamlessly behind the scene on insert and decompresses it on read/extract.

### Out-of-core
Similar to compression but can store the data on the hard drive instead of in RAM.

### Distributed Data
Another specialisation is to create a PathSpace child that can replicate a space over several computers over the network. Duplicating data where needed. May use Asia for networking.
Like a live object.

## Memory (not yet implemented)
In order to avoid memory allocation calls to the operating system the PathSpace could have a pre-allocated pool of memory from the start. Perhaps some PathSpace tuple data could be marked
as non essential somehow, if an out of memory situation occurs such data could be erased or flushed to disk. The alpha version of PathSpace will not contain this feature and will allocate
all memory via std standard allocators.

## Metadata (not yet implemented)
Every PathSpace will have some metadata such as last time read, last time modified, how many times modified (same as version). Testing will be done by using a special CMake project that uses one .cpp file per operation to test.

## Documentation (not yet implemented)
Documentation with examples and descriptions of the API will be provided on the GitHub page for the project.

### Metrics Collection (not yet implemented)
Will be possible to collect metrics on the data for the paths, how often they are accessed etc.

### Data Integrity (not yet implemented)
Especially for the networking part some checking for data consistency will be needed.

## Distributed Networking
### Transaction Support
TBD
### Multi-Version Consistency Control
TBD
### Conflict-Free Replicated Data Types
TBD
### Invariant-based Reasoning
TBD

### Version Migration Utilities
TBD

## Back-Pressure Handling
TBD

## Default Paths
TBD

## Live Objects
TBD

## Fault Tolerance
TBD

## Views
TBD

## Operating System
TBD</design.md>

<!-- === ./src/pathspace/PathSpace.hpp === -->
<PathSpace.hpp>
#pragma once
#include "PathSpaceLeaf.hpp"
#include "core/OutOptions.hpp"
#include "path/GlobPath.hpp"
#include "taskpool/TaskPool.hpp"
#include "utils/TaggedLogger.hpp"
#include "utils/WaitMap.hpp"

namespace SP {
class PathSpace {
public:
    /**
     * @brief Constructs a PathSpace object.
     * @param pool Pointer to a TaskPool for managing asynchronous operations. If nullptr, uses the global instance.
     */
    explicit PathSpace(TaskPool* pool = nullptr);
    ~PathSpace();

    /**
     * @brief Inserts data into the PathSpace at the specified path.
     *
     * @tparam DataType The type of data being inserted.
     * @param path The glob-style path where the data should be inserted.
     * @param data The data to be inserted.
     * @param options Options controlling the insertion behavior, such as overwrite policies.
     * @return InsertReturn object containing information about the insertion operation, including any errors.
     */
    template <typename DataType>
    auto insert(GlobPathStringView const& path, DataType&& data, InOptions const& options = {}) -> InsertReturn {
        log("PathSpace::insert", "Function Called");
        InputData inputData{std::forward<DataType>(data)};
        ConstructiblePath constructedPath = path.isConcrete() ? ConstructiblePath{path} : ConstructiblePath{};

        if (inputData.metadata.category == DataCategory::ExecutionFunctionPointer
            || inputData.metadata.category == DataCategory::ExecutionStdFunction) {
            bool const isImmidiate
                    = (!options.execution.has_value())
                      || (options.execution.has_value() && options.execution.value().category == ExecutionOptions::Category::Immediate);
            bool const isOnReadOrExtract
                    = options.execution.has_value() && options.execution.value().category == ExecutionOptions::Category::OnReadOrExtract;
            if (std::optional<Task> task = this->createTask(constructedPath, std::forward<DataType>(data), inputData, options)) {
                if (isImmidiate) {
                    this->pool->addTask(std::move(task.value()));
                    return {.nbrTasksCreated = 1};
                } else if (isOnReadOrExtract) {
                    inputData.task = std::move(task);
                }
            }
        }

        return this->in(constructedPath, path, inputData, options);
    }

    /**
     * @brief Reads data from the PathSpace at the specified path.
     *
     * @tparam DataType The type of data to be read.
     * @param path The concrete path from which to read the data.
     * @param options Options controlling the read behavior, such as blocking policies.
     * @return Expected<DataType> containing the read data if successful, or an error if not.
     */
    template <typename DataType>
    auto read(ConcretePathStringView const& path, OutOptions const& options = {.doPop = false}) const -> Expected<DataType> {
        log("PathSpace::read", "Function Called");
        if (options.doPop)
            return std::unexpected(Error{Error::Code::PopInRead, std::string("read does not support doPop: ").append(path.getPath())});
        DataType obj;
        if (auto ret = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj); !ret)
            return std::unexpected(ret.error());
        return obj;
    }

    template <typename DataType>
    auto readBlock(ConcretePathStringView const& path,
                   OutOptions const& options = {.block{{.behavior = BlockOptions::Behavior::Wait}}, .doPop = false}) const
            -> Expected<DataType> {
        log("PathSpace::readBlock", "Function Called");
        DataType obj;
        auto result = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj);

        if (result.has_value() || !options.block.has_value()
            || (options.block.has_value() && options.block.value().behavior == BlockOptions::Behavior::DontWait)) {
            if (result.has_value() && result.value() > 0) {
                return obj;
            }
            std::unexpected(result.error());
        }

        bool const exitLoopAfterFirstRun = options.block && options.block->timeout;
        auto const timeout = (options.block && options.block->timeout) ? std::chrono::system_clock::now() + *options.block->timeout
                                                                       : std::chrono::system_clock::time_point::max();
        auto guard = waitMap.wait(path);
        while (!result.has_value() && !this->shuttingDown.load()) {
            if (guard.wait_until(timeout, [&]() {
                    result = const_cast<PathSpace*>(this)->out(path, InputMetadataT<DataType>{}, options, &obj);
                    return (result.has_value() && result.value() > 0) || this->shuttingDown.load();
                })) {
                break;
            }
            if (exitLoopAfterFirstRun)
                break;
        }

        if (this->shuttingDown.load()) {
            return std::unexpected(Error{Error::Code::Shutdown, "PathSpace is shutting down"});
        }

        if (result.has_value() && result.value() > 0) {
            return obj;
        }
        return std::unexpected(result.error());
    }

    /**
     * @brief Reads and removes data from the PathSpace at the specified path.
     *
     * @tparam DataType The type of data to be extractbed.
     * @param path The concrete path from which to extract the data.
     * @return Expected<DataType> containing the extractbed data if successful, or an error if not.
     */
    template <typename DataType>
    auto extract(ConcretePathStringView const& path, OutOptions const& options = {}) -> Expected<DataType> {
        log("PathSpace::extract", "Function Called");
        DataType obj;
        auto const ret = this->out(path, InputMetadataT<DataType>{}, options, &obj);
        if (!ret)
            return std::unexpected(ret.error());
        if (ret.has_value() && (ret.value() == 0))
            return std::unexpected(Error{Error::Code::NoObjectFound, std::string("Object not found at: ").append(path.getPath())});
        return obj;
    }

    template <typename DataType>
    auto extractBlock(ConcretePathStringView const& path, OutOptions const& options = {.block{{.behavior = BlockOptions::Behavior::Wait}}})
            -> Expected<DataType> {
        log("PathSpace::extractBlock", "Function Called");
        DataType obj;
        auto result = this->out(path, InputMetadataT<DataType>{}, options, &obj);

        if (result.has_value() || !options.block.has_value()
            || (options.block.has_value() && options.block.value().behavior == BlockOptions::Behavior::DontWait)) {
            if (result.has_value() && result.value() > 0) {
                return obj;
            }
            return std::unexpected(result.error());
        }

        bool const exitLoopAfterFirstRun = options.block && options.block->timeout;
        auto const timeout = (options.block && options.block->timeout) ? std::chrono::system_clock::now() + *options.block->timeout
                                                                       : std::chrono::system_clock::time_point::max();
        auto guard = waitMap.wait(path);
        while (!result.has_value() && !this->shuttingDown.load()) {
            if (guard.wait_until(timeout, [&]() {
                    result = this->out(path, InputMetadataT<DataType>{}, options, &obj);
                    return (result.has_value() && result.value() > 0) || this->shuttingDown.load();
                })) {
                break;
            }
            if (exitLoopAfterFirstRun)
                break;
        }

        if (this->shuttingDown.load()) {
            return std::unexpected(Error{Error::Code::Shutdown, "PathSpace is shutting down"});
        }

        if (result.has_value() && result.value() > 0) {
            return obj;
        }
        return std::unexpected(result.error());
    }

    auto clear() -> void;

protected:
    template <typename DataType>
    auto createTask(ConstructiblePath const& constructedPath, DataType const& data, InputData const& inputData, InOptions const& options)
            -> std::optional<Task> { // ToDo:: Add support for glob based executions
        log("PathSpace::createTask", "Function Called");
        if constexpr (ExecutionFunctionPointer<DataType> || ExecutionStdFunction<DataType>) {
            auto function = [userFunction = std::move(data)](Task const& task, void* obj, bool isOut) {
                if (isOut) {
                    *static_cast<std::function<std::invoke_result_t<DataType>()>*>(obj) = userFunction;
                } else {
                    if (obj == nullptr) {
                        assert(task.space != nullptr);
                        task.space->insert(task.pathToInsertReturnValueTo.getPath(), userFunction());
                    } else {
                        *static_cast<std::invoke_result_t<DataType>*>(obj) = userFunction();
                    }
                }
            };
            return Task{.space = this,
                        .pathToInsertReturnValueTo = constructedPath,
                        .executionOptions = options.execution.has_value() ? options.execution.value() : ExecutionOptions{},
                        .function = std::move(function)};
        }
        return std::nullopt;
    }

    virtual auto in(ConstructiblePath& constructedPath, GlobPathStringView const& path, InputData const& data, InOptions const& options)
            -> InsertReturn;

    virtual auto out(ConcretePathStringView const& path, InputMetadata const& inputMetadata, OutOptions const& options, void* obj)
            -> Expected<int>;

    auto shutdown() -> void;

    TaskPool* pool = nullptr;
    PathSpaceLeaf root;
    std::atomic<bool> shuttingDown{false};
    mutable WaitMap waitMap;
};

} // namespace SP</PathSpace.hpp>

<!-- === ./src/pathspace/CMakeLists.txt === -->
<CMakeLists.txt>
#if ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
#    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")
#endif()

include(FetchContent)

FetchContent_Declare(
  nlohmann
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG v3.11.3
)
FetchContent_MakeAvailable(nlohmann)

FetchContent_Declare(
  ParallelHashmap
  GIT_REPOSITORY https://github.com/greg7mdp/parallel-hashmap.git
  GIT_TAG v1.3.11
)
FetchContent_MakeAvailable(ParallelHashmap)

FetchContent_Declare(
  glaze
  GIT_REPOSITORY https://github.com/stephenberry/glaze.git
  GIT_TAG main
  GIT_SHALLOW TRUE
)
FetchContent_MakeAvailable(glaze)

FetchContent_Declare(
    alpaca
    GIT_TAG 6bed0a0
    GIT_REPOSITORY https://github.com/p-ranav/alpaca.git
)
FetchContent_MakeAvailable(alpaca)

FetchContent_Declare(
  foonathan_memory
    GIT_TAG 016c9fb
    GIT_REPOSITORY https://github.com/foonathan/memory
)
FetchContent_MakeAvailable(foonathan_memory)

# Indicate that we only want to compile source files into a library
add_library(PathSpace
    path/ConcretePath.cpp
    path/ConcreteName.cpp
    path/ConcretePathIterator.cpp
    path/GlobPath.cpp
    path/GlobPathIterator.cpp
    path/GlobName.cpp
    path/Path.cpp
    taskpool/Task.cpp
    taskpool/TaskPool.cpp
    utils/TaggedLogger.cpp
    PathSpace.cpp
    PathSpaceLeaf.cpp
)

target_compile_options(PathSpace PUBLIC "-Wno-deprecated")

target_include_directories(PathSpace
PUBLIC
    ${CMAKE_SOURCE_DIR}/src/pathspace
    ${CMAKE_SOURCE_DIR}/src/
    ${CMAKE_SOURCE_DIR}/include
    ${parallelhashmap_SOURCE_DIR}
    ${nlohmann_SOURCE_DIR}/include
    ${cereal_SOURCE_DIR}/include
    ${glaze_SOURCE_DIR}/include
    ${cista_SOURCE_DIR}/include
    ${alpaca_SOURCE_DIR}/include
    ${foonathan_memory_SOURCE_DIR}/include
)

target_link_libraries(PathSpace
PRIVATE
    glaze::glaze
    foonathan_memory
)

set_target_properties(PathSpace PROPERTIES PUBLIC_HEADER "PathSpace.hpp")

if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(PathSpace PRIVATE SP_LOG_DEBUG)
endif()

install(TARGETS PathSpace
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
    PUBLIC_HEADER DESTINATION include
)
</CMakeLists.txt>

<!-- === ./src/pathspace/type/InputData.hpp === -->
<InputData.hpp>
#pragma once
#include "pathspace/type/InputMetadata.hpp"

#include <functional>

namespace SP {
struct Task;

struct InputData {
    template <typename T>
    InputData(T&& in) : metadata(InputMetadataT<T>{}) {
        if constexpr (std::is_function_v<std::remove_pointer_t<std::decay_t<T>>> || std::is_member_function_pointer_v<std::decay_t<T>>) {
            this->obj = reinterpret_cast<void*>(+in);
        } else {
            this->obj = const_cast<void*>(static_cast<const void*>(&in));
        }
    }

    void* obj = nullptr;
    std::optional<Task> task;
    InputMetadata metadata;
};

} // namespace SP</InputData.hpp>

<!-- === ./src/pathspace/type/InputMetadataT.hpp === -->
<InputMetadataT.hpp>
#pragma once
#include "type/helpers/serialization_alpaca.hpp"
// #include "type/helpers/serialization_glaze.hpp"
</InputMetadataT.hpp>

<!-- === ./src/pathspace/type/helpers/serialization_glaze.hpp === -->
<serialization_glaze.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "pathspace/taskpool/TaskPool.hpp"
#include "type/helpers/return_type.hpp"

#include <cassert>

#include "glaze/glaze.hpp"
#define SERIALIZATION_TYPE std::byte
namespace SP {

template <typename T>
static auto serialize_glaze(void const* objPtr, std::vector<std::byte>& bytes) -> void {
    T const& obj = *static_cast<T const*>(objPtr);
    std::vector<std::byte> tmp;
    glz::write_binary_untagged(obj, tmp);
    bytes.insert(bytes.end(), tmp.begin(), tmp.end());
}

template <typename T>
static auto deserialize_glaze(void* objPtr, std::vector<std::byte> const& bytes) -> void {
    T* obj = static_cast<T*>(objPtr);
    auto error = glz::read_binary_untagged(obj, bytes);
    assert(!error);
}

template <typename T>
static auto deserialize_pop_glaze(void* objPtr, std::vector<std::byte>& bytes) -> void {
    deserialize_glaze<T>(objPtr, bytes);
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(T));
}

template <typename CVRefT>
struct InputMetadataT {
    using T = std::remove_cvref_t<CVRefT>;
    InputMetadataT() = default;

    static constexpr auto serialize = &serialize_glaze<T>;
    static constexpr auto deserialize = &deserialize_glaze<T>;
    static constexpr auto deserializePop = &deserialize_pop_glaze<T>;
};

} // namespace SP</serialization_glaze.hpp>

<!-- === ./src/pathspace/type/helpers/return_type.hpp === -->
<return_type.hpp>
#pragma once
/*
    Defines a helper template ReturnTypeInfo that can return a type_info pointer
    for any type. If the type is a function pointer, it will return the return value type.
*/

template <typename T>
struct return_type_helper {
    using type = std::remove_cvref_t<T>;
};

template <typename R, typename... Args>
struct return_type_helper<R (*)(Args...)> {
    using type = R;
};

template <typename R, typename... Args>
struct return_type_helper<R(Args...)> {
    using type = R;
};

template <typename T>
concept Invocable = requires(T t) { std::invoke(t); };

template <Invocable T>
struct return_type_helper<T> {
    using type = std::invoke_result_t<T>;
};

template <typename T>
std::type_info const* ReturnTypeInfo = &typeid(typename return_type_helper<std::remove_cvref_t<T>>::type);</return_type.hpp>

<!-- === ./src/pathspace/type/helpers/serialization_alpaca.hpp === -->
<serialization_alpaca.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "taskpool/TaskPool.hpp"
#include "type/DataCategory.hpp"
#include "type/helpers/return_type.hpp"
#include "utils/TaggedLogger.hpp"

#include <cassert>
#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <type_traits>
#include <vector>

#define SERIALIZATION_TYPE uint8_t
#include <alpaca/alpaca.h>

namespace SP {
struct PathSpace;

// ########### Alpaca Serialization ###########

template <typename T>
static auto serialize_alpaca(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    struct Wrapper {
        T wrappedObject;
    };
    Wrapper wrapper{*static_cast<T const*>(objPtr)};

    try {
        // Serialize the object
        std::vector<uint8_t> tempBytes;
        size_t bytesWritten = alpaca::serialize<Wrapper, 1>(wrapper, tempBytes);

        // Store the size of the serialized data
        uint32_t size = static_cast<uint32_t>(bytesWritten);
        bytes.insert(bytes.end(), reinterpret_cast<const uint8_t*>(&size), reinterpret_cast<const uint8_t*>(&size) + sizeof(size));

        // Append the serialized data
        bytes.insert(bytes.end(), tempBytes.begin(), tempBytes.begin() + bytesWritten);

        log("Object serialized successfully", "INFO");
    } catch (const std::exception& e) {
        log("Serialization failed: " + std::string(e.what()), "ERROR");
        throw;
    }
}

template <typename T>
static auto deserialize_alpaca_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    if (bytes.size() < sizeof(uint32_t)) {
        log("Not enough data to read size", "ERROR");
        throw std::runtime_error("Not enough data to read size");
    }

    uint32_t size;
    std::memcpy(&size, bytes.data(), sizeof(uint32_t));

    if (bytes.size() < sizeof(uint32_t) + size) {
        log("Not enough data to deserialize object", "ERROR");
        throw std::runtime_error("Not enough data to deserialize object");
    }

    struct Wrapper {
        T wrappedObject;
    };

    std::error_code ec;
    std::vector<uint8_t> deserializeBytes(bytes.begin() + sizeof(uint32_t), bytes.begin() + sizeof(uint32_t) + size);
    auto wrapper = alpaca::deserialize<Wrapper, 1>(deserializeBytes, ec);

    if (ec) {
        log("Deserialization failed: " + ec.message(), "ERROR");
        throw std::runtime_error("Deserialization failed: " + ec.message());
    }

    // Copy the deserialized object to the output
    *static_cast<T*>(objPtr) = std::move(wrapper.wrappedObject);

    // Remove the read data from the input vector
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(uint32_t) + size);

    log("Object deserialized successfully", "INFO");
}

template <typename T>
static auto deserialize_alpaca_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    if (bytes.size() < sizeof(uint32_t)) {
        log("Not enough data to read size", "ERROR");
        throw std::runtime_error("Not enough data to read size");
    }

    uint32_t size;
    std::memcpy(&size, bytes.data(), sizeof(uint32_t));

    if (bytes.size() < sizeof(uint32_t) + size) {
        log("Not enough data to deserialize object", "ERROR");
        throw std::runtime_error("Not enough data to deserialize object");
    }

    struct Wrapper {
        T wrappedObject;
    };

    std::error_code ec;
    std::vector<uint8_t> deserializeBytes(bytes.begin() + sizeof(uint32_t), bytes.begin() + sizeof(uint32_t) + size);
    auto wrapper = alpaca::deserialize<Wrapper, 1>(deserializeBytes, ec);

    if (ec) {
        log("Deserialization failed: " + ec.message(), "ERROR");
        throw std::runtime_error("Deserialization failed: " + ec.message());
    }

    // Copy the deserialized object to the output
    *static_cast<T*>(objPtr) = std::move(wrapper.wrappedObject);

    log("Object deserialized successfully", "INFO");
}

template <typename T>
concept AlpacaCompatible = !std::is_pointer_v<T> && requires(T t, std::vector<uint8_t>& v) {
    { serialize_alpaca<T>(static_cast<void const*>(&t), v) };
    { deserialize_alpaca_const<T>(static_cast<void*>(&t), v) };
};

// ########### Fundamental Datatype Serialization ###########

template <typename T>
static auto serialize_fundamental(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    static_assert(std::is_fundamental_v<T>, "T must be a fundamental type");
    T const& obj = *static_cast<T const*>(objPtr);
    auto const* begin = reinterpret_cast<uint8_t const*>(&obj);
    auto const* end = begin + sizeof(T);
    bytes.insert(bytes.end(), begin, end);
}

template <typename T>
static auto deserialize_fundamental_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    static_assert(std::is_fundamental_v<T>, "T must be a fundamental type");
    if (bytes.size() < sizeof(T)) {
        return;
    }
    T* obj = static_cast<T*>(objPtr);
    std::copy(bytes.begin(), bytes.begin() + sizeof(T), reinterpret_cast<uint8_t*>(obj));
}

template <typename T>
static auto deserialize_fundamental_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    deserialize_fundamental_const<T>(objPtr, bytes);
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(T));
}

static auto serialize_function_pointer(void const* objPtr, std::vector<uint8_t>& bytes) -> void {
    auto funcPtr = *static_cast<void (**)()>(const_cast<void*>(objPtr));
    auto funcPtrInt = reinterpret_cast<std::uintptr_t>(funcPtr);
    auto const* begin = reinterpret_cast<uint8_t const*>(&funcPtrInt);
    auto const* end = begin + sizeof(funcPtrInt);
    bytes.insert(bytes.end(), begin, end);
}

static auto deserialize_function_pointer_pop(void* objPtr, std::vector<uint8_t>& bytes) -> void {
    if (bytes.size() < sizeof(std::uintptr_t)) {
        return;
    }
    std::uintptr_t funcPtrInt;
    std::copy(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t), reinterpret_cast<uint8_t*>(&funcPtrInt));
    auto funcPtr = reinterpret_cast<void (*)()>(funcPtrInt);
    *static_cast<void (**)()>(objPtr) = funcPtr;
    bytes.erase(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t));
}

static auto deserialize_function_pointer_const(void* objPtr, std::vector<uint8_t> const& bytes) -> void {
    if (bytes.size() < sizeof(std::uintptr_t)) {
        return;
    }
    std::uintptr_t funcPtrInt;
    std::copy(bytes.begin(), bytes.begin() + sizeof(std::uintptr_t), reinterpret_cast<uint8_t*>(&funcPtrInt));
    auto funcPtr = reinterpret_cast<void (*)()>(funcPtrInt);
    *static_cast<void (**)()>(objPtr) = funcPtr;
}

template <typename T>
concept FunctionPointer = requires {
    requires std::is_pointer_v<T>;
    requires std::is_function_v<std::remove_pointer_t<T>>;
};

template <typename T>
concept ExecutionFunctionPointer
        = (std::is_function_v<std::remove_pointer_t<T>> || std::is_member_function_pointer_v<T> || requires(T& t) { +t; })
          && // Unary plus operator, which attempts to convert to function pointer
          requires(T t) {
              t(); // Can be called with no arguments
          };

template <typename T, typename R = void>
concept ExecutionStdFunction = requires(T f) { requires std::is_convertible_v<T, std::function<R()>>; };

template <typename CVRefT>
struct InputMetadataT {
    using T = std::remove_cvref_t<CVRefT>;
    InputMetadataT() = default;

    static constexpr std::type_info const* typeInfo = []() {
        if constexpr (ExecutionFunctionPointer<T> || ExecutionStdFunction<T>) {
            return &typeid(std::invoke_result_t<T>);
        }
        return &typeid(T);
    }();

    static constexpr DataCategory const category = []() {
        if constexpr (ExecutionFunctionPointer<T>) {
            return DataCategory::ExecutionFunctionPointer;
        } else if constexpr (FunctionPointer<T>) {
            return DataCategory::FunctionPointer;
        } else if constexpr (ExecutionStdFunction<T>) {
            return DataCategory::ExecutionStdFunction;
        } else if constexpr (std::is_fundamental<T>::value) {
            return DataCategory::Fundamental;
        } else if constexpr (AlpacaCompatible<T>) {
            return DataCategory::SerializationLibraryCompatible;
        } else {
            return DataCategory::None;
        }
    }();

    static constexpr auto serialize = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return &serialize_function_pointer;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &serialize_fundamental<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &serialize_alpaca<T>;
        } else {
            return nullptr;
        }
    }();

    static constexpr auto deserialize = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return deserialize_function_pointer_const;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (FunctionPointer<T>) {
            return &deserialize_function_pointer_const;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &deserialize_fundamental_const<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &deserialize_alpaca_const<T>;
        } else {
            return nullptr;
        }
    }();

    static constexpr auto deserializePop = []() {
        if constexpr (ExecutionFunctionPointer<T> || FunctionPointer<T>) {
            return &deserialize_function_pointer_pop;
        } else if constexpr (ExecutionStdFunction<T>) {
            return nullptr;
        } else if constexpr (FunctionPointer<T>) {
            return nullptr;
        } else if constexpr (std::is_fundamental<T>::value) {
            return &deserialize_fundamental_pop<T>;
        } else if constexpr (AlpacaCompatible<T>) {
            return &deserialize_alpaca_pop<T>;
        } else {
            return nullptr;
        }
    }();
};

} // namespace SP
</serialization_alpaca.hpp>

<!-- === ./src/pathspace/type/InputMetadata.hpp === -->
<InputMetadata.hpp>
#pragma once
#include <type_traits>
#include <typeinfo>

#include "pathspace/type/DataCategory.hpp"
#include "pathspace/type/InputMetadataT.hpp"

namespace SP {

struct InputMetadata {
    InputMetadata() = default;
    template <typename CVRefT, typename T = std::remove_cvref_t<CVRefT>>
    InputMetadata(InputMetadataT<CVRefT> const& obj)
        : category(obj.category), typeInfo(obj.typeInfo), serialize(obj.serialize), deserialize(obj.deserialize),
          deserializePop(obj.deserializePop) {
    }

    DataCategory category;
    std::type_info const* typeInfo = nullptr;
    void (*serialize)(void const* obj, std::vector<SERIALIZATION_TYPE>&) = nullptr;
    void (*deserialize)(void* obj, std::vector<SERIALIZATION_TYPE> const&) = nullptr;
    void (*deserializePop)(void* obj, std::vector<SERIALIZATION_TYPE>&) = nullptr;
};

} // namespace SP</InputMetadata.hpp>

<!-- === ./src/pathspace/type/DataCategory.hpp === -->
<DataCategory.hpp>
#pragma once
#include <typeinfo>

namespace SP {

enum struct DataCategory {
    None = 0,
    SerializedData,
    ExecutionFunctionPointer,
    FunctionPointer,
    ExecutionStdFunction,
    Fundamental,
    SerializationLibraryCompatible
};

} // namespace SP</DataCategory.hpp>

<!-- === ./src/pathspace/type/NodeDataHashMap.hpp === -->
<NodeDataHashMap.hpp>
#pragma once
#include "core/NodeData.hpp"
#include "path/ConcreteName.hpp"

#include <parallel_hashmap/phmap.h>

namespace SP {
class PathSpaceLeaf;
class PathSpace;
using NodeDataHashMap = phmap::parallel_node_hash_map<
        SP::ConcreteNameString,
        std::variant<SP::NodeData, std::unique_ptr<SP::PathSpaceLeaf>>,
        std::hash<SP::ConcreteNameString>,
        std::equal_to<SP::ConcreteNameString>,
        std::allocator<std::pair<const SP::ConcreteNameString, std::variant<SP::NodeData, std::unique_ptr<SP::PathSpaceLeaf>>>>,
        12, // Number of submaps
        std::mutex>;

} // namespace SP
</NodeDataHashMap.hpp>

<!-- === ./src/pathspace/PathSpaceLeaf.hpp === -->
<PathSpaceLeaf.hpp>
#pragma once
#include "path/ConcretePathIterator.hpp"
#include "path/GlobPathIterator.hpp"
#include "type/NodeDataHashMap.hpp"

namespace SP {
struct Error;
struct InOptions;
struct InsertReturn;
struct InputData;
struct OutOptions;
struct ConstructiblePath;

class PathSpaceLeaf {
public:
    auto in(ConstructiblePath& path,
            GlobPathIteratorStringView const& iter,
            GlobPathIteratorStringView const& end,
            InputData const& inputData,
            InOptions const& options,
            InsertReturn& ret) -> void;
    auto out(ConcretePathIteratorStringView const& iter,
             ConcretePathIteratorStringView const& end,
             InputMetadata const& inputMetadata,
             void* obj,
             OutOptions const& options) -> Expected<int>;

    auto clear() -> void;

private:
    auto inFinalComponent(ConstructiblePath& path,
                          GlobName const& pathComponent,
                          InputData const& inputData,
                          InOptions const& options,
                          InsertReturn& ret) -> void;
    auto inIntermediateComponent(ConstructiblePath& path,
                                 GlobPathIteratorStringView const& iter,
                                 GlobPathIteratorStringView const& end,
                                 GlobName const& pathComponent,
                                 InputData const& inputData,
                                 InOptions const& options,
                                 InsertReturn& ret) -> void;

    auto outDataName(ConcreteNameStringView const& concreteName,
                     ConcretePathIteratorStringView const& nextIter,
                     ConcretePathIteratorStringView const& end,
                     InputMetadata const& inputMetadata,
                     void* obj,
                     OutOptions const& options) -> Expected<int>;
    auto outConcretePathComponent(ConcretePathIteratorStringView const& nextIter,
                                  ConcretePathIteratorStringView const& end,
                                  ConcreteNameStringView const& concreteName,
                                  InputMetadata const& inputMetadata,
                                  void* obj,
                                  OutOptions const& options) -> Expected<int>;
    NodeDataHashMap nodeDataMap;
};

} // namespace SP</PathSpaceLeaf.hpp>

<!-- === ./src/pathspace/core/ExecutionOptions.hpp === -->
<ExecutionOptions.hpp>
#pragma once
#include <chrono>

namespace SP {

struct ExecutionOptions {
    enum class Category {
        Immediate,
        OnReadOrExtract,
        PeriodicImmidiate,
        PeriodicOnRead,
        Never
    };
    enum class Location {
        Any,
        MainThread
    };
    enum class Priority {
        Low,
        Middle,
        High
    };

    Category category = Category::Immediate;
    Location location = Location::Any;
    Priority priority = Priority::Middle;
    std::optional<std::chrono::milliseconds> updateInterval;
    std::optional<uint32_t> maxNbrExecutions;
    bool cacheResult = false; // Converts function pointer/object to stored value for future read/extract operations
};

} // namespace SP</ExecutionOptions.hpp>

<!-- === ./src/pathspace/core/InOptions.hpp === -->
<InOptions.hpp>
#pragma once
#include "BlockOptions.hpp"
#include "ExecutionOptions.hpp"

#include <optional>

namespace SP {

struct InOptions {
    std::optional<ExecutionOptions> execution;
    std::optional<BlockOptions> block;
    std::optional<int> maxInsertionsForBlob;
    bool createDirectoriesAlongPath = true;
};

} // namespace SP</InOptions.hpp>

<!-- === ./src/pathspace/core/NodeData.hpp === -->
<NodeData.hpp>
#pragma once

#include "ElementType.hpp"
#include "Error.hpp"
#include "ExecutionOptions.hpp"
#include "InOptions.hpp"
#include "InsertReturn.hpp"
#include "type/DataCategory.hpp"
#include "type/InputData.hpp"
#include "type/InputMetadata.hpp"

#include <cassert>
#include <deque>
#include <expected>
#include <optional>

namespace SP {

struct NodeData {
    NodeData() = default;
    NodeData(InputData const& inputData, InOptions const& options, InsertReturn& ret) {
        this->serialize(inputData, options, ret);
    }

    auto serialize(const InputData& inputData, const InOptions& options, InsertReturn& ret) -> std::optional<Error> {
        if (inputData.task.has_value()) {
            this->tasks.push_back(std::move(inputData.task.value()));
            ret.nbrTasksCreated++;
        } else {
            if (!inputData.metadata.serialize)
                return Error{Error::Code::SerializationFunctionMissing, "Serialization function is missing."};
            inputData.metadata.serialize(inputData.obj, data);
        }
        pushType(inputData.metadata);
        return std::nullopt;
    }

    auto deserialize(void* obj, const InputMetadata& inputMetadata, std::optional<ExecutionOptions> const& execution) const
            -> Expected<int> {
        return const_cast<NodeData*>(this)->deserializeImpl(obj, inputMetadata, execution, false);
    }

    auto deserializePop(void* obj, const InputMetadata& inputMetadata) -> Expected<int> {
        return deserializeImpl(obj, inputMetadata, std::nullopt, true);
    }

private:
    std::vector<SERIALIZATION_TYPE> data;
    std::deque<Task> tasks;
    std::deque<ElementType> types;

    auto deserializeImpl(void* obj, const InputMetadata& inputMetadata, std::optional<ExecutionOptions> const& execution, bool shouldPop)
            -> Expected<int> {
        if (types.empty())
            return 0;

        if (this->types.front().typeInfo != inputMetadata.typeInfo)
            return 0;

        if (this->types.front().category == DataCategory::ExecutionFunctionPointer
            || this->types.front().category == DataCategory::ExecutionStdFunction) {
            assert(!this->tasks.empty());
            if (inputMetadata.category == DataCategory::ExecutionStdFunction)
                this->tasks.front().function(this->tasks.front(), obj, true);
            else
                this->tasks.front().function(this->tasks.front(), obj, false);
            if (shouldPop) {
                this->tasks.pop_front();
                popType();
            }
            return 1;
        }

        if (shouldPop) {
            if (!inputMetadata.deserializePop) {
                return std::unexpected(Error{Error::Code::UnserializableType, "No pop deserialization function provided."});
            }
            inputMetadata.deserializePop(obj, data);
            popType();
        } else {
            if (!inputMetadata.deserialize) {
                return std::unexpected(Error{Error::Code::UnserializableType, "No deserialization function provided."});
            }
            inputMetadata.deserialize(obj, data);
        }
        return 1;
    }

    auto pushType(InputMetadata const& meta) -> void {
        if (!types.empty()) {
            if (types.back().typeInfo == meta.typeInfo)
                types.back().elements++;
            else
                types.emplace_back(meta.typeInfo, 1, meta.category);
        } else {
            types.emplace_back(meta.typeInfo, 1, meta.category);
        }
    }

    auto popType() -> void {
        if (!this->types.empty()) {
            if (--this->types.front().elements == 0) {
                this->types.erase(this->types.begin());
            }
        }
    }
};

} // namespace SP</NodeData.hpp>

<!-- === ./src/pathspace/core/BlockOptions.hpp === -->
<BlockOptions.hpp>
#pragma once

#include <chrono>
#include <optional>

struct BlockOptions {
    enum class Behavior {
        DontWait,
        WaitForExecution,
        WaitForExistence,
        Wait
    };

    Behavior behavior = Behavior::DontWait;
    std::optional<std::chrono::milliseconds> timeout;
};</BlockOptions.hpp>

<!-- === ./src/pathspace/core/InsertReturn.hpp === -->
<InsertReturn.hpp>
#pragma once
#include "Error.hpp"

#include <cstdint>
#include <vector>

namespace SP {

struct InsertReturn {
    uint32_t nbrValuesInserted = 0;
    uint32_t nbrSpacesInserted = 0;
    uint32_t nbrTasksCreated = 0;
    std::vector<Error> errors;
};

} // namespace SP</InsertReturn.hpp>

<!-- === ./src/pathspace/core/ElementType.hpp === -->
<ElementType.hpp>
#pragma once

#include "type/DataCategory.hpp"

#include <stdint.h>
#include <typeinfo>

namespace SP {

struct ElementType {
    std::type_info const* typeInfo = nullptr;
    uint32_t elements = 0;
    DataCategory category = DataCategory::SerializedData;
};

} // namespace SP</ElementType.hpp>

<!-- === ./src/pathspace/core/OutOptions.hpp === -->
<OutOptions.hpp>
#pragma once
#include "BlockOptions.hpp"
#include "ExecutionOptions.hpp"

#include <optional>

namespace SP {

struct OutOptions {
    std::optional<ExecutionOptions> execution;
    std::optional<BlockOptions> block;
    std::optional<int> maxReadsForBlob;
    bool doPop = true;
};

} // namespace SP</OutOptions.hpp>

<!-- === ./src/pathspace/core/Error.hpp === -->
<Error.hpp>
#pragma once
#include <expected>
#include <optional>
#include <string>

namespace SP {

struct Error {
    enum class Code {
        NoSuchPath,
        InvalidPath,
        InvalidPathSubcomponent,
        InvalidType,
        Timeout,
        CapabilityMismatch,
        CapabilityWriteMissing,
        MemoryAllocationFailed,
        MalformedInput,
        UnmatchedQuotes,
        UnknownError,
        SerializationFunctionMissing,
        UnserializableType,
        NoObjectFound,
        PopInRead,
        Shutdown
    };

    Code code;
    std::optional<std::string> message;

    Error(Code c, std::string m) : code(c), message(std::move(m)) {
    }
};

template <typename T>
using Expected = std::expected<T, Error>;

} // namespace SP</Error.hpp>

<!-- === ./src/pathspace/PathSpace.cpp === -->
<PathSpace.cpp>
#include "PathSpace.hpp"
#include "core/BlockOptions.hpp"

namespace SP {

PathSpace::PathSpace(TaskPool* pool) {
    log("PathSpace::PathSpace", "Function Called");
    if (this->pool == nullptr)
        this->pool = &TaskPool::Instance();
};

PathSpace::~PathSpace() {
    log("PathSpace::~PathSpace", "Function Called");
    this->shutdown();
}

auto PathSpace::clear() -> void {
    log("PathSpace::clear", "Function Called");
    this->root.clear();
    this->waitMap.clear();
}

auto PathSpace::shutdown() -> void {
    log("PathSpace::shutdown", "Function Called");
    this->shuttingDown.exchange(true);
    this->waitMap.notifyAll();
}

auto PathSpace::in(ConstructiblePath& constructedPath, GlobPathStringView const& path, InputData const& data, InOptions const& options)
        -> InsertReturn {
    log("PathSpace::in", "Function Called");
    InsertReturn ret;
    if (!path.isValid()) {
        ret.errors.emplace_back(Error::Code::InvalidPath, std::string("The path was not valid: ").append(path.getPath()));
        return ret;
    }

    this->root.in(constructedPath, path.begin(), path.end(), data, options, ret);

    if (ret.nbrSpacesInserted > 0 || ret.nbrValuesInserted > 0 || ret.nbrTasksCreated) {
        waitMap.notify(path.getPath()); // ToDo:: Fix glob path situation
    }
    return ret;
}

auto PathSpace::out(ConcretePathStringView const& path, InputMetadata const& inputMetadata, OutOptions const& options, void* obj)
        -> Expected<int> {
    log("PathSpace::out", "Function Called");
    return this->root.out(path.begin(), path.end(), inputMetadata, obj, options);
}

} // namespace SP</PathSpace.cpp>

<!-- === ./src/pathspace/taskpool/TaskPool.cpp === -->
<TaskPool.cpp>
#include "TaskPool.hpp"
#include <stdexcept>

namespace SP {

TaskPool& TaskPool::Instance() {
    static TaskPool instance;
    return instance;
}

TaskPool::TaskPool(size_t threadCount) : stop(false), availableThreads(0) {
    if (threadCount == 0) {
        threadCount = std::thread::hardware_concurrency();
    }
    for (size_t i = 0; i < threadCount; ++i) {
        workers.emplace_back(&TaskPool::workerFunction, this);
    }
}

TaskPool::~TaskPool() {
    shutdown();
}

auto TaskPool::addTask(Task&& task) -> void {
    std::lock_guard<std::mutex> lock(taskMutex);
    if (task.executionOptions.location == ExecutionOptions::Location::MainThread)
        tasksMainThread.emplace(std::move(task));
    else
        tasks.emplace(std::move(task));
    taskCV.notify_one();
}

void TaskPool::shutdown() {
    {
        std::unique_lock<std::mutex> lock(taskMutex);
        stop = true;
        taskCV.notify_all();
    }
    for (std::thread& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }
}

size_t TaskPool::size() const {
    return workers.size();
}

void TaskPool::workerFunction() {
    while (true) {
        Task task;
        {
            std::unique_lock<std::mutex> lock(taskMutex);
            taskCV.wait(lock, [this]() { return this->stop || !this->tasks.empty(); });

            if (this->stop && this->tasks.empty()) {
                break;
            }

            if (!tasks.empty()) {
                task = std::move(tasks.front());
                tasks.pop();
            } else {
                continue;
            }
        }

        {
            std::unique_lock<std::mutex> counterLock(availableThreadsMutex);
            availableThreads++;
        }

        if (task.function) {
            task.function(task, nullptr, false);
        }

        {
            std::unique_lock<std::mutex> counterLock(availableThreadsMutex);
            availableThreads--;
        }
    }
}

} // namespace SP</TaskPool.cpp>

<!-- === ./src/pathspace/taskpool/TaskPool.hpp === -->
<TaskPool.hpp>
#pragma once
#include "Task.hpp"

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <optional>
#include <queue>
#include <thread>
#include <vector>

namespace SP {

struct PathSpace;

class TaskPool {
public:
    TaskPool(size_t threadCount = 0);
    ~TaskPool();

    static TaskPool& Instance();

    TaskPool(TaskPool const&) = delete;
    auto operator=(TaskPool const&) -> TaskPool& = delete;

    auto addTask(Task&& task) -> void;

    auto shutdown() -> void;
    auto size() const -> size_t;

private:
    auto workerFunction() -> void;

    std::vector<std::thread> workers;
    std::queue<Task> tasks;
    std::queue<Task> tasksMainThread;
    std::mutex taskMutex, availableThreadsMutex;
    std::condition_variable taskCV;
    std::atomic<bool> stop;
    std::atomic<size_t> availableThreads;
};

} // namespace SP</TaskPool.hpp>

<!-- === ./src/pathspace/taskpool/Task.cpp === -->
<Task.cpp>
#include "taskpool/Task.hpp"

namespace SP {} // namespace SP</Task.cpp>

<!-- === ./src/pathspace/taskpool/Task.hpp === -->
<Task.hpp>
#pragma once
#include "core/ExecutionOptions.hpp"
#include "path/ConstructiblePath.hpp"
#include <cassert>
#include <functional>
#include <variant>

namespace SP {
struct PathSpace;

struct Task {
    PathSpace* space = nullptr;                  // Returned values from the execution will be inserted here
    ConstructiblePath pathToInsertReturnValueTo; // On this path, the return value will be inserted.
    ExecutionOptions executionOptions;

    std::function<void(Task const& task, void* obj, bool isOut)> function;
};

} // namespace SP</Task.hpp>

<!-- === ./src/pathspace/PathSpaceLeaf.cpp === -->
<PathSpaceLeaf.cpp>
#include "PathSpaceLeaf.hpp"
#include "core/BlockOptions.hpp"
#include "core/Error.hpp"
#include "core/InOptions.hpp"
#include "core/InsertReturn.hpp"
#include "core/OutOptions.hpp"
#include "path/ConstructiblePath.hpp"
#include "pathspace/type/InputData.hpp"
#include "type/InputData.hpp"

namespace SP {

auto PathSpaceLeaf::clear() -> void {
    this->nodeDataMap.clear();
}

/*
    ############# In #############
*/

auto PathSpaceLeaf::in(ConstructiblePath& path,
                       GlobPathIteratorStringView const& iter,
                       GlobPathIteratorStringView const& end,
                       InputData const& inputData,
                       InOptions const& options,
                       InsertReturn& ret) -> void {
    std::next(iter) == end ? inFinalComponent(path, *iter, inputData, options, ret)
                           : inIntermediateComponent(path, iter, end, *iter, inputData, options, ret);
}

auto PathSpaceLeaf::inFinalComponent(ConstructiblePath& path,
                                     GlobName const& pathComponent,
                                     InputData const& inputData,
                                     InOptions const& options,
                                     InsertReturn& ret) -> void {
    path.append(pathComponent.getName());

    if (pathComponent.isGlob()) {
        // Create a vector to store the keys that match before modification. ToDo: Memory allocation
        std::vector<ConcreteNameString> matchingKeys;

        // First pass: Collect all matching keys without holding write locks
        nodeDataMap.for_each([&](auto& item) {
            const auto& key = item.first;
            if (std::get<0>(pathComponent.match(key))) {
                matchingKeys.push_back(key);
            }
        });

        // Second pass: Modify matching nodes with proper locking
        for (const auto& key : matchingKeys) {
            nodeDataMap.modify_if(key, [&](auto& nodePair) {
                if (auto* nodeData = std::get_if<NodeData>(&nodePair.second)) {
                    if (auto error = nodeData->serialize(inputData, options, ret); error.has_value()) {
                        ret.errors.emplace_back(error.value());
                    }
                    ret.nbrValuesInserted++;
                    return true; // Indicate that modification occurred
                }
                return false; // No modification if it's not a NodeData
            });
        }
    } else {
        nodeDataMap.try_emplace_l(
                pathComponent.getName(),
                [&](auto& value) {
                    if (auto* nodeData = std::get_if<NodeData>(&value.second)) {
                        if (auto error = nodeData->serialize(inputData, options, ret); error.has_value()) {
                            ret.errors.emplace_back(error.value());
                        }
                    }
                },
                NodeData{inputData, options, ret});
        ret.nbrValuesInserted++;
    }
}

auto PathSpaceLeaf::inIntermediateComponent(ConstructiblePath& path,
                                            GlobPathIteratorStringView const& iter,
                                            GlobPathIteratorStringView const& end,
                                            GlobName const& pathComponent,
                                            InputData const& inputData,
                                            InOptions const& options,
                                            InsertReturn& ret) -> void {
    path.append(pathComponent.getName());
    auto nextIter = std::next(iter);

    if (pathComponent.isGlob()) {
        nodeDataMap.for_each([&](const auto& item) {
            const auto& key = item.first;
            if (std::get<0>(pathComponent.match(key))) {
                if (const auto* leaf = std::get_if<std::unique_ptr<PathSpaceLeaf>>(&item.second)) {
                    (*leaf)->in(path, nextIter, end, inputData, options, ret);
                }
            }
        });
    } else {
        auto [it, inserted] = nodeDataMap.try_emplace(pathComponent.getName(), std::make_unique<PathSpaceLeaf>());
        if (auto* leaf = std::get_if<std::unique_ptr<PathSpaceLeaf>>(&it->second)) {
            (*leaf)->in(path, nextIter, end, inputData, options, ret);
        }
    }
}

/*
    ############# Out #############
*/

auto PathSpaceLeaf::out(ConcretePathIteratorStringView const& iter,
                        ConcretePathIteratorStringView const& end,
                        InputMetadata const& inputMetadata,
                        void* obj,
                        OutOptions const& options) -> Expected<int> {
    auto const nextIter = std::next(iter);
    auto const pathComponent = *iter;
    return nextIter == end ? outDataName(pathComponent, nextIter, end, inputMetadata, obj, options)
                           : outConcretePathComponent(nextIter, end, pathComponent, inputMetadata, obj, options);
}

auto PathSpaceLeaf::outDataName(ConcreteNameStringView const& concreteName,
                                ConcretePathIteratorStringView const& nextIter,
                                ConcretePathIteratorStringView const& end,
                                InputMetadata const& inputMetadata,
                                void* obj,
                                OutOptions const& options) -> Expected<int> {
    Expected<int> result = std::unexpected(Error{Error::Code::NoSuchPath, "Path not found"});

    nodeDataMap.modify_if(concreteName.getName(), [&](auto& nodePair) {
        if (auto* nodeData = std::get_if<NodeData>(&nodePair.second)) {
            if (options.doPop) {
                result = nodeData->deserializePop(obj, inputMetadata);
            } else {
                result = nodeData->deserialize(obj, inputMetadata, options.execution);
            }
            return options.doPop; // Only modify (remove) if it's a pop operation
        }
        return false;
    });

    return result;
}

auto PathSpaceLeaf::outConcretePathComponent(ConcretePathIteratorStringView const& nextIter,
                                             ConcretePathIteratorStringView const& end,
                                             ConcreteNameStringView const& concreteName,
                                             InputMetadata const& inputMetadata,
                                             void* obj,
                                             OutOptions const& options) -> Expected<int> {
    Expected<int> expected = std::unexpected(Error{Error::Code::NoSuchPath, "Path not found"});
    this->nodeDataMap.if_contains(concreteName.getName(), [&](auto const& nodePair) {
        expected = std::holds_alternative<std::unique_ptr<PathSpaceLeaf>>(nodePair.second)
                           ? std::get<std::unique_ptr<PathSpaceLeaf>>(nodePair.second)->out(nextIter, end, inputMetadata, obj, options)
                           : std::unexpected(Error{Error::Code::InvalidPathSubcomponent, "Sub-component name is data"});
    });
    return expected;
}

} // namespace SP</PathSpaceLeaf.cpp>

<!-- === ./src/pathspace/path/Path.hpp === -->
<Path.hpp>
#pragma once

namespace SP {

template <typename T>
struct Path {
    Path() = default;
    Path(T const& path);

    auto isValid() const -> bool;
    auto getPath() const -> T const&;
    auto setPath(T const& path) -> void;

protected:
    T path;
};

} // namespace SP</Path.hpp>

<!-- === ./src/pathspace/path/GlobName.cpp === -->
<GlobName.cpp>
#include "GlobName.hpp"

namespace SP {

auto is_glob(std::string_view const& strv) -> bool {
    bool previousCharWasEscape = false;
    for (auto const& ch : strv) {
        if (ch == '\\' && !previousCharWasEscape) {
            previousCharWasEscape = true;
            continue;
        }
        if (previousCharWasEscape) {
            previousCharWasEscape = false;
            continue;
        }
        if (ch == '*' || ch == '?' || ch == '[' || ch == ']') {
            return true;
        }
    }
    return false;
}

GlobName::GlobName(char const* const ptr) : name(ptr) {
}

GlobName::GlobName(std::string::const_iterator const& iter, std::string::const_iterator const& endIter) : name(iter, endIter) {
}

GlobName::GlobName(std::string_view::const_iterator const& iter, std::string_view::const_iterator const& endIter) : name(iter, endIter) {
}

auto GlobName::operator<=>(GlobName const& other) const -> std::strong_ordering {
    return this->name <=> other.name;
}

auto GlobName::operator==(GlobName const& other) const -> bool {
    return this->name == other.name;
}

auto GlobName::operator==(ConcreteNameStringView const& other) const -> bool {
    return this->name == other.name;
}

auto GlobName::operator==(char const* const other) const -> bool {
    return this->name == other;
}

auto GlobName::match(const std::string_view& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/> {
    size_t globIdx = 0;
    size_t strIdx = 0;

    while (strIdx < str.size()) {
        if (this->name[globIdx] == '\\') {
            // Handle escape character
            globIdx++; // Skip backslash
            if (globIdx < this->name.size() && this->name[globIdx] == str[strIdx]) {
                // Match the escaped character literally
                ++strIdx;
                ++globIdx;
            } else {
                // Mismatch, glob pattern does not match filename
                return {false, false};
            }
        } else if (globIdx < this->name.size() && this->name[globIdx] == '?') {
            globIdx++;
            strIdx++;
        } else if (globIdx < this->name.size() && this->name[globIdx] == '*') {
            size_t nextGlobIdx = globIdx + 1;
            if (nextGlobIdx < this->name.size() && this->name[nextGlobIdx] == '*') { // ** matches across name edge
                return {true, true};
            }

            if (nextGlobIdx == this->name.size()) {
                return {true, false}; // Trailing '*' matches everything
            }

            size_t matchIdx = strIdx;
            while (matchIdx < str.size() && str[matchIdx] != this->name[nextGlobIdx]) {
                matchIdx++;
            }

            if (matchIdx == str.size()) {
                return {false, false};
            }

            globIdx = nextGlobIdx;
            strIdx = matchIdx;
        } else if (globIdx < this->name.size() && this->name[globIdx] == '[') {
            globIdx++;
            bool invert = false;
            if (globIdx < this->name.size() && this->name[globIdx] == '!') {
                invert = true;
                globIdx++;
            }

            bool matched = false;
            char prevChar = '\0';
            bool inRange = false;

            while (globIdx < this->name.size() && this->name[globIdx] != ']') {
                if (this->name[globIdx] == '-' && prevChar != '\0' && globIdx + 1 < this->name.size()) {
                    inRange = true;
                    prevChar = this->name[globIdx + 1];
                    globIdx += 2;
                } else {
                    if (inRange) {
                        if (strIdx < str.size() && str[strIdx] >= prevChar && str[strIdx] <= this->name[globIdx]) {
                            matched = true;
                        }
                        inRange = false;
                    } else {
                        if (strIdx < str.size() && str[strIdx] == this->name[globIdx]) {
                            matched = true;
                        }
                    }
                    prevChar = this->name[globIdx];
                    globIdx++;
                }
            }

            if ((invert && !matched) || (!invert && matched)) {
                strIdx++;
            } else {
                return {false, false};
            }
        } else {
            if (strIdx < str.size() && this->name[globIdx] == str[strIdx]) {
                globIdx++;
                strIdx++;
            } else {
                return {false, false};
            }
        }
    }

    while (globIdx < this->name.size() && this->name[globIdx] == '*') {
        globIdx++;
    }

    return {globIdx == this->name.size() && strIdx == str.size(), false};
}

auto GlobName::match(const ConcreteNameStringView& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/> {
    return this->match(str.name);
}

auto GlobName::match(const ConcreteNameString& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/> {
    return this->match(str.getName());
}

auto GlobName::isConcrete() const -> bool {
    return !this->isGlob();
}

auto GlobName::isGlob() const -> bool {
    return is_glob(this->name);
}

auto GlobName::getName() const -> std::string_view const& {
    return this->name;
}

} // namespace SP</GlobName.cpp>

<!-- === ./src/pathspace/path/ConcreteName.hpp === -->
<ConcreteName.hpp>
#pragma once
#include <functional>
#include <string>
#include <string_view>

namespace SP {

template <typename T>
struct ConcreteName {
    ConcreteName() = default;
    ConcreteName(char const* const ptr);
    ConcreteName(std::string const& str);
    ConcreteName(std::string_view const& name);
    ConcreteName(std::string::const_iterator const& iter, std::string::const_iterator const& endIter);
    ConcreteName(std::string_view::const_iterator const& iter, std::string_view::const_iterator const& endIter);

    auto operator<=>(ConcreteName<T> const& other) const -> std::strong_ordering;
    auto operator==(ConcreteName<T> const& other) const -> bool;
    auto operator==(char const* const other) const -> bool;

    auto getName() const -> std::string_view const;

    template <class Archive>
    void serialize(Archive& ar) {
        ar(std::string{this->name});
    }

    friend struct GlobName;

private:
    T name;
};

using ConcreteNameStringView = ConcreteName<std::string_view>;
using ConcreteNameString = ConcreteName<std::string>;

} // namespace SP

namespace std {

template <>
struct hash<SP::ConcreteNameStringView> {
    std::size_t operator()(const SP::ConcreteNameStringView& name) const noexcept {
        return std::hash<std::string_view>{}(name.getName());
    }
};

template <>
struct hash<SP::ConcreteNameString> {
    std::size_t operator()(const SP::ConcreteNameString& name) const noexcept {
        return std::hash<std::string_view>{}(name.getName());
    }
};

} // namespace std</ConcreteName.hpp>

<!-- === ./src/pathspace/path/ConcreteName.cpp === -->
<ConcreteName.cpp>
#include "ConcreteName.hpp"

namespace SP {

template <typename T>
ConcreteName<T>::ConcreteName(char const* const ptr) : name(ptr) {
}

template <typename T>
ConcreteName<T>::ConcreteName(std::string_view const& name) : name(name) {
}

template <typename T>
ConcreteName<T>::ConcreteName(std::string::const_iterator const& iter, std::string::const_iterator const& endIter) : name(iter, endIter) {
}

template <typename T>
ConcreteName<T>::ConcreteName(std::string const& str) : name(str) {
}

template <typename T>
ConcreteName<T>::ConcreteName(std::string_view::const_iterator const& iter, std::string_view::const_iterator const& endIter)
    : name(iter, endIter) {
}

template <typename T>
auto ConcreteName<T>::operator<=>(ConcreteName<T> const& other) const -> std::strong_ordering {
    return this->name <=> other.name;
}

template <typename T>
auto ConcreteName<T>::operator==(ConcreteName<T> const& other) const -> bool {
    return this->name == other.name;
}

template <typename T>
auto ConcreteName<T>::operator==(char const* const other) const -> bool {
    return this->name == other;
}

template <typename T>
auto ConcreteName<T>::getName() const -> std::string_view const {
    return this->name;
}

template struct ConcreteName<std::string>;
template struct ConcreteName<std::string_view>;

} // namespace SP</ConcreteName.cpp>

<!-- === ./src/pathspace/path/GlobPath.hpp === -->
<GlobPath.hpp>
#pragma once
#include "ConcretePath.hpp"
#include "GlobPathIterator.hpp"
#include "Path.hpp"

#include <string>
#include <string_view>

namespace SP {

template <typename T>
struct GlobPath : public Path<T> {
    auto begin() const -> GlobPathIterator<T>;
    auto end() const -> GlobPathIterator<T>;

    GlobPath() = default;
    GlobPath(std::string_view const& sv);
    GlobPath(std::string const& s);
    GlobPath(char const* path);

    auto operator<=>(GlobPath<T> const& other) const -> std::strong_ordering;
    auto operator==(std::string_view const& other) const -> bool;
    template <typename U>
    auto operator==(ConcretePath<U> const& other) const -> bool;
    template <typename U>
    auto operator==(GlobPath<U> const& other) const -> bool;

    auto isConcrete() const -> bool;
    auto isGlob() const -> bool;
};
using GlobPathString = GlobPath<std::string>;
using GlobPathStringView = GlobPath<std::string_view>;

} // namespace SP
</GlobPath.hpp>

<!-- === ./src/pathspace/path/Path.cpp === -->
<Path.cpp>
#include <string>
#include <string_view>

#include "path/Path.hpp"

namespace SP {
template <typename T>
Path<T>::Path(T const& path) : path(path) {
}

template <typename T>
auto Path<T>::isValid() const -> bool {
    if (this->path.size() < 1) // Must start with / and have at least one name.
        return false;

    if (this->path[0] != '/')
        return false;

    // Check for relative paths like '.', '..', etc. Names not allowed to start with .
    if (this->path.contains("/."))
        return false;

    return true;
}

template <typename T>
auto Path<T>::getPath() const -> T const& {
    return this->path;
}

template <typename T>
auto Path<T>::setPath(T const& path) -> void {
    this->path = path;
}

template struct Path<std::string>;
template struct Path<std::string_view>;
} // namespace SP</Path.cpp>

<!-- === ./src/pathspace/path/ConcretePath.cpp === -->
<ConcretePath.cpp>
#include "ConcretePath.hpp"

namespace SP {

template <typename T>
auto ConcretePath<T>::begin() const -> ConcretePathIterator<T> {
    return {this->path.begin(), this->path.end()};
}

template <typename T>
auto ConcretePath<T>::end() const -> ConcretePathIterator<T> {
    return {this->path.end(), this->path.end()};
}

template <typename T>
ConcretePath<T>::ConcretePath(std::string_view const& sv) : Path<T>(std::is_same_v<T, std::string> ? T(std::string(sv)) : T(sv)) {
}

template <typename T>
ConcretePath<T>::ConcretePath(std::string const& s) : Path<T>(s) {
}

template <typename T>
ConcretePath<T>::ConcretePath(char const* const t) : Path<T>(t) {
}

template <typename T>
auto ConcretePath<T>::operator==(std::string_view const& otherView) const -> bool {
    ConcretePathStringView const other{otherView};
    if (!this->isValid() || !other.isValid())
        return false;
    auto iterA = this->begin();
    auto iterB = other.begin();
    while (iterA != this->end() && iterB != other.end()) {
        if (*iterA != *iterB)
            return false;
        ++iterA;
        ++iterB;
    }
    return iterA == this->end() && iterB == other.end();
}

template <typename T>
auto ConcretePath<T>::operator==(ConcretePath<T> const& other) const -> bool {
    return this->operator==(std::string_view{other.getPath()});
}

template <typename T>
auto ConcretePath<T>::operator==(char const* const other) const -> bool {
    return this->operator==(std::string_view{other});
}

// Explicit instantiations
template struct ConcretePath<std::string>;
template struct ConcretePath<std::string_view>;

// Explicit instantiations for non-member functions
template auto operator<=>(std::string_view, ConcretePath<std::string> const&) -> std::strong_ordering;
template auto operator==(std::string_view, ConcretePath<std::string> const&) -> bool;
template auto operator<=>(std::string_view, ConcretePath<std::string_view> const&) -> std::strong_ordering;
template auto operator==(std::string_view, ConcretePath<std::string_view> const&) -> bool;

// New explicit instantiations for mixed ConcretePath comparisons
template auto ConcretePath<std::string>::operator<=>(const ConcretePath<std::string_view>&) const -> std::strong_ordering;
template auto ConcretePath<std::string>::operator==(const ConcretePath<std::string_view>&) const -> bool;
template auto ConcretePath<std::string_view>::operator<=>(const ConcretePath<std::string>&) const -> std::strong_ordering;
template auto ConcretePath<std::string_view>::operator==(const ConcretePath<std::string>&) const -> bool;

template auto operator<=>(const ConcretePath<std::string>&, const ConcretePath<std::string_view>&) -> std::strong_ordering;
template auto operator==(const ConcretePath<std::string>&, const ConcretePath<std::string_view>&) -> bool;
template auto operator<=>(const ConcretePath<std::string_view>&, const ConcretePath<std::string>&) -> std::strong_ordering;
template auto operator==(const ConcretePath<std::string_view>&, const ConcretePath<std::string>&) -> bool;

} // namespace SP</ConcretePath.cpp>

<!-- === ./src/pathspace/path/ConcretePath.hpp === -->
<ConcretePath.hpp>
#pragma once
#include "ConcretePathIterator.hpp"
#include "Path.hpp"

#include <compare>
#include <functional>
#include <string>
#include <string_view>

namespace SP {

template <typename T>
struct ConcretePath : public Path<T> {
    using Path<T>::Path; // Inherit constructors

    auto begin() const -> ConcretePathIterator<T>;
    auto end() const -> ConcretePathIterator<T>;

    ConcretePath() = default;
    ConcretePath(std::string_view const& sv);
    ConcretePath(std::string const& s);
    ConcretePath(char const* const t);

    // Existing comparison operators
    auto operator==(char const* const other) const -> bool;
    auto operator==(std::string_view const& other) const -> bool;
    auto operator==(ConcretePath<T> const& other) const -> bool;

    // New comparison operators
    auto operator<=>(const ConcretePath& other) const -> std::strong_ordering {
        return this->path <=> other.path;
    }

    // Comparison with string_view
    auto operator<=>(std::string_view other) const -> std::strong_ordering {
        return this->path <=> other;
    }

    // New comparison operators for different ConcretePath types
    template <typename U>
    auto operator<=>(const ConcretePath<U>& other) const -> std::strong_ordering {
        return std::string_view(this->path) <=> std::string_view(other.getPath());
    }

    template <typename U>
    auto operator==(const ConcretePath<U>& other) const -> bool {
        return std::string_view(this->path) == std::string_view(other.getPath());
    }

    // Explicit conversion to string_view
    explicit operator std::string_view() const noexcept {
        return this->path;
    }
};

// Non-member comparison operators for symmetry
template <typename T>
auto operator<=>(std::string_view lhs, const ConcretePath<T>& rhs) -> std::strong_ordering {
    return lhs <=> std::string_view(rhs.getPath());
}

template <typename T>
auto operator==(std::string_view lhs, const ConcretePath<T>& rhs) -> bool {
    return lhs == std::string_view(rhs.getPath());
}

// New non-member comparison operators for different ConcretePath types
template <typename T, typename U>
auto operator<=>(const ConcretePath<T>& lhs, const ConcretePath<U>& rhs) -> std::strong_ordering {
    return std::string_view(lhs.getPath()) <=> std::string_view(rhs.getPath());
}

template <typename T, typename U>
auto operator==(const ConcretePath<T>& lhs, const ConcretePath<U>& rhs) -> bool {
    return std::string_view(lhs.getPath()) == std::string_view(rhs.getPath());
}

using ConcretePathString = ConcretePath<std::string>;
using ConcretePathStringView = ConcretePath<std::string_view>;

} // namespace SP

namespace std {
template <typename T>
struct hash<SP::ConcretePath<T>> {
    size_t operator()(const SP::ConcretePath<T>& path) const noexcept {
        return hash<string_view>{}(static_cast<string_view>(path));
    }
};
} // namespace std</ConcretePath.hpp>

<!-- === ./src/pathspace/path/GlobPath.cpp === -->
<GlobPath.cpp>
#include "GlobPath.hpp"

namespace SP {
template <typename T>
auto GlobPath<T>::begin() const -> GlobPathIterator<T> {
    return {this->path.begin(), this->path.end()};
}

template <typename T>
auto GlobPath<T>::end() const -> GlobPathIterator<T> {
    return {this->path.end(), this->path.end()};
}

template <typename T>
GlobPath<T>::GlobPath(std::string_view const& sv) : Path<T>(std::is_same_v<T, std::string> ? T(std::string(sv)) : T(sv)) {
}

template <typename T>
GlobPath<T>::GlobPath(std::string const& s) : Path<T>(s) {
}

template <typename T>
GlobPath<T>::GlobPath(char const* path) : Path<T>(path) {
}

template <typename T>
auto GlobPath<T>::operator<=>(GlobPath<T> const& other) const -> std::strong_ordering {
    return this->path <=> other.path;
}

template <typename T>
auto GlobPath<T>::operator==(std::string_view const& otherView) const -> bool {
    return this->operator==(ConcretePathStringView{otherView});
}

template <typename T>
template <typename U>
auto GlobPath<T>::operator==(GlobPath<U> const& other) const -> bool {
    return ConcretePathStringView{this->path} == ConcretePathStringView{other.getPath()};
}

template <typename T>
template <typename U>
auto GlobPath<T>::operator==(ConcretePath<U> const& other) const -> bool {
    if (!this->isValid() || !other.isValid())
        return false;
    auto iterA = this->begin();
    auto iterB = other.begin();
    while (iterA != this->end() && iterB != other.end()) {
        auto const match = (*iterA).match(*iterB);
        if (std::get<1>(match)) // Supermatch (**)
            return true;
        if (!std::get<0>(match))
            return false;
        ++iterA;
        ++iterB;
    }
    if (iterA != this->end() || iterB != other.end())
        return false;
    return true;
}

template <typename T>
auto GlobPath<T>::isConcrete() const -> bool {
    return !this->isGlob();
}

template <typename T>
auto GlobPath<T>::isGlob() const -> bool {
    return is_glob(this->path);
}

template struct GlobPath<std::string>;
template auto GlobPathString::operator==(ConcretePathString const&) const -> bool;
template auto GlobPathString::operator==(ConcretePathStringView const&) const -> bool;
template auto GlobPathString::operator==(GlobPathString const&) const -> bool;
template auto GlobPathString::operator==(GlobPathStringView const&) const -> bool;

template struct GlobPath<std::string_view>;
template auto GlobPathStringView::operator==(ConcretePathString const&) const -> bool;
template auto GlobPathStringView::operator==(ConcretePathStringView const&) const -> bool;
template auto GlobPathStringView::operator==(GlobPathString const&) const -> bool;
template auto GlobPathStringView::operator==(GlobPathStringView const&) const -> bool;
} // namespace SP</GlobPath.cpp>

<!-- === ./src/pathspace/path/GlobPathIterator.cpp === -->
<GlobPathIterator.cpp>
#include "GlobPathIterator.hpp"

namespace SP {
template <typename T>
GlobPathIterator<T>::GlobPathIterator(T::const_iterator const& iter, T::const_iterator const& endIter)
    : begin(iter), current(iter), end(endIter) {
}

template <typename T>
auto GlobPathIterator<T>::operator++() -> GlobPathIterator<T>& {
    this->skipSlashes(this->current); // Will only happen at beginning
    this->skipNonSlashes(this->current);
    this->skipSlashes(this->current);
    return *this;
}

template <typename T>
auto GlobPathIterator<T>::operator++(int) -> GlobPathIterator<T> {
    GlobPathIterator<T> current = *this;
    this->operator++();
    return current;
}

template <typename T>
auto GlobPathIterator<T>::operator==(const GlobPathIterator<T>& other) const -> bool {
    return this->current == other.current;
}

template <typename T>
auto GlobPathIterator<T>::operator*() const -> GlobName {
    auto startSub = this->current;
    auto currentSub = this->current;

    this->skipSlashes(startSub);   // Will only happen at beginning
    this->skipSlashes(currentSub); // Will only happen at beginning
    this->skipNonSlashes(currentSub);
    return {startSub, currentSub};
}

template <typename T>
auto GlobPathIterator<T>::isAtStart() const -> bool {
    return this->begin == this->current;
}

template <typename T>
auto GlobPathIterator<T>::fullPath() const -> std::string_view {
    return std::string_view(this->begin, this->end);
}

template <typename T>
auto GlobPathIterator<T>::skipSlashes(SIterator& iter) const -> void {
    while (iter != this->end && *iter == '/')
        ++iter;
}

template <typename T>
auto GlobPathIterator<T>::skipNonSlashes(SIterator& iter) const -> void {
    while (iter != this->end && *iter != '/')
        ++iter;
}

template struct GlobPathIterator<std::string>;
template struct GlobPathIterator<std::string_view>;
} // namespace SP</GlobPathIterator.cpp>

<!-- === ./src/pathspace/path/ConcretePathIterator.cpp === -->
<ConcretePathIterator.cpp>
#include "ConcretePathIterator.hpp"

namespace SP {
template <typename T>
ConcretePathIterator<T>::ConcretePathIterator(T::const_iterator const& iter, T::const_iterator const& endIter)
    : begin(iter), current(iter), end(endIter) {
}

template <typename T>
auto ConcretePathIterator<T>::operator++() -> ConcretePathIterator<T>& {
    this->skipSlashes(this->current); // Will only happen at beginning
    this->skipNonSlashes(this->current);
    this->skipSlashes(this->current);
    return *this;
}

template <typename T>
auto ConcretePathIterator<T>::operator==(const ConcretePathIterator<T>& other) const -> bool {
    return this->current == other.current;
}

template <typename T>
auto ConcretePathIterator<T>::operator*() const -> ConcreteNameStringView {
    auto startSub = this->current;
    auto currentSub = this->current;

    this->skipSlashes(startSub);   // Will only happen at beginning
    this->skipSlashes(currentSub); // Will only happen at beginning
    this->skipNonSlashes(currentSub);
    return {startSub, currentSub};
}

template <typename T>
auto ConcretePathIterator<T>::isAtStart() const -> bool {
    return this->begin == this->current;
}

template <typename T>
auto ConcretePathIterator<T>::fullPath() const -> std::string_view {
    return std::string_view(this->begin, this->end);
}

template <typename T>
auto ConcretePathIterator<T>::skipSlashes(SIterator& iter) const -> void {
    while (iter != this->end && *iter == '/')
        ++iter;
}

template <typename T>
auto ConcretePathIterator<T>::skipNonSlashes(SIterator& iter) const -> void {
    while (iter != this->end && *iter != '/')
        ++iter;
}

template struct ConcretePathIterator<std::string>;
template struct ConcretePathIterator<std::string_view>;
} // namespace SP</ConcretePathIterator.cpp>

<!-- === ./src/pathspace/path/GlobPathIterator.hpp === -->
<GlobPathIterator.hpp>
#pragma once
#include "GlobName.hpp"

#include <string>
#include <string_view>

namespace SP {

template <typename T>
struct GlobPathIterator {
    using iterator_category = std::forward_iterator_tag;
    using value_type = GlobName;
    using difference_type = std::ptrdiff_t;
    using pointer = const GlobName*;
    using reference = const GlobName&;
    using SIterator = T::const_iterator;

    GlobPathIterator(SIterator const& iter, SIterator const& endIter);

    auto operator++() -> GlobPathIterator<T>&;
    auto operator++(int) -> GlobPathIterator<T>;
    auto operator==(GlobPathIterator const& other) const -> bool;
    auto operator*() const -> GlobName;

    auto isAtStart() const -> bool;
    auto fullPath() const -> std::string_view;

private:
    auto skipSlashes(SIterator& iter) const -> void;
    auto skipNonSlashes(SIterator& iter) const -> void;
    SIterator begin;
    SIterator current;
    SIterator end;
};
using GlobPathIteratorString = GlobPathIterator<std::string>;
using GlobPathIteratorStringView = GlobPathIterator<std::string_view>;

} // namespace SP</GlobPathIterator.hpp>

<!-- === ./src/pathspace/path/ConcretePathIterator.hpp === -->
<ConcretePathIterator.hpp>
#pragma once
#include "ConcreteName.hpp"

#include <string>
#include <string_view>

namespace SP {

template <typename T>
struct ConcretePathIterator {
    using iterator_category = std::forward_iterator_tag;
    using value_type = ConcreteNameStringView;
    using difference_type = std::ptrdiff_t;
    using pointer = const ConcreteNameStringView*;
    using reference = const ConcreteNameStringView&;
    using SIterator = T::const_iterator;

    ConcretePathIterator(SIterator const& iter, SIterator const& endIter);

    auto operator++() -> ConcretePathIterator&;
    auto operator==(ConcretePathIterator const& other) const -> bool;
    auto operator*() const -> ConcreteNameStringView;

    auto isAtStart() const -> bool;
    auto fullPath() const -> std::string_view;

private:
    auto skipSlashes(SIterator& iter) const -> void;
    auto skipNonSlashes(SIterator& iter) const -> void;
    SIterator begin;
    SIterator current;
    SIterator end;
};
using ConcretePathIteratorString = ConcretePathIterator<std::string>;
using ConcretePathIteratorStringView = ConcretePathIterator<std::string_view>;

} // namespace SP</ConcretePathIterator.hpp>

<!-- === ./src/pathspace/path/ConstructiblePath.hpp === -->
<ConstructiblePath.hpp>
#pragma once

#include "path/Path.hpp"
#include <compare>
#include <concepts>
#include <string>
#include <string_view>

namespace SP {

class ConstructiblePath {
public:
    ConstructiblePath() noexcept : path("/") {
    }

    template <std::convertible_to<std::string_view> T>
    explicit ConstructiblePath(T&& str) : path(std::forward<T>(str)), isComplete(true) {
    }

    template <typename T>
    explicit ConstructiblePath(const Path<T>& p) : path(p.getPath()), isComplete(true) {
    }

    // Rule of zero
    ConstructiblePath(const ConstructiblePath&) = default;
    ConstructiblePath(ConstructiblePath&&) noexcept = default;
    ConstructiblePath& operator=(const ConstructiblePath&) = default;
    ConstructiblePath& operator=(ConstructiblePath&&) noexcept = default;
    ~ConstructiblePath() = default;

    // Three-way comparison
    auto operator<=>(const ConstructiblePath&) const = default;

    // Equality comparisons
    bool operator==(std::string_view other) const {
        return path == other;
    }

    bool operator==(const ConstructiblePath& other) const {
        return path == other.path;
    }

    template <typename T>
    bool operator==(const Path<T>& other) const {
        return path == other.getPath();
    }

    ConstructiblePath& append(std::string_view str) {
        if (!isComplete) {
            if (!str.empty()) {
                if (path.back() == '/' && str.front() == '/') {
                    // If both path and str have a slash, skip one
                    path.append(str.substr(1));
                } else if (path.back() != '/' && str.front() != '/') {
                    // If neither has a slash, add one
                    path += '/';
                    path.append(str);
                } else {
                    // In all other cases, just append
                    path.append(str);
                }
            }
        }
        return *this;
    }

    // Getters
    std::string_view getPath() const noexcept {
        return path;
    }
    bool isCompleted() const noexcept {
        return isComplete;
    }

    // Utility methods
    void markComplete() noexcept {
        isComplete = true;
    }
    void reset() {
        path = "/";
        isComplete = false;
    }

    // Conversion operator
    explicit operator std::string_view() const noexcept {
        return path;
    }

private:
    std::string path;
    bool isComplete = false;
};

// Non-member comparison functions
inline bool operator==(std::string_view lhs, const ConstructiblePath& rhs) {
    return lhs == rhs.getPath();
}

template <typename T>
inline bool operator==(const Path<T>& lhs, const ConstructiblePath& rhs) {
    return lhs.getPath() == rhs.getPath();
}

} // namespace SP</ConstructiblePath.hpp>

<!-- === ./src/pathspace/path/GlobName.hpp === -->
<GlobName.hpp>
#pragma once
#include "ConcreteName.hpp"

#include <string>
#include <string_view>

namespace SP {

auto is_glob(std::string_view const& strv) -> bool;

struct GlobName {
    GlobName(char const* const ptr);
    GlobName(std::string::const_iterator const& iter, std::string::const_iterator const& endIter);
    GlobName(std::string_view::const_iterator const& iter, std::string_view::const_iterator const& endIter);

    auto operator<=>(GlobName const& other) const -> std::strong_ordering;
    auto operator==(GlobName const& other) const -> bool;
    auto operator==(ConcreteNameStringView const& other) const -> bool;
    auto operator==(char const* const other) const -> bool;

    auto match(const std::string_view& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/>;
    auto match(const ConcreteNameStringView& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/>;
    auto match(const ConcreteNameString& str) const -> std::tuple<bool /*match*/, bool /*supermatch*/>;

    auto isConcrete() const -> bool;
    auto isGlob() const -> bool;
    auto getName() const -> std::string_view const&;

    template <class Archive>
    void serialize(Archive& ar) {
        ar(std::string{this->name});
    }

private:
    std::string_view name;
};

} // namespace SP</GlobName.hpp>

<!-- === ./src/pathspace/utils/WaitMap.hpp === -->
<WaitMap.hpp>
#pragma once
#include "path/ConcretePath.hpp"
#include <chrono>
#include <condition_variable>
#include <mutex>
#include <unordered_map>

namespace SP {

struct WaitMap {
    struct Guard {
        Guard(WaitMap& waitMap, ConcretePathString const& path, std::unique_lock<std::mutex> lock)
            : waitMap(waitMap), path(path), lock(std::move(lock)) {
        }

        template <typename Pred>
        bool wait_until(std::chrono::time_point<std::chrono::system_clock> timeout, Pred pred) {
            return waitMap.getCv(path).wait_until(lock, timeout, std::move(pred));
        }

    private:
        WaitMap& waitMap;
        ConcretePathString path;
        std::unique_lock<std::mutex> lock;
    };

    auto wait(ConcretePathStringView const& path) -> Guard {
        return Guard(*this, ConcretePathString{path.getPath()}, std::unique_lock<std::mutex>(mutex));
    }

    auto notify(ConcretePathStringView const& path) -> void {
        std::lock_guard<std::mutex> lock(mutex);
        auto it = cvMap.find(ConcretePathString{path.getPath()});
        if (it != cvMap.end()) {
            it->second.notify_all();
        }
    }

    auto notifyAll() -> void {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto& [_, cv] : cvMap) {
            cv.notify_all();
        }
    }

    auto clear() -> void {
        std::lock_guard<std::mutex> lock(mutex);
        cvMap.clear();
    }

private:
    friend struct Guard;

    auto getCv(ConcretePathString const& path) -> std::condition_variable& {
        return cvMap[path];
    }

    mutable std::mutex mutex;
    std::unordered_map<ConcretePathString, std::condition_variable> cvMap;
};

} // namespace SP</WaitMap.hpp>

<!-- === ./src/pathspace/utils/TaggedLogger.hpp === -->
<TaggedLogger.hpp>
#pragma once

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

namespace SP {

class TaggedLogger {
public:
    struct LogMessage {
        std::chrono::system_clock::time_point timestamp;
        std::vector<std::string> tags;
        std::string message;
        std::string threadName;
    };

    TaggedLogger();
    ~TaggedLogger();

    TaggedLogger(const TaggedLogger&) = delete;
    TaggedLogger& operator=(const TaggedLogger&) = delete;
    TaggedLogger(TaggedLogger&&) = delete;
    TaggedLogger& operator=(TaggedLogger&&) = delete;

    template <typename... Tags>
    auto log(const std::string& message, Tags&&... tags) -> void;

    auto setThreadName(const std::string& name) -> void;
    auto setLoggingEnabled(bool enabled) -> void;

    static std::mutex coutMutex;

private:
    std::queue<LogMessage> messageQueue;
    mutable std::mutex queueMutex;
    std::condition_variable cv;
    std::thread workerThread;
    std::atomic<bool> running;
    std::atomic<bool> loggingEnabled;

    std::unordered_map<std::thread::id, std::string> threadNames;
    mutable std::mutex threadNamesMutex;
    std::atomic<int> nextThreadNumber;

    auto processQueue() -> void;
    auto writeToStderr(const LogMessage& msg) const -> void;
    auto getThreadName(const std::thread::id& id) -> std::string;
};

// Inline function definitions

inline TaggedLogger& logger() {
    static TaggedLogger instance;
    return instance;
}

template <typename... Tags>
auto TaggedLogger::log(const std::string& message, Tags&&... tags) -> void {
    if (!loggingEnabled)
        return;

    const auto logMessage = LogMessage{.timestamp = std::chrono::system_clock::now(),
                                       .tags = {std::forward<Tags>(tags)...},
                                       .message = message,
                                       .threadName = getThreadName(std::this_thread::get_id())};

    {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->messageQueue.push(std::move(logMessage));
        this->cv.notify_one();
    }
}

template <typename... Args>
inline void log(Args&&... args) {
    // logger().log(std::forward<Args>(args)...);
}

inline void set_thread_name(const std::string& name) {
    logger().setThreadName(name);
}

inline void set_logging_enabled(bool enabled) {
    logger().setLoggingEnabled(enabled);
}

} // namespace SP</TaggedLogger.hpp>

<!-- === ./src/pathspace/utils/TaggedLogger.cpp === -->
<TaggedLogger.cpp>
#include "TaggedLogger.hpp"

namespace SP {

std::mutex TaggedLogger::coutMutex;

TaggedLogger::TaggedLogger() : running(true), nextThreadNumber(0), loggingEnabled(true) {
    this->workerThread = std::thread(&TaggedLogger::processQueue, this);
}

TaggedLogger::~TaggedLogger() {
    {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->running = false;
        this->cv.notify_one();
    }
    if (this->workerThread.joinable()) {
        this->workerThread.join();
    }
}

auto TaggedLogger::setThreadName(const std::string& name) -> void {
    const auto threadId = std::this_thread::get_id();
    std::lock_guard<std::mutex> lock(threadNamesMutex);
    threadNames[threadId] = name;
}

auto TaggedLogger::setLoggingEnabled(bool enabled) -> void {
    loggingEnabled.store(enabled, std::memory_order_relaxed);
}

auto TaggedLogger::processQueue() -> void {
    while (true) {
        std::unique_lock<std::mutex> lock(this->queueMutex);
        this->cv.wait(lock, [this] { return !this->messageQueue.empty() || !this->running; });

        if (!this->running && this->messageQueue.empty()) {
            return;
        }

        while (!this->messageQueue.empty()) {
            const auto msg = std::move(this->messageQueue.front());
            this->messageQueue.pop();
            lock.unlock();
            this->writeToStderr(msg);
            lock.lock();
        }
    }
}

auto TaggedLogger::writeToStderr(const LogMessage& msg) const -> void {
    const auto now = msg.timestamp;
    const auto nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
    const auto nowTimeT = std::chrono::system_clock::to_time_t(now);
    const auto* nowTm = std::localtime(&nowTimeT);

    std::ostringstream oss;
    oss << std::put_time(nowTm, "%Y-%m-%d %H:%M:%S") << '.' << std::setfill('0') << std::setw(3) << nowMs.count() << ' ';

    oss << '[';
    for (size_t i = 0; i < msg.tags.size(); ++i) {
        if (i > 0)
            oss << "][";
        oss << msg.tags[i];
    }
    oss << "] ";

    oss << "[" << msg.threadName << "] ";
    oss << msg.message << '\n';

    std::lock_guard<std::mutex> lock(coutMutex);
    std::cerr << oss.str() << std::flush;
}

auto TaggedLogger::getThreadName(const std::thread::id& id) -> std::string {
    std::lock_guard<std::mutex> lock(threadNamesMutex);
    auto it = threadNames.find(id);
    if (it != threadNames.end()) {
        return it->second;
    } else {
        std::string name = "Thread " + std::to_string(nextThreadNumber++);
        threadNames[id] = name;
        return name;
    }
}

} // namespace SP</TaggedLogger.cpp>

